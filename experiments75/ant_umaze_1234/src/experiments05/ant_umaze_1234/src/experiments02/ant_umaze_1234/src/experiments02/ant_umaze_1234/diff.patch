diff --git a/configs/env_tingwu/ant_umaze.yml b/configs/env_tingwu/ant_umaze.yml
index f653d95..ab75516 100644
--- a/configs/env_tingwu/ant_umaze.yml
+++ b/configs/env_tingwu/ant_umaze.yml
@@ -5,6 +5,4 @@ runner:
   max_steps: 1000
 plan:
   max_steps: 1000
-pc: 
-  bonus_scale: 0.1  
 
diff --git a/experiments05/ant_umaze_1234/config.yml b/experiments05/ant_umaze_1234/config.yml
new file mode 100644
index 0000000..cad5fe6
--- /dev/null
+++ b/experiments05/ant_umaze_1234/config.yml
@@ -0,0 +1,76 @@
+OUNoise:
+  sigma: 0.3
+  theta: 0.15
+PPO:
+  clip_range: 0.2
+  ent_coef: 0.005
+  lr: 0.0003
+  n_minibatches: 32
+  n_opt_epochs: 10
+TRPO:
+  cg_damping: 0.1
+  ent_coef: 0
+  max_kl: 0.01
+  n_cg_iters: 10
+  n_vf_iters: 5
+  vf_lr: 0.001
+algorithm: OLBO
+ckpt:
+  base: /tmp/mbrl/logs
+  buf_load: null
+  buf_load_index: 0
+  model_load: null
+  n_save_stages: 10
+  policy_load: null
+  warm_up: null
+commit: 7315421ee85a3e3a88f7b5e93c10320b95aa84c5
+env:
+  id: AntUMaze-v1
+log_dir: ./experiments05/ant_umaze_1234
+model:
+  G_coef: 0.5
+  dev_batch_size: 512
+  hidden_sizes:
+  - 500
+  - 500
+  loss: L2
+  lr: 0.001
+  multi_step: 2
+  optimizer: Adam
+  train_batch_size: 128
+  validation_freq: 1
+  weight_decay: 1.0e-05
+pc:
+  bonus_scale: 0.5
+  bonus_stop_time: 30
+  lamb: 0.01
+plan:
+  max_steps: 1000
+  n_envs: 4
+  n_trpo_samples: 4000
+policy:
+  hidden_sizes:
+  - 32
+  - 32
+  init_std: 1.0
+rollout:
+  max_buf_size: 100000
+  n_dev_samples: 4000
+  n_test_samples: 10000
+  n_train_samples: 4000
+  normalizer: policy
+run_id: null
+runner:
+  gamma: 0.99
+  lambda_: 0.95
+  max_steps: 1000
+seed: 1234
+slbo:
+  n_evaluate_iters: 5
+  n_iters: 20
+  n_model_iters: 100
+  n_policy_iters: 40
+  n_stages: 50
+  opt_model: false
+  start: reset
+use_prev: true
diff --git a/experiments05/ant_umaze_1234/diff.patch b/experiments05/ant_umaze_1234/diff.patch
new file mode 100644
index 0000000..cf39b3b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/diff.patch
@@ -0,0 +1,156 @@
+diff --git a/configs/env_tingwu/ant_umaze.yml b/configs/env_tingwu/ant_umaze.yml
+index f653d95..ab75516 100644
+--- a/configs/env_tingwu/ant_umaze.yml
++++ b/configs/env_tingwu/ant_umaze.yml
+@@ -5,6 +5,4 @@ runner:
+   max_steps: 1000
+ plan:
+   max_steps: 1000
+-pc: 
+-  bonus_scale: 0.1  
+ 
+diff --git a/lunzi/__pycache__/Logger.cpython-36.pyc b/lunzi/__pycache__/Logger.cpython-36.pyc
+index c62e4dc..cd65096 100644
+Binary files a/lunzi/__pycache__/Logger.cpython-36.pyc and b/lunzi/__pycache__/Logger.cpython-36.pyc differ
+diff --git a/lunzi/__pycache__/__init__.cpython-36.pyc b/lunzi/__pycache__/__init__.cpython-36.pyc
+index d0052a1..bb94071 100644
+Binary files a/lunzi/__pycache__/__init__.cpython-36.pyc and b/lunzi/__pycache__/__init__.cpython-36.pyc differ
+diff --git a/lunzi/__pycache__/config.cpython-36.pyc b/lunzi/__pycache__/config.cpython-36.pyc
+index 38e50cc..151d0cd 100644
+Binary files a/lunzi/__pycache__/config.cpython-36.pyc and b/lunzi/__pycache__/config.cpython-36.pyc differ
+diff --git a/lunzi/__pycache__/dataset.cpython-36.pyc b/lunzi/__pycache__/dataset.cpython-36.pyc
+index f5f173f..673cfda 100644
+Binary files a/lunzi/__pycache__/dataset.cpython-36.pyc and b/lunzi/__pycache__/dataset.cpython-36.pyc differ
+diff --git a/lunzi/__pycache__/stubs.cpython-36.pyc b/lunzi/__pycache__/stubs.cpython-36.pyc
+index 40d1d88..ac6d28a 100644
+Binary files a/lunzi/__pycache__/stubs.cpython-36.pyc and b/lunzi/__pycache__/stubs.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/__init__.cpython-36.pyc b/lunzi/nn/__pycache__/__init__.cpython-36.pyc
+index 2082353..d28b7c9 100644
+Binary files a/lunzi/nn/__pycache__/__init__.cpython-36.pyc and b/lunzi/nn/__pycache__/__init__.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/container.cpython-36.pyc b/lunzi/nn/__pycache__/container.cpython-36.pyc
+index fd7039b..f16264f 100644
+Binary files a/lunzi/nn/__pycache__/container.cpython-36.pyc and b/lunzi/nn/__pycache__/container.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/flat_param.cpython-36.pyc b/lunzi/nn/__pycache__/flat_param.cpython-36.pyc
+index dc8e6f9..792725a 100644
+Binary files a/lunzi/nn/__pycache__/flat_param.cpython-36.pyc and b/lunzi/nn/__pycache__/flat_param.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/layers.cpython-36.pyc b/lunzi/nn/__pycache__/layers.cpython-36.pyc
+index 3f22fba..9fd6751 100644
+Binary files a/lunzi/nn/__pycache__/layers.cpython-36.pyc and b/lunzi/nn/__pycache__/layers.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/loss.cpython-36.pyc b/lunzi/nn/__pycache__/loss.cpython-36.pyc
+index 9fa218d..10a1d20 100644
+Binary files a/lunzi/nn/__pycache__/loss.cpython-36.pyc and b/lunzi/nn/__pycache__/loss.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/module.cpython-36.pyc b/lunzi/nn/__pycache__/module.cpython-36.pyc
+index c0f0f4a..9088e26 100644
+Binary files a/lunzi/nn/__pycache__/module.cpython-36.pyc and b/lunzi/nn/__pycache__/module.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/parameter.cpython-36.pyc b/lunzi/nn/__pycache__/parameter.cpython-36.pyc
+index 5191416..2131727 100644
+Binary files a/lunzi/nn/__pycache__/parameter.cpython-36.pyc and b/lunzi/nn/__pycache__/parameter.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/patch.cpython-36.pyc b/lunzi/nn/__pycache__/patch.cpython-36.pyc
+index d535500..78a52be 100644
+Binary files a/lunzi/nn/__pycache__/patch.cpython-36.pyc and b/lunzi/nn/__pycache__/patch.cpython-36.pyc differ
+diff --git a/lunzi/nn/__pycache__/utils.cpython-36.pyc b/lunzi/nn/__pycache__/utils.cpython-36.pyc
+index 1c808e8..f1860e7 100644
+Binary files a/lunzi/nn/__pycache__/utils.cpython-36.pyc and b/lunzi/nn/__pycache__/utils.cpython-36.pyc differ
+diff --git a/run2.sh b/run2.sh
+new file mode 100644
+index 0000000..7440dc5
+--- /dev/null
++++ b/run2.sh
+@@ -0,0 +1,10 @@
++#!/usr/bin/env bash
++
++for env_name in $1; do
++    echo "=> Running environment ${env_name}"
++    #for random_seed in 1234 2314 2345 1235; do
++    for random_seed in 1234; do
++        python main.py -c configs/algos/slbo_bm_200k.yml configs/env_tingwu/${env_name}.yml \
++	    -s pc.bonus_scale=0.2 log_dir=./experiments02/${env_name}_${random_seed} seed=${random_seed}
++    done
++done
+diff --git a/run_experiments.sh b/run_experiments.sh
+index 37ce016..e3f2ad7 100644
+--- a/run_experiments.sh
++++ b/run_experiments.sh
+@@ -3,8 +3,8 @@
+ for env_name in $1; do
+     echo "=> Running environment ${env_name}"
+     #for random_seed in 1234 2314 2345 1235; do
+-    for random_seed in 19; do
++    for random_seed in 1234; do
+         python main.py -c configs/algos/slbo_bm_200k.yml configs/env_tingwu/${env_name}.yml \
+-	    -s log_dir=./experiments/${env_name}_${random_seed} seed=${random_seed}
++	    -s pc.bonus_scale=0.5 log_dir=./experiments05/${env_name}_${random_seed} seed=${random_seed}
+     done
+ done
+diff --git a/slbo/__pycache__/__init__.cpython-36.pyc b/slbo/__pycache__/__init__.cpython-36.pyc
+index 069fa36..6a33858 100644
+Binary files a/slbo/__pycache__/__init__.cpython-36.pyc and b/slbo/__pycache__/__init__.cpython-36.pyc differ
+diff --git a/slbo/__pycache__/dynamics_model.cpython-36.pyc b/slbo/__pycache__/dynamics_model.cpython-36.pyc
+index d9193cb..91423ce 100644
+Binary files a/slbo/__pycache__/dynamics_model.cpython-36.pyc and b/slbo/__pycache__/dynamics_model.cpython-36.pyc differ
+diff --git a/slbo/__pycache__/partial_envs.cpython-36.pyc b/slbo/__pycache__/partial_envs.cpython-36.pyc
+index f20520d..7ad21fc 100644
+Binary files a/slbo/__pycache__/partial_envs.cpython-36.pyc and b/slbo/__pycache__/partial_envs.cpython-36.pyc differ
+diff --git a/slbo/__pycache__/random_net.cpython-36.pyc b/slbo/__pycache__/random_net.cpython-36.pyc
+index 7688576..6e866b0 100644
+Binary files a/slbo/__pycache__/random_net.cpython-36.pyc and b/slbo/__pycache__/random_net.cpython-36.pyc differ
+diff --git a/slbo/algos/__pycache__/TRPO.cpython-36.pyc b/slbo/algos/__pycache__/TRPO.cpython-36.pyc
+index 99cdd6a..9ba8329 100644
+Binary files a/slbo/algos/__pycache__/TRPO.cpython-36.pyc and b/slbo/algos/__pycache__/TRPO.cpython-36.pyc differ
+diff --git a/slbo/algos/__pycache__/__init__.cpython-36.pyc b/slbo/algos/__pycache__/__init__.cpython-36.pyc
+index 09f2f9c..9c74708 100644
+Binary files a/slbo/algos/__pycache__/__init__.cpython-36.pyc and b/slbo/algos/__pycache__/__init__.cpython-36.pyc differ
+diff --git a/slbo/loss/__pycache__/__init__.cpython-36.pyc b/slbo/loss/__pycache__/__init__.cpython-36.pyc
+index f1c5979..cc5457b 100644
+Binary files a/slbo/loss/__pycache__/__init__.cpython-36.pyc and b/slbo/loss/__pycache__/__init__.cpython-36.pyc differ
+diff --git a/slbo/loss/__pycache__/multi_step_loss.cpython-36.pyc b/slbo/loss/__pycache__/multi_step_loss.cpython-36.pyc
+index 53c9a3d..695e469 100644
+Binary files a/slbo/loss/__pycache__/multi_step_loss.cpython-36.pyc and b/slbo/loss/__pycache__/multi_step_loss.cpython-36.pyc differ
+diff --git a/slbo/policies/__pycache__/__init__.cpython-36.pyc b/slbo/policies/__pycache__/__init__.cpython-36.pyc
+index a98e999..0f2ff6d 100644
+Binary files a/slbo/policies/__pycache__/__init__.cpython-36.pyc and b/slbo/policies/__pycache__/__init__.cpython-36.pyc differ
+diff --git a/slbo/policies/__pycache__/gaussian_mlp_policy.cpython-36.pyc b/slbo/policies/__pycache__/gaussian_mlp_policy.cpython-36.pyc
+index b355a90..3f0a156 100644
+Binary files a/slbo/policies/__pycache__/gaussian_mlp_policy.cpython-36.pyc and b/slbo/policies/__pycache__/gaussian_mlp_policy.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/OU_noise.cpython-36.pyc b/slbo/utils/__pycache__/OU_noise.cpython-36.pyc
+index 5819e5d..bdfb380 100644
+Binary files a/slbo/utils/__pycache__/OU_noise.cpython-36.pyc and b/slbo/utils/__pycache__/OU_noise.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/__init__.cpython-36.pyc b/slbo/utils/__pycache__/__init__.cpython-36.pyc
+index 0e85b1e..9df4fd9 100644
+Binary files a/slbo/utils/__pycache__/__init__.cpython-36.pyc and b/slbo/utils/__pycache__/__init__.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/average_meter.cpython-36.pyc b/slbo/utils/__pycache__/average_meter.cpython-36.pyc
+index 1bc0297..7fa8339 100644
+Binary files a/slbo/utils/__pycache__/average_meter.cpython-36.pyc and b/slbo/utils/__pycache__/average_meter.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/dataset.cpython-36.pyc b/slbo/utils/__pycache__/dataset.cpython-36.pyc
+index 0cc5d73..46a212c 100644
+Binary files a/slbo/utils/__pycache__/dataset.cpython-36.pyc and b/slbo/utils/__pycache__/dataset.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/flags.cpython-36.pyc b/slbo/utils/__pycache__/flags.cpython-36.pyc
+index dfd7feb..193bff4 100644
+Binary files a/slbo/utils/__pycache__/flags.cpython-36.pyc and b/slbo/utils/__pycache__/flags.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/multi_layer_perceptron.cpython-36.pyc b/slbo/utils/__pycache__/multi_layer_perceptron.cpython-36.pyc
+index ae136c1..eceaef9 100644
+Binary files a/slbo/utils/__pycache__/multi_layer_perceptron.cpython-36.pyc and b/slbo/utils/__pycache__/multi_layer_perceptron.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/normalizer.cpython-36.pyc b/slbo/utils/__pycache__/normalizer.cpython-36.pyc
+index 8c67648..574fc2b 100644
+Binary files a/slbo/utils/__pycache__/normalizer.cpython-36.pyc and b/slbo/utils/__pycache__/normalizer.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/np_utils.cpython-36.pyc b/slbo/utils/__pycache__/np_utils.cpython-36.pyc
+index e1f3150..d9d1d69 100644
+Binary files a/slbo/utils/__pycache__/np_utils.cpython-36.pyc and b/slbo/utils/__pycache__/np_utils.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/pc_utils.cpython-36.pyc b/slbo/utils/__pycache__/pc_utils.cpython-36.pyc
+index 0e894f3..b76bb46 100644
+Binary files a/slbo/utils/__pycache__/pc_utils.cpython-36.pyc and b/slbo/utils/__pycache__/pc_utils.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/runner.cpython-36.pyc b/slbo/utils/__pycache__/runner.cpython-36.pyc
+index 2678071..cce1028 100644
+Binary files a/slbo/utils/__pycache__/runner.cpython-36.pyc and b/slbo/utils/__pycache__/runner.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/tf_utils.cpython-36.pyc b/slbo/utils/__pycache__/tf_utils.cpython-36.pyc
+index 47606c4..59378e0 100644
+Binary files a/slbo/utils/__pycache__/tf_utils.cpython-36.pyc and b/slbo/utils/__pycache__/tf_utils.cpython-36.pyc differ
+diff --git a/slbo/utils/__pycache__/truncated_normal.cpython-36.pyc b/slbo/utils/__pycache__/truncated_normal.cpython-36.pyc
+index 6d8d1b4..a615a74 100644
+Binary files a/slbo/utils/__pycache__/truncated_normal.cpython-36.pyc and b/slbo/utils/__pycache__/truncated_normal.cpython-36.pyc differ
+diff --git a/slbo/v_function/__pycache__/__init__.cpython-36.pyc b/slbo/v_function/__pycache__/__init__.cpython-36.pyc
+index a38ef07..5932be7 100644
+Binary files a/slbo/v_function/__pycache__/__init__.cpython-36.pyc and b/slbo/v_function/__pycache__/__init__.cpython-36.pyc differ
+diff --git a/slbo/v_function/__pycache__/mlp_v_function.cpython-36.pyc b/slbo/v_function/__pycache__/mlp_v_function.cpython-36.pyc
+index dba380d..06cd147 100644
+Binary files a/slbo/v_function/__pycache__/mlp_v_function.cpython-36.pyc and b/slbo/v_function/__pycache__/mlp_v_function.cpython-36.pyc differ
diff --git a/experiments05/ant_umaze_1234/final.npy b/experiments05/ant_umaze_1234/final.npy
new file mode 100644
index 0000000..3081364
Binary files /dev/null and b/experiments05/ant_umaze_1234/final.npy differ
diff --git a/experiments05/ant_umaze_1234/log.json b/experiments05/ant_umaze_1234/log.json
new file mode 100644
index 0000000..697a515
--- /dev/null
+++ b/experiments05/ant_umaze_1234/log.json
@@ -0,0 +1,104 @@
+{"level": "info", "fmt": "log_dir = %s", "args": ["./experiments05/ant_umaze_1234"], "caller": "slbo/utils/flags.py:157", "time": "2021-02-04T22:06:16.576636"}
+{"level": "info", "fmt": "Enabling flattening... %s", "args": [["GaussianMLPPolicy_1/log_std:0", "GaussianMLPPolicy_1/Linear_1/weight:0", "GaussianMLPPolicy_1/Linear_1/bias:0", "GaussianMLPPolicy_1/Linear_1_2/weight:0", "GaussianMLPPolicy_1/Linear_1_2/bias:0", "GaussianMLPPolicy_1/Linear_2_1/weight:0", "GaussianMLPPolicy_1/Linear_2_1/bias:0"]], "caller": "lunzi/nn/flat_param.py:17", "time": "2021-02-04T22:06:18.960629"}
+{"level": "info", "fmt": "------ Starting Stage %d --------", "args": [0], "caller": "main.py:129", "time": "2021-02-04T22:06:19.998601"}
+{"level": "info", "fmt": "Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f", "args": ["episode", "Real Env", 8, 0.0, 0.0], "caller": "main.py:37", "time": "2021-02-04T22:06:28.500010"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["DynamicsModel", "[states actions] => [next_states]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:28.502822"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["RandomNet", "[states actions] => [features]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:28.538762"}
+{"level": "info", "fmt": "Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f", "args": ["episode", "Virt Env", 8, -7.284889785537853, 0.1432991688976139], "caller": "main.py:37", "time": "2021-02-04T22:06:33.022952"}
+{"level": "info", "fmt": "episode: %s", "args": [1.5049363137840386], "caller": "main.py:149", "time": "2021-02-04T22:06:42.796739"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["MultiStepLoss", "[states next_states_ actions masks] => [train loss grad_norm]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:43.195288"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["MultiStepLoss", "[states next_states_ actions masks] => [loss]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:45.545221"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [0, 0.9378997683525085, 0.8658612370491028, 100, 0.0445103133518442], "caller": "main.py:200", "time": "2021-02-04T22:06:45.625833"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["MLPVFunction", "[states] => [values]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:47.284993"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["TRPO", "[] => [sync_old]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:47.342512"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["TRPO", "[states actions advantages ent_coef] => [loss flat_grad dist_std mean_kl dist_mean]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:47.366344"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["TRPO", "[states tangents actions] => [hessian_vec_prod]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:47.508742"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["FlatParam", "[] => [get_flat]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:47.808253"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["FlatParam", "[feed_flat] => [set_flat]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:47.854704"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["TRPO", "[states actions advantages ent_coef] => [loss mean_kl]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:47.886948"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["TRPO", "[states returns] => [train_vf vf_loss]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:47.948213"}
+{"level": "info", "fmt": "[%s] is making TensorFlow callables, key = %s", "args": ["TRPO", "[states returns] => [vf_loss]"], "caller": "lunzi/nn/module.py:71", "time": "2021-02-04T22:06:48.262897"}
+{"level": "info", "fmt": "Violated kl constraints, shrinking step... mean_kl = %.6f, max_kl = %.6f", "args": [0.016324544325470924, 0.01], "caller": "slbo/algos/TRPO.py:155", "time": "2021-02-04T22:07:43.593863"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [1, 0.7674996852874756, 0.6594032049179077, 100, 0.18592303832996326], "caller": "main.py:200", "time": "2021-02-04T22:08:10.697304"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [2, 0.6140119433403015, 0.5865762829780579, 100, 0.29068448287322], "caller": "main.py:200", "time": "2021-02-04T22:09:35.164936"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [3, 0.5615626573562622, 0.5586785078048706, 100, 0.3232737593029521], "caller": "main.py:200", "time": "2021-02-04T22:10:59.071856"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [4, 0.5196434259414673, 0.5130995512008667, 100, 0.3634198417896201], "caller": "main.py:200", "time": "2021-02-04T22:12:25.863775"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [5, 0.48745059967041016, 0.47261008620262146, 100, 0.381774088106125], "caller": "main.py:200", "time": "2021-02-04T22:13:49.000563"}
+{"level": "info", "fmt": "Violated kl constraints, shrinking step... mean_kl = %.6f, max_kl = %.6f", "args": [0.015538932755589485, 0.01], "caller": "slbo/algos/TRPO.py:155", "time": "2021-02-04T22:14:04.970451"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [6, 0.46413275599479675, 0.43267542123794556, 100, 0.40544601227758975], "caller": "main.py:200", "time": "2021-02-04T22:15:12.233352"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [7, 0.4409376084804535, 0.43018847703933716, 100, 0.4347987842125016], "caller": "main.py:200", "time": "2021-02-04T22:16:35.703169"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [8, 0.4228054881095886, 0.40959271788597107, 100, 0.4525770934963645], "caller": "main.py:200", "time": "2021-02-04T22:17:59.243764"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [9, 0.4062086045742035, 0.39805346727371216, 100, 0.464379822863394], "caller": "main.py:200", "time": "2021-02-04T22:19:22.427830"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [10, 0.38758179545402527, 0.3727763295173645, 100, 0.4922852912052919], "caller": "main.py:200", "time": "2021-02-04T22:20:45.706091"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [11, 0.36915135383605957, 0.36561858654022217, 100, 0.5079268761961365], "caller": "main.py:200", "time": "2021-02-04T22:22:09.004981"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [12, 0.3513016402721405, 0.3548884391784668, 100, 0.5363482841312979], "caller": "main.py:200", "time": "2021-02-04T22:23:32.073457"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [13, 0.3346582353115082, 0.3185774087905884, 100, 0.5705401512409921], "caller": "main.py:200", "time": "2021-02-04T22:24:55.240207"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [14, 0.3141838014125824, 0.3186214864253998, 100, 0.5858541428456963], "caller": "main.py:200", "time": "2021-02-04T22:26:18.546528"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [15, 0.2984384596347809, 0.29204872250556946, 100, 0.6008404158945059], "caller": "main.py:200", "time": "2021-02-04T22:27:41.838724"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [16, 0.28569743037223816, 0.27806591987609863, 100, 0.672443496517648], "caller": "main.py:200", "time": "2021-02-04T22:29:05.087587"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [17, 0.27058354020118713, 0.26003047823905945, 100, 0.7046934481750561], "caller": "main.py:200", "time": "2021-02-04T22:30:28.263191"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [18, 0.2567311227321625, 0.24795295298099518, 100, 0.6876876067427548], "caller": "main.py:200", "time": "2021-02-04T22:31:51.223327"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [19, 0.24300675094127655, 0.24058246612548828, 100, 0.6691345238016474], "caller": "main.py:200", "time": "2021-02-04T22:33:14.495438"}
+{"level": "info", "fmt": "------ Starting Stage %d --------", "args": [1], "caller": "main.py:129", "time": "2021-02-04T22:34:35.655817"}
+{"level": "info", "fmt": "Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f", "args": ["episode", "Real Env", 8, 0.0, 0.0], "caller": "main.py:37", "time": "2021-02-04T22:34:44.369043"}
+{"level": "info", "fmt": "Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f", "args": ["episode", "Virt Env", 8, 27.192308183330308, 24.760283378785978], "caller": "main.py:37", "time": "2021-02-04T22:34:48.267922"}
+{"level": "info", "fmt": "episode: %s", "args": [1.489976007330652], "caller": "main.py:149", "time": "2021-02-04T22:34:58.121211"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [0, 0.3885601758956909, 0.350123792886734, 100, 0.5928953191045098], "caller": "main.py:200", "time": "2021-02-04T22:35:00.283383"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [1, 0.34407249093055725, 0.34708529710769653, 100, 0.5578546842374846], "caller": "main.py:200", "time": "2021-02-04T22:36:23.252016"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [2, 0.32253608107566833, 0.3255731463432312, 100, 0.5708341010834157], "caller": "main.py:200", "time": "2021-02-04T22:37:46.110918"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [3, 0.313480943441391, 0.30371248722076416, 100, 0.6192356213308033], "caller": "main.py:200", "time": "2021-02-04T22:39:09.192702"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [4, 0.2979777455329895, 0.29178136587142944, 100, 0.5731983556770285], "caller": "main.py:200", "time": "2021-02-04T22:40:31.981213"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [5, 0.2904617190361023, 0.2777021527290344, 100, 0.6256044807404524], "caller": "main.py:200", "time": "2021-02-04T22:41:54.926837"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [6, 0.28052788972854614, 0.2641128897666931, 100, 0.6070984631169711], "caller": "main.py:200", "time": "2021-02-04T22:43:17.806912"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [7, 0.2707897424697876, 0.27002131938934326, 100, 0.5908373644357169], "caller": "main.py:200", "time": "2021-02-04T22:44:40.655936"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [8, 0.2660534381866455, 0.2636871635913849, 100, 0.6013584124440604], "caller": "main.py:200", "time": "2021-02-04T22:46:03.514508"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [9, 0.25895369052886963, 0.25655531883239746, 100, 0.6216240509722881], "caller": "main.py:200", "time": "2021-02-04T22:47:26.590334"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [10, 0.25077924132347107, 0.2553086280822754, 100, 0.6017815517777431], "caller": "main.py:200", "time": "2021-02-04T22:48:49.516891"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [11, 0.24886669218540192, 0.23380886018276215, 100, 0.6649544762900109], "caller": "main.py:200", "time": "2021-02-04T22:50:12.335035"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [12, 0.24325209856033325, 0.23574472963809967, 100, 0.6566666015325962], "caller": "main.py:200", "time": "2021-02-04T22:51:35.301970"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [13, 0.23818263411521912, 0.23670199513435364, 100, 0.6738321166556774], "caller": "main.py:200", "time": "2021-02-04T22:52:58.254151"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [14, 0.23493073880672455, 0.2335895597934723, 100, 0.6719666754527466], "caller": "main.py:200", "time": "2021-02-04T22:54:21.252748"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [15, 0.2304995208978653, 0.23062093555927277, 100, 0.692142946650909], "caller": "main.py:200", "time": "2021-02-04T22:55:44.285615"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [16, 0.22534342110157013, 0.23156443238258362, 100, 0.6872498794702879], "caller": "main.py:200", "time": "2021-02-04T22:57:07.401667"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [17, 0.22134967148303986, 0.22219376266002655, 100, 0.648625861639487], "caller": "main.py:200", "time": "2021-02-04T22:58:30.390541"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [18, 0.21619480848312378, 0.2310514897108078, 100, 0.6517196726147292], "caller": "main.py:200", "time": "2021-02-04T22:59:53.255547"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [19, 0.21469898521900177, 0.2038353532552719, 100, 0.6756238823453481], "caller": "main.py:200", "time": "2021-02-04T23:01:16.160010"}
+{"level": "info", "fmt": "------ Starting Stage %d --------", "args": [2], "caller": "main.py:129", "time": "2021-02-04T23:02:37.002820"}
+{"level": "info", "fmt": "Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f", "args": ["episode", "Real Env", 8, 0.0, 0.0], "caller": "main.py:37", "time": "2021-02-04T23:02:45.523438"}
+{"level": "info", "fmt": "Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f", "args": ["episode", "Virt Env", 8, 13.267047479582477, 1.9088918151755696], "caller": "main.py:37", "time": "2021-02-04T23:02:49.424144"}
+{"level": "info", "fmt": "episode: %s", "args": [1.487764008239687], "caller": "main.py:149", "time": "2021-02-04T23:02:58.913970"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [0, 0.3144923150539398, 0.2991337478160858, 100, 0.6635317563347088], "caller": "main.py:200", "time": "2021-02-04T23:03:01.012835"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [1, 0.28729701042175293, 0.3148777484893799, 100, 0.6241637703152196], "caller": "main.py:200", "time": "2021-02-04T23:04:23.954885"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [2, 0.27259671688079834, 0.2707923650741577, 100, 0.5935929482581686], "caller": "main.py:200", "time": "2021-02-04T23:05:46.955610"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [3, 0.2694573998451233, 0.2647353410720825, 100, 0.5981501745579524], "caller": "main.py:200", "time": "2021-02-04T23:07:09.871475"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [4, 0.26527607440948486, 0.258899450302124, 100, 0.6539499264301571], "caller": "main.py:200", "time": "2021-02-04T23:08:32.990118"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [5, 0.2576935589313507, 0.2569398283958435, 100, 0.6086306899177365], "caller": "main.py:200", "time": "2021-02-04T23:09:55.835832"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [6, 0.25381457805633545, 0.24574750661849976, 100, 0.6171740683296058], "caller": "main.py:200", "time": "2021-02-04T23:11:18.832240"}
+{"level": "info", "fmt": "Violated kl constraints, shrinking step... mean_kl = %.6f, max_kl = %.6f", "args": [0.022534703835844994, 0.01], "caller": "slbo/algos/TRPO.py:155", "time": "2021-02-04T23:11:26.694358"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [7, 0.2511337697505951, 0.25088873505592346, 100, 0.6123427557332909], "caller": "main.py:200", "time": "2021-02-04T23:12:41.665803"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [8, 0.24774698913097382, 0.2308853566646576, 100, 0.6431975745511588], "caller": "main.py:200", "time": "2021-02-04T23:14:04.341207"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [9, 0.24619396030902863, 0.24259039759635925, 100, 0.651422682339376], "caller": "main.py:200", "time": "2021-02-04T23:15:27.195008"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [10, 0.24316495656967163, 0.265470027923584, 100, 0.6222608702752602], "caller": "main.py:200", "time": "2021-02-04T23:16:50.085719"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [11, 0.2408212423324585, 0.23947125673294067, 100, 0.6285275407997075], "caller": "main.py:200", "time": "2021-02-04T23:18:12.936986"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [12, 0.23787333071231842, 0.23752161860466003, 100, 0.6805508797680274], "caller": "main.py:200", "time": "2021-02-04T23:19:35.890560"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [13, 0.23594336211681366, 0.23638111352920532, 100, 0.6598031651313921], "caller": "main.py:200", "time": "2021-02-04T23:20:58.793084"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [14, 0.23323023319244385, 0.2264213263988495, 100, 0.6622032528453474], "caller": "main.py:200", "time": "2021-02-04T23:22:21.709722"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [15, 0.22890880703926086, 0.22115200757980347, 100, 0.6395868932561249], "caller": "main.py:200", "time": "2021-02-04T23:23:44.646134"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [16, 0.22666774690151215, 0.2260974496603012, 100, 0.6247618656725779], "caller": "main.py:200", "time": "2021-02-04T23:25:07.563841"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [17, 0.22472494840621948, 0.22024323046207428, 100, 0.6225398712727757], "caller": "main.py:200", "time": "2021-02-04T23:26:30.493156"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [18, 0.22352708876132965, 0.21198055148124695, 100, 0.6530370154323808], "caller": "main.py:200", "time": "2021-02-04T23:27:53.313411"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [19, 0.22073757648468018, 0.2294287532567978, 100, 0.662848564320083], "caller": "main.py:200", "time": "2021-02-04T23:29:16.214194"}
+{"level": "info", "fmt": "Violated kl constraints, shrinking step... mean_kl = %.6f, max_kl = %.6f", "args": [0.015084369108080864, 0.01], "caller": "slbo/algos/TRPO.py:155", "time": "2021-02-04T23:29:34.103943"}
+{"level": "info", "fmt": "------ Starting Stage %d --------", "args": [3], "caller": "main.py:129", "time": "2021-02-04T23:30:36.847258"}
+{"level": "info", "fmt": "Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f", "args": ["episode", "Real Env", 8, 0.0, 0.0], "caller": "main.py:37", "time": "2021-02-04T23:30:45.167955"}
+{"level": "info", "fmt": "Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f", "args": ["episode", "Virt Env", 8, 47.932426984214715, 40.372009165803384], "caller": "main.py:37", "time": "2021-02-04T23:30:49.084754"}
+{"level": "info", "fmt": "episode: %s", "args": [-0.7433383015969701], "caller": "main.py:149", "time": "2021-02-04T23:30:58.423775"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [0, 0.2656884491443634, 0.2537093758583069, 100, 0.6232987427088188], "caller": "main.py:200", "time": "2021-02-04T23:31:00.517908"}
+{"level": "info", "fmt": "Violated kl constraints, shrinking step... mean_kl = %.6f, max_kl = %.6f", "args": [0.016556521877646446, 0.01], "caller": "slbo/algos/TRPO.py:155", "time": "2021-02-04T23:31:42.621634"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [1, 0.2495730221271515, 0.2373039424419403, 100, 0.6469324394413607], "caller": "main.py:200", "time": "2021-02-04T23:32:23.377174"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [2, 0.24598462879657745, 0.23024287819862366, 100, 0.6409468358114165], "caller": "main.py:200", "time": "2021-02-04T23:33:46.352348"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [3, 0.2429787665605545, 0.24423713982105255, 100, 0.6559720181762851], "caller": "main.py:200", "time": "2021-02-04T23:35:09.392199"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [4, 0.2384742945432663, 0.19784434139728546, 100, 0.6408335500314748], "caller": "main.py:200", "time": "2021-02-04T23:36:32.369834"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [5, 0.23314964771270752, 0.21497824788093567, 100, 0.6509717588965804], "caller": "main.py:200", "time": "2021-02-04T23:37:55.184743"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [6, 0.23205643892288208, 0.2285858690738678, 100, 0.663094974093885], "caller": "main.py:200", "time": "2021-02-04T23:39:18.300826"}
+{"level": "info", "fmt": "# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f", "args": [7, 0.23327691853046417, 0.24604706466197968, 100, 0.692660083701486], "caller": "main.py:200", "time": "2021-02-04T23:40:41.044261"}
diff --git a/experiments05/ant_umaze_1234/src/.gitignore b/experiments05/ant_umaze_1234/src/.gitignore
new file mode 100644
index 0000000..01e12c7
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/.gitignore
@@ -0,0 +1,132 @@
+# Byte-compiled / optimized / DLL files
+__pycache__/
+*.py[cod]
+*$py.class
+
+# C extensions
+*.so
+
+# Distribution / packaging
+.Python
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+wheels/
+pip-wheel-metadata/
+share/python-wheels/
+*.egg-info/
+.installed.cfg
+*.egg
+MANIFEST
+vendor/
+rllab/
+tmp/
+log/
+experiments/
+# PyInstaller
+#  Usually these files are written by a python script from a template
+#  before PyInstaller builds the exe, so as to inject date/other infos into it.
+*.manifest
+*.spec
+
+# Installer logs
+pip-log.txt
+pip-delete-this-directory.txt
+
+# Unit test / coverage reports
+htmlcov/
+.tox/
+.nox/
+.coverage
+.coverage.*
+.cache
+nosetests.xml
+coverage.xml
+*.cover
+*.py,cover
+.hypothesis/
+.pytest_cache/
+
+# Translations
+*.mo
+*.pot
+
+# Django stuff:
+*.log
+local_settings.py
+db.sqlite3
+db.sqlite3-journal
+
+# Flask stuff:
+instance/
+.webassets-cache
+
+# Scrapy stuff:
+.scrapy
+
+# Sphinx documentation
+docs/_build/
+
+# PyBuilder
+target/
+
+# Jupyter Notebook
+.ipynb_checkpoints
+
+# IPython
+profile_default/
+ipython_config.py
+
+# pyenv
+.python-version
+
+# pipenv
+#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
+#   However, in case of collaboration, if having platform-specific dependencies or dependencies
+#   having no cross-platform support, pipenv may install dependencies that don't work, or not
+#   install all needed dependencies.
+#Pipfile.lock
+
+# PEP 582; used by e.g. github.com/David-OConnor/pyflow
+__pypackages__/
+
+# Celery stuff
+celerybeat-schedule
+celerybeat.pid
+
+# SageMath parsed files
+*.sage.py
+
+# Environments
+.env
+.venv
+venv/
+ENV/
+env.bak/
+venv.bak/
+
+# Spyder project settings
+.spyderproject
+.spyproject
+
+# Rope project settings
+.ropeproject
+
+# mkdocs documentation
+/site
+
+# mypy
+.mypy_cache/
+.dmypy.json
+dmypy.json
+
+# Pyre type checker
+.pyre/
diff --git a/experiments05/ant_umaze_1234/src/CODE_OF_CONDUCT.md b/experiments05/ant_umaze_1234/src/CODE_OF_CONDUCT.md
new file mode 100644
index 0000000..0d31b1f
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/CODE_OF_CONDUCT.md
@@ -0,0 +1,5 @@
+# Code of Conduct
+
+Facebook has adopted a Code of Conduct that we expect project participants to adhere to.
+Please read the [full text](https://code.fb.com/codeofconduct/)
+so that you can understand what actions will and will not be tolerated.
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/CONTRIBUTING.md b/experiments05/ant_umaze_1234/src/CONTRIBUTING.md
new file mode 100644
index 0000000..07780f7
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/CONTRIBUTING.md
@@ -0,0 +1,31 @@
+# Contributing to SLBO
+We want to make contributing to this project as easy and transparent as
+possible.
+
+## Pull Requests
+We actively welcome your pull requests.
+
+1. Fork the repo and create your branch from `master`.
+2. Ensure the examples still run.
+3. If you haven't already, complete the Contributor License Agreement ("CLA").
+
+## Contributor License Agreement ("CLA")
+In order to accept your pull request, we need you to submit a CLA. You only need
+to do this once to work on any of Facebook's open source projects.
+
+Complete your CLA here: <https://code.facebook.com/cla>
+
+## Issues
+We use GitHub issues to track public bugs. Please ensure your description is
+clear and has sufficient instructions to be able to reproduce the issue.
+
+Facebook has a [bounty program](https://www.facebook.com/whitehat/) for the safe
+disclosure of security bugs. In those cases, please go through the process
+outlined on that page and do not file a public issue.
+
+## Coding Style  
+We try to follow the PEP style guidelines and encourage you to as well.
+
+## License
+By contributing to SparseConvNet, you agree that your contributions will be licensed
+under the LICENSE file in the root directory of this source tree.
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/LICENSE b/experiments05/ant_umaze_1234/src/LICENSE
new file mode 100644
index 0000000..1fe4148
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/LICENSE
@@ -0,0 +1,407 @@
+Attribution-NonCommercial 4.0 International
+
+=======================================================================
+
+Creative Commons Corporation ("Creative Commons") is not a law firm and
+does not provide legal services or legal advice. Distribution of
+Creative Commons public licenses does not create a lawyer-client or
+other relationship. Creative Commons makes its licenses and related
+information available on an "as-is" basis. Creative Commons gives no
+warranties regarding its licenses, any material licensed under their
+terms and conditions, or any related information. Creative Commons
+disclaims all liability for damages resulting from their use to the
+fullest extent possible.
+
+Using Creative Commons Public Licenses
+
+Creative Commons public licenses provide a standard set of terms and
+conditions that creators and other rights holders may use to share
+original works of authorship and other material subject to copyright
+and certain other rights specified in the public license below. The
+following considerations are for informational purposes only, are not
+exhaustive, and do not form part of our licenses.
+
+     Considerations for licensors: Our public licenses are
+     intended for use by those authorized to give the public
+     permission to use material in ways otherwise restricted by
+     copyright and certain other rights. Our licenses are
+     irrevocable. Licensors should read and understand the terms
+     and conditions of the license they choose before applying it.
+     Licensors should also secure all rights necessary before
+     applying our licenses so that the public can reuse the
+     material as expected. Licensors should clearly mark any
+     material not subject to the license. This includes other CC-
+     licensed material, or material used under an exception or
+     limitation to copyright. More considerations for licensors:
+	wiki.creativecommons.org/Considerations_for_licensors
+
+     Considerations for the public: By using one of our public
+     licenses, a licensor grants the public permission to use the
+     licensed material under specified terms and conditions. If
+     the licensor's permission is not necessary for any reason--for
+     example, because of any applicable exception or limitation to
+     copyright--then that use is not regulated by the license. Our
+     licenses grant only permissions under copyright and certain
+     other rights that a licensor has authority to grant. Use of
+     the licensed material may still be restricted for other
+     reasons, including because others have copyright or other
+     rights in the material. A licensor may make special requests,
+     such as asking that all changes be marked or described.
+     Although not required by our licenses, you are encouraged to
+     respect those requests where reasonable. More_considerations
+     for the public:
+	wiki.creativecommons.org/Considerations_for_licensees
+
+=======================================================================
+
+Creative Commons Attribution-NonCommercial 4.0 International Public
+License
+
+By exercising the Licensed Rights (defined below), You accept and agree
+to be bound by the terms and conditions of this Creative Commons
+Attribution-NonCommercial 4.0 International Public License ("Public
+License"). To the extent this Public License may be interpreted as a
+contract, You are granted the Licensed Rights in consideration of Your
+acceptance of these terms and conditions, and the Licensor grants You
+such rights in consideration of benefits the Licensor receives from
+making the Licensed Material available under these terms and
+conditions.
+
+
+Section 1 -- Definitions.
+
+  a. Adapted Material means material subject to Copyright and Similar
+     Rights that is derived from or based upon the Licensed Material
+     and in which the Licensed Material is translated, altered,
+     arranged, transformed, or otherwise modified in a manner requiring
+     permission under the Copyright and Similar Rights held by the
+     Licensor. For purposes of this Public License, where the Licensed
+     Material is a musical work, performance, or sound recording,
+     Adapted Material is always produced where the Licensed Material is
+     synched in timed relation with a moving image.
+
+  b. Adapter's License means the license You apply to Your Copyright
+     and Similar Rights in Your contributions to Adapted Material in
+     accordance with the terms and conditions of this Public License.
+
+  c. Copyright and Similar Rights means copyright and/or similar rights
+     closely related to copyright including, without limitation,
+     performance, broadcast, sound recording, and Sui Generis Database
+     Rights, without regard to how the rights are labeled or
+     categorized. For purposes of this Public License, the rights
+     specified in Section 2(b)(1)-(2) are not Copyright and Similar
+     Rights.
+  d. Effective Technological Measures means those measures that, in the
+     absence of proper authority, may not be circumvented under laws
+     fulfilling obligations under Article 11 of the WIPO Copyright
+     Treaty adopted on December 20, 1996, and/or similar international
+     agreements.
+
+  e. Exceptions and Limitations means fair use, fair dealing, and/or
+     any other exception or limitation to Copyright and Similar Rights
+     that applies to Your use of the Licensed Material.
+
+  f. Licensed Material means the artistic or literary work, database,
+     or other material to which the Licensor applied this Public
+     License.
+
+  g. Licensed Rights means the rights granted to You subject to the
+     terms and conditions of this Public License, which are limited to
+     all Copyright and Similar Rights that apply to Your use of the
+     Licensed Material and that the Licensor has authority to license.
+
+  h. Licensor means the individual(s) or entity(ies) granting rights
+     under this Public License.
+
+  i. NonCommercial means not primarily intended for or directed towards
+     commercial advantage or monetary compensation. For purposes of
+     this Public License, the exchange of the Licensed Material for
+     other material subject to Copyright and Similar Rights by digital
+     file-sharing or similar means is NonCommercial provided there is
+     no payment of monetary compensation in connection with the
+     exchange.
+
+  j. Share means to provide material to the public by any means or
+     process that requires permission under the Licensed Rights, such
+     as reproduction, public display, public performance, distribution,
+     dissemination, communication, or importation, and to make material
+     available to the public including in ways that members of the
+     public may access the material from a place and at a time
+     individually chosen by them.
+
+  k. Sui Generis Database Rights means rights other than copyright
+     resulting from Directive 96/9/EC of the European Parliament and of
+     the Council of 11 March 1996 on the legal protection of databases,
+     as amended and/or succeeded, as well as other essentially
+     equivalent rights anywhere in the world.
+
+  l. You means the individual or entity exercising the Licensed Rights
+     under this Public License. Your has a corresponding meaning.
+
+
+Section 2 -- Scope.
+
+  a. License grant.
+
+       1. Subject to the terms and conditions of this Public License,
+          the Licensor hereby grants You a worldwide, royalty-free,
+          non-sublicensable, non-exclusive, irrevocable license to
+          exercise the Licensed Rights in the Licensed Material to:
+
+            a. reproduce and Share the Licensed Material, in whole or
+               in part, for NonCommercial purposes only; and
+
+            b. produce, reproduce, and Share Adapted Material for
+               NonCommercial purposes only.
+
+       2. Exceptions and Limitations. For the avoidance of doubt, where
+          Exceptions and Limitations apply to Your use, this Public
+          License does not apply, and You do not need to comply with
+          its terms and conditions.
+
+       3. Term. The term of this Public License is specified in Section
+          6(a).
+
+       4. Media and formats; technical modifications allowed. The
+          Licensor authorizes You to exercise the Licensed Rights in
+          all media and formats whether now known or hereafter created,
+          and to make technical modifications necessary to do so. The
+          Licensor waives and/or agrees not to assert any right or
+          authority to forbid You from making technical modifications
+          necessary to exercise the Licensed Rights, including
+          technical modifications necessary to circumvent Effective
+          Technological Measures. For purposes of this Public License,
+          simply making modifications authorized by this Section 2(a)
+          (4) never produces Adapted Material.
+
+       5. Downstream recipients.
+
+            a. Offer from the Licensor -- Licensed Material. Every
+               recipient of the Licensed Material automatically
+               receives an offer from the Licensor to exercise the
+               Licensed Rights under the terms and conditions of this
+               Public License.
+
+            b. No downstream restrictions. You may not offer or impose
+               any additional or different terms or conditions on, or
+               apply any Effective Technological Measures to, the
+               Licensed Material if doing so restricts exercise of the
+               Licensed Rights by any recipient of the Licensed
+               Material.
+
+       6. No endorsement. Nothing in this Public License constitutes or
+          may be construed as permission to assert or imply that You
+          are, or that Your use of the Licensed Material is, connected
+          with, or sponsored, endorsed, or granted official status by,
+          the Licensor or others designated to receive attribution as
+          provided in Section 3(a)(1)(A)(i).
+
+  b. Other rights.
+
+       1. Moral rights, such as the right of integrity, are not
+          licensed under this Public License, nor are publicity,
+          privacy, and/or other similar personality rights; however, to
+          the extent possible, the Licensor waives and/or agrees not to
+          assert any such rights held by the Licensor to the limited
+          extent necessary to allow You to exercise the Licensed
+          Rights, but not otherwise.
+
+       2. Patent and trademark rights are not licensed under this
+          Public License.
+
+       3. To the extent possible, the Licensor waives any right to
+          collect royalties from You for the exercise of the Licensed
+          Rights, whether directly or through a collecting society
+          under any voluntary or waivable statutory or compulsory
+          licensing scheme. In all other cases the Licensor expressly
+          reserves any right to collect such royalties, including when
+          the Licensed Material is used other than for NonCommercial
+          purposes.
+
+
+Section 3 -- License Conditions.
+
+Your exercise of the Licensed Rights is expressly made subject to the
+following conditions.
+
+  a. Attribution.
+
+       1. If You Share the Licensed Material (including in modified
+          form), You must:
+
+            a. retain the following if it is supplied by the Licensor
+               with the Licensed Material:
+
+                 i. identification of the creator(s) of the Licensed
+                    Material and any others designated to receive
+                    attribution, in any reasonable manner requested by
+                    the Licensor (including by pseudonym if
+                    designated);
+
+                ii. a copyright notice;
+
+               iii. a notice that refers to this Public License;
+
+                iv. a notice that refers to the disclaimer of
+                    warranties;
+
+                 v. a URI or hyperlink to the Licensed Material to the
+                    extent reasonably practicable;
+
+            b. indicate if You modified the Licensed Material and
+               retain an indication of any previous modifications; and
+
+            c. indicate the Licensed Material is licensed under this
+               Public License, and include the text of, or the URI or
+               hyperlink to, this Public License.
+
+       2. You may satisfy the conditions in Section 3(a)(1) in any
+          reasonable manner based on the medium, means, and context in
+          which You Share the Licensed Material. For example, it may be
+          reasonable to satisfy the conditions by providing a URI or
+          hyperlink to a resource that includes the required
+          information.
+
+       3. If requested by the Licensor, You must remove any of the
+          information required by Section 3(a)(1)(A) to the extent
+          reasonably practicable.
+
+       4. If You Share Adapted Material You produce, the Adapter's
+          License You apply must not prevent recipients of the Adapted
+          Material from complying with this Public License.
+
+
+Section 4 -- Sui Generis Database Rights.
+
+Where the Licensed Rights include Sui Generis Database Rights that
+apply to Your use of the Licensed Material:
+
+  a. for the avoidance of doubt, Section 2(a)(1) grants You the right
+     to extract, reuse, reproduce, and Share all or a substantial
+     portion of the contents of the database for NonCommercial purposes
+     only;
+
+  b. if You include all or a substantial portion of the database
+     contents in a database in which You have Sui Generis Database
+     Rights, then the database in which You have Sui Generis Database
+     Rights (but not its individual contents) is Adapted Material; and
+
+  c. You must comply with the conditions in Section 3(a) if You Share
+     all or a substantial portion of the contents of the database.
+
+For the avoidance of doubt, this Section 4 supplements and does not
+replace Your obligations under this Public License where the Licensed
+Rights include other Copyright and Similar Rights.
+
+
+Section 5 -- Disclaimer of Warranties and Limitation of Liability.
+
+  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE
+     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS
+     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF
+     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,
+     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,
+     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR
+     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,
+     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT
+     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT
+     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.
+
+  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE
+     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,
+     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,
+     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,
+     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR
+     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN
+     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR
+     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR
+     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.
+
+  c. The disclaimer of warranties and limitation of liability provided
+     above shall be interpreted in a manner that, to the extent
+     possible, most closely approximates an absolute disclaimer and
+     waiver of all liability.
+
+
+Section 6 -- Term and Termination.
+
+  a. This Public License applies for the term of the Copyright and
+     Similar Rights licensed here. However, if You fail to comply with
+     this Public License, then Your rights under this Public License
+     terminate automatically.
+
+  b. Where Your right to use the Licensed Material has terminated under
+     Section 6(a), it reinstates:
+
+       1. automatically as of the date the violation is cured, provided
+          it is cured within 30 days of Your discovery of the
+          violation; or
+
+       2. upon express reinstatement by the Licensor.
+
+     For the avoidance of doubt, this Section 6(b) does not affect any
+     right the Licensor may have to seek remedies for Your violations
+     of this Public License.
+
+  c. For the avoidance of doubt, the Licensor may also offer the
+     Licensed Material under separate terms or conditions or stop
+     distributing the Licensed Material at any time; however, doing so
+     will not terminate this Public License.
+
+  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public
+     License.
+
+
+Section 7 -- Other Terms and Conditions.
+
+  a. The Licensor shall not be bound by any additional or different
+     terms or conditions communicated by You unless expressly agreed.
+
+  b. Any arrangements, understandings, or agreements regarding the
+     Licensed Material not stated herein are separate from and
+     independent of the terms and conditions of this Public License.
+
+
+Section 8 -- Interpretation.
+
+  a. For the avoidance of doubt, this Public License does not, and
+     shall not be interpreted to, reduce, limit, restrict, or impose
+     conditions on any use of the Licensed Material that could lawfully
+     be made without permission under this Public License.
+
+  b. To the extent possible, if any provision of this Public License is
+     deemed unenforceable, it shall be automatically reformed to the
+     minimum extent necessary to make it enforceable. If the provision
+     cannot be reformed, it shall be severed from this Public License
+     without affecting the enforceability of the remaining terms and
+     conditions.
+
+  c. No term or condition of this Public License will be waived and no
+     failure to comply consented to unless expressly agreed to by the
+     Licensor.
+
+  d. Nothing in this Public License constitutes or may be interpreted
+     as a limitation upon, or waiver of, any privileges and immunities
+     that apply to the Licensor or You, including from the legal
+     processes of any jurisdiction or authority.
+
+=======================================================================
+
+Creative Commons is not a party to its public
+licenses. Notwithstanding, Creative Commons may elect to apply one of
+its public licenses to material it publishes and in those instances
+will be considered the Licensor. The text of the Creative Commons
+public licenses is dedicated to the public domain under the CC0 Public
+Domain Dedication. Except for the limited purpose of indicating that
+material is shared under a Creative Commons public license or as
+otherwise permitted by the Creative Commons policies published at
+creativecommons.org/policies, Creative Commons does not authorize the
+use of the trademark "Creative Commons" or any other trademark or logo
+of Creative Commons without its prior written consent including,
+without limitation, in connection with any unauthorized modifications
+to any of its public licenses or any other arrangements,
+understandings, or agreements concerning use of licensed material. For
+the avoidance of doubt, this paragraph does not form part of the
+public licenses.
+
+Creative Commons may be contacted at creativecommons.org.
diff --git a/experiments05/ant_umaze_1234/src/README.md b/experiments05/ant_umaze_1234/src/README.md
new file mode 100644
index 0000000..ec09da9
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/README.md
@@ -0,0 +1,29 @@
+# Stochastic Lower Bound Optimization
+
+This is the TensorFlow implementation for the paper [
+Algorithmic Framework for Model-based Deep Reinforcement Learning with Theoretical Guarantees](https://arxiv.org/abs/1807.03858).
+A PyTorch version will be released later.  
+
+
+## Requirements
+1. OpenAI Baselines
+2. rllab (commit number `b3a2899`)
+3. MuJoCo (1.5)
+4. TensorFlow (>= 1.9)
+5. NumPy (>= 1.14.5)
+6. Python 3.6
+
+## Run
+
+Before running, please make sure that `rllab` and `baselines` are available 
+
+```bash
+python main.py -c configs/algos/slbo.yml configs/envs/half_cheetah.yml -s log_dir=/tmp
+```
+
+If you want to change hyper-parameters, you can either modify a corresponding `yml` file or 
+change it temporarily by appending `model.hidden_sizes='[1000,1000]'` in the command line.
+
+## License
+
+See [LICENSE](LICENSE) for additional details.
diff --git a/experiments05/ant_umaze_1234/src/check_result.py b/experiments05/ant_umaze_1234/src/check_result.py
new file mode 100644
index 0000000..d1c8161
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/check_result.py
@@ -0,0 +1,12 @@
+import numpy as np
+
+seed_list = ['1234', '1235', '2314', '2345']
+env_name = 'gym_reacher'
+lasts = []
+for seed in seed_list:
+    cur = np.load('experiments/'+env_name+'_'+seed+'/eval_real_returns.npy')
+    lasts.append(cur[-1])
+
+print(lasts)
+print(np.mean(lasts))
+print(np.std(lasts))
diff --git a/experiments05/ant_umaze_1234/src/configs/algos/mb_trpo.yml b/experiments05/ant_umaze_1234/src/configs/algos/mb_trpo.yml
new file mode 100644
index 0000000..cce36ec
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/algos/mb_trpo.yml
@@ -0,0 +1,12 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+model:
+  multi_step: 2
+  dev_batch_size: 512
+  train_batch_size: 128
+slbo:
+  n_stages: 100
+  n_iters: 1
+  n_model_iters: 2000
+  n_policy_iters: 200
+TRPO:
+  ent_coef: 0.005
diff --git a/experiments05/ant_umaze_1234/src/configs/algos/mf.yml b/experiments05/ant_umaze_1234/src/configs/algos/mf.yml
new file mode 100644
index 0000000..5d5e317
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/algos/mf.yml
@@ -0,0 +1,11 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+algorithm: MF
+rollout:
+  n_train_samples: 10000
+  n_dev_samples: 128
+  n_test_samples: 10000
+slbo:
+  n_stages: 100
+  n_iters: 1
+  n_policy_iters: 20
+  n_model_iters: 1
diff --git a/experiments05/ant_umaze_1234/src/configs/algos/slbo.yml b/experiments05/ant_umaze_1234/src/configs/algos/slbo.yml
new file mode 100644
index 0000000..2b5eecb
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/algos/slbo.yml
@@ -0,0 +1,12 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+model:
+  multi_step: 2
+  dev_batch_size: 512
+  train_batch_size: 128
+slbo:
+  n_stages: 100
+  n_iters: 20
+  n_model_iters: 100
+  n_policy_iters: 40
+TRPO:
+  ent_coef: 0
diff --git a/experiments05/ant_umaze_1234/src/configs/algos/slbo_bm_1m.yml b/experiments05/ant_umaze_1234/src/configs/algos/slbo_bm_1m.yml
new file mode 100644
index 0000000..dcf3777
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/algos/slbo_bm_1m.yml
@@ -0,0 +1,12 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+model:
+  multi_step: 2
+  dev_batch_size: 512
+  train_batch_size: 128
+slbo:
+  n_stages: 100
+  n_iters: 20
+  n_model_iters: 100
+  n_policy_iters: 40
+TRPO:
+  ent_coef: 0.005
diff --git a/experiments05/ant_umaze_1234/src/configs/algos/slbo_bm_200k.yml b/experiments05/ant_umaze_1234/src/configs/algos/slbo_bm_200k.yml
new file mode 100644
index 0000000..9544e89
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/algos/slbo_bm_200k.yml
@@ -0,0 +1,15 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+model:
+  multi_step: 2
+  dev_batch_size: 512
+  train_batch_size: 128
+slbo:
+  n_stages: 50
+  n_iters: 20
+  n_model_iters: 100
+  n_policy_iters: 40
+TRPO:
+  ent_coef: 0
+rollout:
+  n_train_samples: 4000
+
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/ant_umaze.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/ant_umaze.yml
new file mode 100644
index 0000000..ab75516
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/ant_umaze.yml
@@ -0,0 +1,8 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: AntUMaze-v1
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
+
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/fetch_push.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/fetch_push.yml
new file mode 100644
index 0000000..43a36d0
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/fetch_push.yml
@@ -0,0 +1,8 @@
+env:
+  id: FetchPush
+runner:
+  max_steps: 50
+plan:
+  max_steps: 50
+pc:
+  bonus_scale: 0.1
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_acrobot.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_acrobot.yml
new file mode 100644
index 0000000..fe01e4a
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_acrobot.yml
@@ -0,0 +1,6 @@
+env:
+  id: Acrobot
+runner:
+  max_steps: 200
+plan:
+  max_steps: 200
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_ant.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_ant.yml
new file mode 100644
index 0000000..07d4c3e
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_ant.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Ant
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_ant_depth_search.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_ant_depth_search.yml
new file mode 100644
index 0000000..1d50248
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_ant_depth_search.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Ant
+runner:
+  max_steps: ENV_LENGTH
+plan:
+  max_steps: PLAN_LENGTH
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpole.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpole.yml
new file mode 100644
index 0000000..a608f7c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpole.yml
@@ -0,0 +1,6 @@
+env:
+  id: CartPole
+runner:
+  max_steps: 200
+plan:
+  max_steps: 200
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpoleO001.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpoleO001.yml
new file mode 100644
index 0000000..f83770b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpoleO001.yml
@@ -0,0 +1,6 @@
+env:
+  id: CartPoleO001
+runner:
+  max_steps: 200
+plan:
+  max_steps: 200
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpoleO01.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpoleO01.yml
new file mode 100644
index 0000000..3f7674f
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cartpoleO01.yml
@@ -0,0 +1,6 @@
+env:
+  id: CartPoleO01
+runner:
+  max_steps: 200
+plan:
+  max_steps: 200
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetah.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetah.yml
new file mode 100644
index 0000000..ae2c095
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetah.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: HalfCheetah
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahA003.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahA003.yml
new file mode 100644
index 0000000..a87b6be
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahA003.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: HalfCheetahA003
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahA01.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahA01.yml
new file mode 100644
index 0000000..5312055
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahA01.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: HalfCheetahA01
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahO001.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahO001.yml
new file mode 100644
index 0000000..960e36e
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahO001.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: HalfCheetahO001
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahO01.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahO01.yml
new file mode 100644
index 0000000..4a5d67d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetahO01.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: HalfCheetahO01
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetah_depth_search.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetah_depth_search.yml
new file mode 100644
index 0000000..c147ec4
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_cheetah_depth_search.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: HalfCheetah
+runner:
+  max_steps: ENV_LENGTH
+plan:
+  max_steps: PLAN_LENGTH
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fant.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fant.yml
new file mode 100644
index 0000000..6773c7b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fant.yml
@@ -0,0 +1,6 @@
+env:
+  id: FixedAnt
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fhopper.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fhopper.yml
new file mode 100644
index 0000000..2efc44e
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fhopper.yml
@@ -0,0 +1,6 @@
+env:
+  id: FixedHopper
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fswimmer.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fswimmer.yml
new file mode 100644
index 0000000..888b87b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fswimmer.yml
@@ -0,0 +1,6 @@
+env:
+  id: FixedSwimmer
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fwalker2d.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fwalker2d.yml
new file mode 100644
index 0000000..ee63b73
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_fwalker2d.yml
@@ -0,0 +1,6 @@
+env:
+  id: FixedWalker
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_hopper.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_hopper.yml
new file mode 100644
index 0000000..a061802
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_hopper.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Hopper
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_humanoid.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_humanoid.yml
new file mode 100644
index 0000000..426bdfb
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_humanoid.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: gym_humanoid
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_invertedPendulum.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_invertedPendulum.yml
new file mode 100644
index 0000000..d1062d9
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_invertedPendulum.yml
@@ -0,0 +1,6 @@
+env:
+  id: InvertedPendulum
+runner:
+  max_steps: 100
+plan:
+  max_steps: 100
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_mountain.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_mountain.yml
new file mode 100644
index 0000000..6c335d5
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_mountain.yml
@@ -0,0 +1,11 @@
+env:
+  id: MountainCar
+runner:
+  max_steps: 200
+plan:
+  max_steps: 200
+pc:
+  bonus_scale: 2
+  bonus_stop_time: 50
+rollout:
+  n_train_samples: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_nostopslimhumanoid.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_nostopslimhumanoid.yml
new file mode 100644
index 0000000..dabe168
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_nostopslimhumanoid.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: gym_nostopslimhumanoid
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulum.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulum.yml
new file mode 100644
index 0000000..c0caff5
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulum.yml
@@ -0,0 +1,6 @@
+env:
+  id: Pendulum
+runner:
+  max_steps: 200
+plan:
+  max_steps: 200
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulumO001.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulumO001.yml
new file mode 100644
index 0000000..1ebd722
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulumO001.yml
@@ -0,0 +1,6 @@
+env:
+  id: PendulumO001
+runner:
+  max_steps: 200
+plan:
+  max_steps: 200
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulumO01.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulumO01.yml
new file mode 100644
index 0000000..4658d7f
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_pendulumO01.yml
@@ -0,0 +1,6 @@
+env:
+  id: PendulumO01
+runner:
+  max_steps: 200
+plan:
+  max_steps: 200
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_reacher.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_reacher.yml
new file mode 100644
index 0000000..427ad36
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_reacher.yml
@@ -0,0 +1,6 @@
+env:
+  id: Reacher
+runner:
+  max_steps: 50
+plan:
+  max_steps: 50
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_slimhumanoid.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_slimhumanoid.yml
new file mode 100644
index 0000000..ecd0976
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_slimhumanoid.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: gym_slimhumanoid
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_swimmer.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_swimmer.yml
new file mode 100644
index 0000000..b9ba125
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_swimmer.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Swimmer
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_walker2d.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_walker2d.yml
new file mode 100644
index 0000000..8403547
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/gym_walker2d.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Walker2D
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/hand_egg.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/hand_egg.yml
new file mode 100644
index 0000000..d4f5160
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/hand_egg.yml
@@ -0,0 +1,8 @@
+env:
+  id: HandEgg
+runner:
+  max_steps: 100
+plan:
+  max_steps: 100
+pc:
+  bonus_scale: 1
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/hand_reach.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/hand_reach.yml
new file mode 100644
index 0000000..40ae08b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/hand_reach.yml
@@ -0,0 +1,8 @@
+env:
+  id: HandReach
+runner:
+  max_steps: 50
+plan:
+  max_steps: 50
+pc:
+  bonus_scale: 0.5
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_fall.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_fall.yml
new file mode 100644
index 0000000..ac26219
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_fall.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: PointFall-v1
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_push.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_push.yml
new file mode 100644
index 0000000..22d4f65
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_push.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: PointPush-v1
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_umaze.yml b/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_umaze.yml
new file mode 100644
index 0000000..b459aa6
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/env_tingwu/point_umaze.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: PointUMaze-v1
+runner:
+  max_steps: 1000
+plan:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/acrobot.yml b/experiments05/ant_umaze_1234/src/configs/envs/acrobot.yml
new file mode 100644
index 0000000..4ca200d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/acrobot.yml
@@ -0,0 +1,4 @@
+env:
+  id: Acrobot
+runner:
+  max_steps: 200
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/ant.yml b/experiments05/ant_umaze_1234/src/configs/envs/ant.yml
new file mode 100644
index 0000000..f24b431
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/ant.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Ant
+runner:
+  max_steps: 1000
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/cartpole.yml b/experiments05/ant_umaze_1234/src/configs/envs/cartpole.yml
new file mode 100644
index 0000000..9b49dbe
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/cartpole.yml
@@ -0,0 +1,4 @@
+env:
+  id: CartPole
+runner:
+  max_steps: 200
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/fswimmer.yml b/experiments05/ant_umaze_1234/src/configs/envs/fswimmer.yml
new file mode 100644
index 0000000..2aee16a
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/fswimmer.yml
@@ -0,0 +1,4 @@
+env:
+  id: FixedSwimmer
+runner:
+  max_steps: 1000
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/half_cheetah.yml b/experiments05/ant_umaze_1234/src/configs/envs/half_cheetah.yml
new file mode 100644
index 0000000..36cfffa
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/half_cheetah.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: HalfCheetah
+runner:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/half_cheetah_short.yml b/experiments05/ant_umaze_1234/src/configs/envs/half_cheetah_short.yml
new file mode 100644
index 0000000..e0e21ed
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/half_cheetah_short.yml
@@ -0,0 +1,7 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: HalfCheetah-v2
+plan:
+  max_steps: 200
+runner:
+  max_steps: 200
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/hopper.yml b/experiments05/ant_umaze_1234/src/configs/envs/hopper.yml
new file mode 100644
index 0000000..7b34a11
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/hopper.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Hopper
+runner:
+  max_steps: 1000
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/humanoid.yml b/experiments05/ant_umaze_1234/src/configs/envs/humanoid.yml
new file mode 100644
index 0000000..1eb1236
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/humanoid.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: POMDPHumanoid-v2
+runner:
+  max_steps: 500
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/inverted_pendulum.yml b/experiments05/ant_umaze_1234/src/configs/envs/inverted_pendulum.yml
new file mode 100644
index 0000000..1d60732
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/inverted_pendulum.yml
@@ -0,0 +1,4 @@
+env:
+  id: InvertedPendulum
+runner:
+  max_steps: 100
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/mountain.yml b/experiments05/ant_umaze_1234/src/configs/envs/mountain.yml
new file mode 100644
index 0000000..e4cb7f6
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/mountain.yml
@@ -0,0 +1,4 @@
+env:
+  id: MountainCar
+runner:
+  max_steps: 200
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/pendulum.yml b/experiments05/ant_umaze_1234/src/configs/envs/pendulum.yml
new file mode 100644
index 0000000..8ea91c3
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/pendulum.yml
@@ -0,0 +1,4 @@
+env:
+  id: Pendulum
+runner:
+  max_steps: 200
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/reacher.yml b/experiments05/ant_umaze_1234/src/configs/envs/reacher.yml
new file mode 100644
index 0000000..bfaf65b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/reacher.yml
@@ -0,0 +1,4 @@
+env:
+  id: Reacher
+runner:
+  max_steps: 50
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/swimmer.yml b/experiments05/ant_umaze_1234/src/configs/envs/swimmer.yml
new file mode 100644
index 0000000..abe2842
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/swimmer.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Swimmer
+runner:
+  max_steps: 1000
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/configs/envs/walker.yml b/experiments05/ant_umaze_1234/src/configs/envs/walker.yml
new file mode 100644
index 0000000..e42fa53
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/envs/walker.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+env:
+  id: Walker2D
+runner:
+  max_steps: 1000
diff --git a/experiments05/ant_umaze_1234/src/configs/multi_step/1.yml b/experiments05/ant_umaze_1234/src/configs/multi_step/1.yml
new file mode 100644
index 0000000..e102872
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/multi_step/1.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+model:
+  multi_step: 1
+  dev_batch_size: 1024
+  train_batch_size: 256
diff --git a/experiments05/ant_umaze_1234/src/configs/multi_step/2.yml b/experiments05/ant_umaze_1234/src/configs/multi_step/2.yml
new file mode 100644
index 0000000..c866952
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/multi_step/2.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+model:
+  multi_step: 2
+  dev_batch_size: 512
+  train_batch_size: 128
diff --git a/experiments05/ant_umaze_1234/src/configs/multi_step/4.yml b/experiments05/ant_umaze_1234/src/configs/multi_step/4.yml
new file mode 100644
index 0000000..16a1e5c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/multi_step/4.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+model:
+  multi_step: 4
+  dev_batch_size: 256
+  train_batch_size: 64
diff --git a/experiments05/ant_umaze_1234/src/configs/multi_step/8.yml b/experiments05/ant_umaze_1234/src/configs/multi_step/8.yml
new file mode 100644
index 0000000..7262945
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/configs/multi_step/8.yml
@@ -0,0 +1,5 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+model:
+  multi_step: 8
+  dev_batch_size: 128
+  train_batch_size: 32
diff --git a/experiments05/ant_umaze_1234/src/cpu_requirements.txt b/experiments05/ant_umaze_1234/src/cpu_requirements.txt
new file mode 100644
index 0000000..141cfbb
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/cpu_requirements.txt
@@ -0,0 +1,8 @@
+tensorflow==1.13.1
+pyyaml==5.1
+termcolor==1.1.0
+gym
+mujoco-py
+json_tricks==3.13.1
+baselines==0.1.5
+
diff --git a/experiments05/ant_umaze_1234/src/lunzi/Logger.py b/experiments05/ant_umaze_1234/src/lunzi/Logger.py
new file mode 100644
index 0000000..9f41014
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/Logger.py
@@ -0,0 +1,133 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from termcolor import colored
+import datetime
+import sys
+import os
+from collections import Counter, defaultdict
+import json_tricks
+
+
+def a():
+    pass
+
+
+_srcfile = os.path.normcase(a.__code__.co_filename)
+
+
+class BaseSink(object):
+    @staticmethod
+    def _time():
+        return datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S,%f')
+
+    def info(self, fmt, *args, **kwargs):
+        raise NotImplementedError
+
+    def warning(self, fmt, *args, **kwargs):
+        self.info(fmt, *args, **kwargs)
+
+    def verbose(self, fmt, *args, **kwargs):
+        pass
+
+
+class StdoutSink(BaseSink):
+    def __init__(self):
+        self.freq_count = Counter()
+
+    def info(self, fmt, *args, freq=1, caller=None):
+        if args:
+            fmt = fmt % args
+        self.freq_count[caller] += 1
+        if self.freq_count[caller] % freq == 0:
+            print("%s - %s - %s" % (colored(self._time(), 'green'),
+                                    colored(caller, 'cyan'), fmt), flush=True)
+
+    def warning(self, fmt, *args, **kwargs):
+        if args:
+            fmt = fmt % args
+        self.info(colored(fmt, 'yellow'), **kwargs)
+
+
+class FileSink(BaseSink):
+    def __init__(self, fn):
+        self.log_file = open(fn, 'w')
+        self.callers = {}
+
+    def info(self, fmt, *args, **kwargs):
+        self._kv(level='info', fmt=fmt, args=args, **kwargs)
+
+    def warning(self, fmt, *args, **kwargs):
+        self._kv(level='warning', fmt=fmt, args=args, **kwargs)
+
+    def _kv(self, **kwargs):
+        kwargs.update(time=datetime.datetime.now())
+        self.log_file.write(json_tricks.dumps(kwargs, primitives=True) + '\n')
+        self.log_file.flush()
+
+    def verbose(self, fmt, *args, **kwargs):
+        self._kv(level='verbose', fmt=fmt, args=args, **kwargs)
+
+
+class LibLogger(object):
+    logfile = ""
+
+    def __init__(self, name='logger', is_root=True):
+        self.name = name
+        self.is_root = is_root
+        self.tab_keys = None
+        self.sinks = []
+        self.key_prior = defaultdict(np.random.randn)
+
+    def add_sink(self, sink):
+        self.sinks.append(sink)
+
+    def info(self, fmt, *args, **kwargs):
+        caller = self.find_caller()
+        for sink in self.sinks:
+            sink.info(fmt, *args, caller=caller, **kwargs)
+
+    def warning(self, fmt, *args, **kwargs):
+        caller = self.find_caller()
+        for sink in self.sinks:
+            sink.warning(fmt, *args, caller=caller, **kwargs)
+
+    def verbose(self, fmt, *args, **kwargs):
+        caller = self.find_caller()
+        for sink in self.sinks:
+            sink.verbose(fmt, *args, caller=caller, **kwargs)
+
+    def find_caller(self):
+        """
+        Copy from `python.logging` module
+
+        Find the stack frame of the caller so that we can note the source
+        file name, line number and function name.
+        """
+        f = sys._getframe(1)
+        if f is not None:
+            f = f.f_back
+        caller = ''
+        while hasattr(f, "f_code"):
+            co = f.f_code
+            filename = os.path.normcase(co.co_filename)
+            if filename == _srcfile:
+                f = f.f_back
+                continue
+            # if stack_info:
+            #     sio = io.StringIO()
+            #     sio.write('Stack (most recent call last):\n')
+            #     traceback.print_stack(f, file=sio)
+            #     sio.close()
+            # rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)
+            rel_path = os.path.relpath(co.co_filename, '')
+            caller = f'{rel_path}:{f.f_lineno}'
+            break
+        return caller
+
+
+def get_logger(name):
+    return LibLogger(name)
+
+
+logger = get_logger('Logger')
+logger.add_sink(StdoutSink())
diff --git a/experiments05/ant_umaze_1234/src/lunzi/__init__.py b/experiments05/ant_umaze_1234/src/lunzi/__init__.py
new file mode 100644
index 0000000..0c5417b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/__init__.py
@@ -0,0 +1,4 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from .stubs import Tensor
+import lunzi.nn
+import lunzi.Logger
diff --git a/experiments05/ant_umaze_1234/src/lunzi/config.py b/experiments05/ant_umaze_1234/src/lunzi/config.py
new file mode 100644
index 0000000..5c39b1e
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/config.py
@@ -0,0 +1,97 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import argparse
+import os
+import yaml
+from lunzi.Logger import logger
+
+
+_frozen = False
+_initialized = False
+
+
+def expand(path):
+    return os.path.abspath(os.path.expanduser(path))
+
+
+class MetaFLAGS(type):
+    _initialized = False
+
+    def __setattr__(self, key, value):
+        assert not _frozen, 'Modifying FLAGS after dumping is not allowed!'
+        super().__setattr__(key, value)
+
+    def __getitem__(self, item):
+        return self.__dict__[item]
+
+    def __iter__(self):
+        for key, value in self.__dict__.items():
+            if not key.startswith('_') and not isinstance(value, classmethod):
+                if isinstance(value, MetaFLAGS):
+                    value = dict(value)
+                yield key, value
+
+    def as_dict(self):
+        return dict(self)
+
+    def merge(self, other: dict):
+        for key in other:
+            assert key in self.__dict__, f"Can't find key `{key}`"
+            if isinstance(self[key], MetaFLAGS) and isinstance(other[key], dict):
+                self[key].merge(other[key])
+            else:
+                setattr(self, key, other[key])
+
+    def set_value(self, path, value):
+        key, *rest = path
+        assert key in self.__dict__, f"Can't find key `{key}`"
+        if not rest:
+            setattr(self, key, value)
+        else:
+            self[key]: MetaFLAGS
+            self[key].set_value(rest, value)
+
+    @staticmethod
+    def set_frozen():
+        global _frozen
+        _frozen = True
+
+    def freeze(self):
+        for key, value in self.__dict__.items():
+            if not key.startswith('_'):
+                if isinstance(value, MetaFLAGS):
+                    value.freeze()
+        self.finalize()
+
+    def finalize(self):
+        pass
+
+
+class BaseFLAGS(metaclass=MetaFLAGS):
+    pass
+
+
+def parse(cls):
+    global _initialized
+
+    if _initialized:
+        return
+    parser = argparse.ArgumentParser(description='Stochastic Lower Bound Optimization')
+    parser.add_argument('-c', '--config', type=str, help='configuration file (YAML)', nargs='+', action='append')
+    parser.add_argument('-s', '--set', type=str, help='additional options', nargs='*', action='append')
+
+    args, unknown = parser.parse_known_args()
+    for a in unknown:
+        logger.info('unknown arguments: %s', a)
+    # logger.info('parsed arguments = %s, unknown arguments: %s', args, unknown)
+    if args.config:
+        for config in sum(args.config, []):
+            cls.merge(yaml.load(open(expand(config))))
+    else:
+        logger.info('no config file specified.')
+    if args.set:
+        for instruction in sum(args.set, []):
+            path, *value = instruction.split('=')
+            cls.set_value(path.split('.'), yaml.load('='.join(value)))
+
+    _initialized = True
+
diff --git a/experiments05/ant_umaze_1234/src/lunzi/dataset.py b/experiments05/ant_umaze_1234/src/lunzi/dataset.py
new file mode 100644
index 0000000..7cb5d5f
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/dataset.py
@@ -0,0 +1,82 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+
+
+class Dataset(np.recarray):
+    """
+        Overallocation can be supported, by making examinations before
+        each `append` and `extend`.
+    """
+
+    @staticmethod
+    def fromarrays(array_lists, dtype):
+        array = np.rec.fromarrays(array_lists, dtype=dtype)
+        ret = Dataset(dtype, len(array))
+        ret.extend(array)
+        return ret
+
+    def __init__(self, dtype, max_size, verbose=False):
+        super().__init__()
+        self.max_size = max_size
+        self._index = 0
+        self._buf_size = 0
+        self._len = 0
+
+        self.resize(max_size)
+        self._buf_size = max_size
+
+    def __new__(cls, dtype, max_size):
+        return np.recarray.__new__(cls, max_size, dtype=dtype)
+
+    def size(self):
+        return self._len
+
+    def reserve(self, size):
+        cur_size = max(self._buf_size, 1)
+        while cur_size < size:
+            cur_size *= 2
+        if cur_size != self._buf_size:
+            self.resize(cur_size)
+
+    def clear(self):
+        self._index = 0
+        self._len = 0
+        return self
+
+    def append(self, item):
+        self[self._index] = item
+        self._index = (self._index + 1) % self.max_size
+        self._len = min(self._len + 1, self.max_size)
+        return self
+
+    def extend(self, items):
+        n_new = len(items)
+        if n_new > self.max_size:
+            items = items[-self.max_size:]
+            n_new = self.max_size
+
+        n_tail = self.max_size - self._index
+        if n_new <= n_tail:
+            self[self._index:self._index + n_new] = items
+        else:
+            n_head = n_new - n_tail
+            self[self._index:] = items[:n_tail]
+            self[:n_head] = items[n_tail:]
+
+        self._index = (self._index + n_new) % self.max_size
+        self._len = min(self._len + n_new, self.max_size)
+        return self
+
+    def sample(self, size, indices=None):
+        if indices is None:
+            indices = np.random.randint(0, self._len, size=size)
+        return self[indices]
+
+    def iterator(self, batch_size):
+        indices = np.arange(self._len, dtype=np.int32)
+        np.random.shuffle(indices)
+        index = 0
+        while index + batch_size <= self._len:
+            end = index + batch_size
+            yield self[indices[index:end]]
+            index = end
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/__init__.py b/experiments05/ant_umaze_1234/src/lunzi/nn/__init__.py
new file mode 100644
index 0000000..2315809
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/__init__.py
@@ -0,0 +1,10 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from . import patch
+from .parameter import Parameter
+from .module import Module
+from .container import *
+from . import utils
+from .utils import make_method
+from .layers import *
+from .loss import *
+from .flat_param import FlatParam
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/container.py b/experiments05/ant_umaze_1234/src/lunzi/nn/container.py
new file mode 100644
index 0000000..6dbafdc
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/container.py
@@ -0,0 +1,35 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import Dict, Any
+from .module import Module
+from .parameter import Parameter
+
+_dict_methods = ['__setitem__', '__getitem__', '__delitem__', '__len__', '__iter__', '__contains__',
+                 'update', 'keys', 'values', 'items', 'clear', 'pop']
+
+
+class ModuleDict(Module, dict):  # use dict for auto-complete
+    """
+        Essentially this exposes some methods of `Module._modules`.
+    """
+    def __init__(self, modules: Dict[Any, Module] = None):
+        super().__init__()
+        for method in _dict_methods:
+            setattr(self, method, getattr(self._modules, method))
+        if modules is not None:
+            self.update(modules)
+
+    def forward(self):
+        raise RuntimeError("ModuleDict is not callable")
+
+
+# Do we need a factory for it?
+class ParameterDict(Module, dict):
+    def __init__(self, parameters: Dict[Any, Parameter] = None):
+        super().__init__()
+        for method in _dict_methods:
+            setattr(self, method, getattr(self._modules, method))
+        if parameters is not None:
+            self.update(parameters)
+
+    def forward(self):
+        raise RuntimeError("ParameterDict is not callable")
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/flat_param.py b/experiments05/ant_umaze_1234/src/lunzi/nn/flat_param.py
new file mode 100644
index 0000000..5c4bb52
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/flat_param.py
@@ -0,0 +1,34 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+from lunzi.Logger import logger
+from .module import Module
+from .utils import make_method, n_parameters, parameters_to_vector, vector_to_parameters
+
+
+class FlatParam(Module):
+    def __init__(self, parameters):
+        super().__init__()
+        self.params = parameters
+        self.op_feed_flat, self.op_set_flat, self.op_get_flat = \
+            self.enable_flat()
+
+    def enable_flat(self):
+        params = self.params
+        logger.info('Enabling flattening... %s', [p.name for p in params])
+        n_params = n_parameters(params)
+        feed_flat = tf.placeholder(tf.float32, [n_params])
+        get_flat = parameters_to_vector(params)
+        set_flat = tf.group(*[tf.assign(param, value) for param, value in
+                            zip(params, vector_to_parameters(feed_flat, params))])
+        return feed_flat, set_flat, get_flat
+
+    def forward(self):
+        return self.op_get_flat
+
+    @make_method(feed='feed_flat', fetch='set_flat')
+    def set_flat(self, feed_flat):
+        pass
+
+    @make_method(fetch='get_flat')
+    def get_flat(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/layers.py b/experiments05/ant_umaze_1234/src/lunzi/nn/layers.py
new file mode 100644
index 0000000..a0cd9c2
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/layers.py
@@ -0,0 +1,88 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+import numpy as np
+from .module import Module
+from .parameter import Parameter
+
+
+class Linear(Module):
+    def __init__(self, in_features: int, out_features: int, bias=True, weight_initializer=None):
+        super().__init__()
+        self.in_features = in_features
+        self.out_features = out_features
+        if weight_initializer is None:
+            init_range = tf.sqrt(6.0 / (in_features + out_features))
+            weight_initializer = tf.random_uniform_initializer(-init_range, init_range, dtype=tf.float32)
+
+        self.use_bias = bias
+        with self.scope:
+            self.op_input = tf.placeholder(dtype=tf.float32, shape=[None, in_features], name='input')
+            self.weight = Parameter(weight_initializer([in_features, out_features],dtype=tf.float32), name='weight')
+            if bias:
+                self.bias = Parameter(tf.zeros([out_features], dtype=tf.float32), name='bias')
+
+        self.op_output = self(self.op_input)
+
+    def forward(self, x):
+        shape = x.get_shape().as_list()
+        if len(shape) > 2:
+            y = tf.tensordot(x, self.weight, [[len(shape) - 1], [0]])
+        else:
+            y = x.matmul(self.weight)
+        if self.use_bias:
+            y = y + self.bias
+        return y
+
+    def fast(self, x):
+        x = x.dot(self.weight.numpy())
+        if self.use_bias:
+            x = x + self.bias.numpy()
+        return x
+
+    def extra_repr(self):
+        return f'in_features={self.in_features}, out_features={self.out_features}, bias={self.use_bias}'
+
+
+class Sequential(Module):
+    def __init__(self, *modules):
+        super().__init__()
+        for i, module in enumerate(modules):
+            self._modules[i] = module
+
+    def forward(self, x):
+        for module in self._modules.values():
+            x = module(x)
+        return x
+
+    def fast(self, x):
+        for module in self._modules.values():
+            x = module.fast(x)
+        return x
+
+
+class ReLU(Module):
+    def forward(self, x):
+        return tf.nn.relu(x)
+
+    def fast(self, x: np.ndarray):
+        return np.maximum(x, 0)
+
+
+class Tanh(Module):
+    def forward(self, x):
+        return tf.nn.tanh(x)
+
+    def fast(self, x: np.ndarray):
+        return np.tanh(x)
+
+
+class Squeeze(Module):
+    def __init__(self, axis=None):
+        super().__init__()
+        self._axis = axis
+
+    def forward(self, x):
+        return x.squeeze(axis=self._axis)
+
+    def fast(self, x):
+        return x.squeeze(axis=self._axis)
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/loss.py b/experiments05/ant_umaze_1234/src/lunzi/nn/loss.py
new file mode 100644
index 0000000..26e662b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/loss.py
@@ -0,0 +1,40 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from lunzi import Tensor
+from .module import Module
+
+
+class PointwiseLoss(Module):
+    def __init__(self, size_average=True, reduce=True):
+        super().__init__()
+        self.size_average = size_average
+        self.reduce = reduce
+
+    def pointwise(self, output: Tensor, target: Tensor):
+        raise NotImplementedError
+
+    def forward(self, output: Tensor, target: Tensor, input: Tensor = None):
+        loss = self.pointwise(output, target)
+        if self.reduce and len(loss.shape) > 1:
+            if self.size_average:
+                loss = loss.reduce_mean(axis=1)
+            else:
+                loss = loss.reduce_sum(axis=1)
+        return loss
+
+
+class L1Loss(PointwiseLoss):
+    def pointwise(self, output: Tensor, target: Tensor):
+        return output.sub(target).abs()
+
+
+class L2Loss(PointwiseLoss):
+    def pointwise(self, output: Tensor, target: Tensor):
+        return output.sub(target).pow(2)
+
+    def forward(self, output: Tensor, target: Tensor, input: Tensor = None):
+        return super().forward(output, target).sqrt()
+
+
+class MSELoss(PointwiseLoss):
+    def pointwise(self, output: Tensor, target: Tensor):
+        return output.sub(target).pow(2)
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/module.py b/experiments05/ant_umaze_1234/src/lunzi/nn/module.py
new file mode 100644
index 0000000..8eacf3b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/module.py
@@ -0,0 +1,158 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import Dict, Any, Callable, List
+from collections import Counter
+import tensorflow as tf
+import numpy as np
+
+from lunzi import Tensor
+from lunzi.Logger import logger
+from .parameter import Parameter
+
+
+class Module(object):
+    """
+        A front-end for TensorFlow, heavily inspired by PyTorch's design and implementation.
+
+        Deepcopy is not supported since I didn't find a good way to duplicate `tf.Variables` and `tf.variable_scope`.
+    """
+
+    # To generate unique name scope
+    # The only reason we keep variable scope here is that we want the variables have meaning names,
+    # since the internal operations always look messy, I put no hope maintaining their names,
+    # So let's just do it for variables.
+    prefix_count = Counter()
+
+    @staticmethod
+    def _create_uid(prefix: str) -> str:
+        scope = tf.get_variable_scope().name + '/'
+        uid = Module.prefix_count[scope + prefix]
+        Module.prefix_count[scope + prefix] += 1
+        if uid == 0:
+            return prefix
+        return f'{prefix}_{uid}'
+
+    def __init__(self):
+        scope = Module._create_uid(self.__class__.__name__)
+        with tf.variable_scope(scope, reuse=False) as self._scope:
+            pass
+        # Since we only plan to support Python 3.6+, in which dict is already ordered, we don't use OrderedDict here.
+        self._parameters: Dict[Any, Parameter] = {}
+        self._modules: Dict[Any, Module] = {}
+        self._callables: Dict[Any, Callable] = {}
+
+    def forward(self, *args: List[Any], **kwargs: Dict[str, Any]) -> Tensor:
+        raise NotImplementedError
+
+    def fast(self, *args, **kwargs):
+        pass
+
+    def __setattr__(self, key, value):
+        # dynamically maintain sub modules.
+        modules = self.__dict__.get('_modules')
+        if isinstance(value, Parameter):
+            self._parameters[key] = value
+        if isinstance(value, Module):
+            assert modules is not None, 'Call `super().__init__` before assigning modules'
+            modules[key] = value
+        else:
+            if modules and key in modules:
+                del modules[key]
+        object.__setattr__(self, key, value)
+
+    def __call__(self, *args, **kwargs):
+        return self.forward(*args, **kwargs)
+
+    def register_callable(self, key, callable):
+        self._callables[key] = callable
+
+    def eval(self, fetch: str, **feed: Dict[str, np.ndarray]):
+        cache_key = f'[{" ".join(feed.keys())}] => [{fetch}]'
+        if cache_key not in self._callables:
+            logger.info('[%s] is making TensorFlow callables, key = %s', self.__class__.__name__, cache_key)
+            feed_ops = []
+            for key in feed.keys():
+                feed_ops.append(self.__dict__['op_' + key])
+            if isinstance(fetch, str):
+                fetch_ops = [self.__dict__['op_' + key] for key in fetch.split(' ')]
+                if len(fetch_ops) == 1:
+                    fetch_ops = fetch_ops[0]
+            else:
+                fetch_ops = fetch
+            self.register_callable(cache_key, tf.get_default_session().make_callable(fetch_ops, feed_ops))
+        return self._callables[cache_key](*feed.values())
+
+    def parameters(self, trainable=True, non_trainable=False, recursive=True, out=None) -> List[Parameter]:
+        """
+            We don't introduce `buffers` here. PyTorch has it since it doesn't have non-trainable Parameter.
+            A tensor in `buffers` is essentially a non-trainable Parameter (part of state_dict but isn't
+            optimized over).
+        """
+        if out is None:
+            out = []
+        for param in self._parameters.values():
+            if param.trainable and trainable or not param.trainable and non_trainable:
+                out.append(param)
+        if recursive:
+            for module in self._modules.values():
+                module.parameters(trainable=trainable, non_trainable=non_trainable, recursive=True, out=out)
+        # probably we don't need to sort since we're using `OrderedDict`
+        return out
+
+    @property
+    def scope(self) -> tf.variable_scope:
+        return tf.variable_scope(self._scope, reuse=tf.AUTO_REUSE)
+
+    def extra_repr(self) -> str:
+        return ''
+
+    def named_modules(self) -> dict:
+        return self._modules
+
+    def __repr__(self):
+        def dfs(node, prefix):
+            root_info = node.__class__.__name__
+            modules = node.named_modules()
+            if not modules:
+                return root_info + f'({node.extra_repr()})'
+
+            root_info += '(\n'
+            for key, module in modules.items():
+                module_repr = dfs(module, prefix + '    ')
+                root_info += f'{prefix}    ({key}): {module_repr}\n'
+            root_info += prefix + ')'
+            return root_info
+        return dfs(self, '')
+
+    def state_dict(self, recursive=True):
+        """
+            A better option is to find all parameters and then sess.run(state) but I assume this can't be the
+            bottleneck.
+        """
+        state = {}
+        for key, parameter in self._parameters.items():
+            # although we can use `.numpy()` here, for safety I'd use `.eval()`
+            state[key] = parameter.eval()
+        if recursive:
+            for key, module in self._modules.items():
+                state[key] = module.state_dict()
+        return state
+
+    def load_state_dict(self, state_dict: Dict[Any, Any], recursive=True, strict=True):
+        for key, parameter in self._parameters.items():
+            if key in state_dict:
+                parameter.load(state_dict[key])
+                parameter.invalidate()
+            else:
+                assert not strict, f'Missing Parameter {key} in state_dict'
+        if recursive:
+            for key, module in self._modules.items():
+                if key in state_dict:
+                    module.load_state_dict(state_dict[key], recursive=recursive, strict=strict)
+                else:
+                    assert not strict, f'Missing Module {key} in state_dict.'
+
+    def apply(self, fn):
+        for module in self._modules.values():
+            module.apply(fn)
+        fn(self)
+        return self
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/parameter.py b/experiments05/ant_umaze_1234/src/lunzi/nn/parameter.py
new file mode 100644
index 0000000..969d79f
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/parameter.py
@@ -0,0 +1,24 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+from lunzi import Tensor
+
+
+def numpy(self):
+    if self.__dict__.get('_numpy_cache', None) is None:
+        self._numpy_cache: Tensor = self.eval()
+    return self._numpy_cache
+
+
+def invalidate(self):
+    self._numpy_cache = None
+
+
+# Q: Why not inherit from `tf.Variable`?
+# A: Since TensorFlow 1.11, `tf.Variable` has a meta class VariableMetaClass, which overrides `__call__`.
+#    And it's `_variable_call` function doesn't explicitly call `tf.Variable` so the return value must
+#    be a `tf.Variable`, which makes inheritance impossible.
+Parameter = tf.Variable
+
+Parameter.numpy = numpy
+Parameter.invalidate = invalidate
+
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/patch.py b/experiments05/ant_umaze_1234/src/lunzi/nn/patch.py
new file mode 100644
index 0000000..5db96d8
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/patch.py
@@ -0,0 +1,60 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+
+from lunzi.Logger import logger
+
+
+def find_monkey_patch_keys(avoid_set=None):
+    if avoid_set is None:
+        avoid_set = {"shape"}  # tf.shape conflicts with Tensor.shape
+    patched = []
+    for key, value in tf.__dict__.items():
+        if not callable(value) or key in avoid_set:
+            continue
+        doc = value.__doc__
+        if doc is None:
+            continue
+        loc = doc.find('Args:\n')
+        if loc == -1:
+            continue
+
+        # Am I doing NLP?
+        # It seems that PyTorch has better doc. They always write `x (Tensor): ...` which is much easier to parse.
+        first_arg_doc = doc[loc + 6:].split('\n')[0].split(': ')[1]
+        if first_arg_doc.startswith('A `Tensor`') or first_arg_doc.startswith('`Tensor`') or key.startswith('reduce_'):
+            patched.append(key)
+    logger.warning(f'Monkey patched TensorFlow: {patched}')
+    return patched
+
+
+def monkey_patch(avoid_set=None):
+    logger.warning('Monkey patching TensorFlow...')
+
+    patched = ['abs', 'acos', 'acosh', 'add', 'angle', 'argmax', 'argmin', 'asin', 'asinh', 'atan', 'atan2', 'atanh',
+            'betainc', 'cast', 'ceil', 'check_numerics', 'clip_by_average_norm', 'clip_by_norm', 'clip_by_value',
+            'complex', 'conj', 'cos', 'cosh', 'cross', 'cumprod', 'cumsum', 'dequantize', 'diag', 'digamma', 'div',
+            'equal', 'erf', 'erfc', 'exp', 'expand_dims', 'expm1', 'fill', 'floor', 'floor_div', 'floordiv', 'floormod',
+            'gather', 'gather_nd', 'greater', 'greater_equal', 'hessians', 'identity', 'igamma', 'igammac', 'imag',
+            'is_finite', 'is_inf', 'is_nan', 'less', 'less_equal', 'lgamma', 'log', 'log1p', 'logical_and',
+            'logical_not', 'logical_or', 'matmul', 'maximum', 'meshgrid', 'minimum', 'mod', 'multiply', 'negative',
+            'norm', 'not_equal', 'one_hot', 'ones_like', 'pad', 'polygamma', 'pow', 'quantize', 'real', 'realdiv',
+            'reciprocal', 'reduce_all', 'reduce_any', 'reduce_logsumexp', 'reduce_max', 'reduce_mean', 'reduce_min',
+            'reduce_prod', 'reduce_sum', 'reshape', 'reverse', 'rint', 'round', 'rsqrt', 'scatter_nd', 'sign', 'sin',
+            'sinh', 'size', 'slice', 'sqrt', 'square', 'squeeze', 'stop_gradient', 'subtract', 'tan', 'tensordot',
+            'tile', 'to_bfloat16', 'to_complex128', 'to_complex64', 'to_double', 'to_float', 'to_int32', 'to_int64',
+            'transpose', 'truediv', 'truncatediv', 'truncatemod', 'unique', 'where', 'zeros_like', 'zeta']
+    alias = {
+        'mul': 'multiply',
+        'sub': 'subtract',
+    }
+
+    # use the code below for more ops
+    # patched = find_monkey_patch_keys(avoid_set)
+
+    for key, method in list(zip(patched, patched)) + list(alias.items()):
+        value = tf.__dict__[method]
+        setattr(tf.Tensor, key, value)
+        setattr(tf.Variable, key, value)
+
+
+monkey_patch()
diff --git a/experiments05/ant_umaze_1234/src/lunzi/nn/utils.py b/experiments05/ant_umaze_1234/src/lunzi/nn/utils.py
new file mode 100644
index 0000000..9fa5707
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/nn/utils.py
@@ -0,0 +1,85 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import Callable, List, Union
+import inspect
+from functools import wraps
+import tensorflow as tf
+import numpy as np
+from lunzi import Tensor
+
+from .parameter import Parameter
+
+
+def make_method(feed: str = None, fetch: str = ''):
+    """
+        The following code:
+
+            @make_method('. w', fetch='d)
+            def func(a, c):
+                pass
+
+        will be converted to
+
+            def func(a, c, fetch='d'):
+                return self.eval(fetch, a=a, w=c)
+
+        Note that `func(1, c=2, b=1)` is also supported. This is
+        useful when writing PyTorch-like object method.
+
+    """
+
+    def decorator(func: Callable):
+        arg_names = inspect.signature(func).parameters.keys()
+        arg_map = {}
+        if feed is None:
+            arg_map = {op_name: op_name for op_name in arg_names if op_name != 'self'}
+        else:
+            feeds = ['-'] + feed.split(' ')  # ignore first `self`
+            for op_name, arg_name in zip(feeds, arg_names):
+                if op_name == '.':
+                    arg_map[op_name] = op_name
+                elif op_name != '-':  # deprecated
+                    arg_map[op_name] = arg_name
+
+        @wraps(func)
+        def wrapper(self, *args, **kwargs):
+            cur_fetch = kwargs.pop('fetch', fetch)
+            call_args = inspect.getcallargs(func, self, *args, **kwargs)
+            feed_dict = {op_name: call_args[arg_name] for op_name, arg_name in arg_map.items()}
+            return self.eval(cur_fetch, **feed_dict)
+
+        return wrapper
+
+    return decorator
+
+
+def n_parameters(params: List[Parameter]) -> int:
+    return sum([np.prod(p.shape) for p in params])
+
+
+def parameters_to_vector(parameters: List[Union[Parameter, Tensor]]) -> Tensor:
+    return tf.concat([param.reshape([-1]) for param in parameters], axis=0)
+
+
+def vector_to_parameters(vec: Tensor, parameters: List[Parameter]) -> List[Tensor]:
+    params: List[Tensor] = []
+    start = 0
+    for p in parameters:
+        end = start + np.prod(p.shape)
+        params.append(vec[start:end].reshape(p.shape))
+        start = end
+    return params
+
+
+def hessian_vec_prod(ys: Tensor, xs: List[Parameter], vs: Tensor) -> Tensor:
+    grad = parameters_to_vector(tf.gradients(ys, xs))
+    aux = (grad * vs).reduce_sum()
+    return parameters_to_vector(tf.gradients(aux, xs))
+
+
+# credit to https://github.com/renmengye/tensorflow-forward-ad/issues/2#issue-234418055
+def jacobian_vec_prod(ys: Tensor, xs: List[Parameter], vs: Tensor) -> Tensor:
+    u = tf.zeros_like(ys)  # dummy variable
+    grad = tf.gradients(ys, xs, grad_ys=u)
+    return tf.gradients(grad, u, grad_ys=vs)
+
+
diff --git a/experiments05/ant_umaze_1234/src/lunzi/stubs.py b/experiments05/ant_umaze_1234/src/lunzi/stubs.py
new file mode 100644
index 0000000..644c477
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/stubs.py
@@ -0,0 +1,6 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+
+
+class Tensor(tf.Tensor):
+    pass
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/lunzi/stubs.pyi b/experiments05/ant_umaze_1234/src/lunzi/stubs.pyi
new file mode 100644
index 0000000..7bab814
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/lunzi/stubs.pyi
@@ -0,0 +1,138 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+
+class Tensor(tf.Tensor):
+    def abs(x, name=None) -> Tensor: ...
+    def acos(x, name=None) -> Tensor: ...
+    def acosh(x, name=None) -> Tensor: ...
+    def add(x, y, name=None) -> Tensor: ...
+    def angle(input, name=None) -> Tensor: ...
+    def argmax(input, axis=None, name=None, dimension=None, output_type=tf.int64) -> Tensor: ...
+    def argmin(input, axis=None, name=None, dimension=None, output_type=tf.int64) -> Tensor: ...
+    def asin(x, name=None) -> Tensor: ...
+    def asinh(x, name=None) -> Tensor: ...
+    def atan(x, name=None) -> Tensor: ...
+    def atan2(y, x, name=None) -> Tensor: ...
+    def atanh(x, name=None) -> Tensor: ...
+    def betainc(a, b, x, name=None) -> Tensor: ...
+    def cast(x, dtype, name=None) -> Tensor: ...
+    def ceil(x, name=None) -> Tensor: ...
+    def check_numerics(tensor, message, name=None) -> Tensor: ...
+    def clip_by_average_norm(t, clip_norm, name=None) -> Tensor: ...
+    def clip_by_norm(t, clip_norm, axes=None, name=None) -> Tensor: ...
+    def clip_by_value(t, clip_value_min, clip_value_max, name=None) -> Tensor: ...
+    def complex(real, imag, name=None) -> Tensor: ...
+    def conj(x, name=None) -> Tensor: ...
+    def cos(x, name=None) -> Tensor: ...
+    def cosh(x, name=None) -> Tensor: ...
+    def cross(a, b, name=None) -> Tensor: ...
+    def cumprod(x, axis=0, exclusive=False, reverse=False, name=None) -> Tensor: ...
+    def cumsum(x, axis=0, exclusive=False, reverse=False, name=None) -> Tensor: ...
+    def dequantize(input, min_range, max_range, mode='MIN_COMBINED', name=None) -> Tensor: ...
+    def diag(diagonal, name=None) -> Tensor: ...
+    def digamma(x, name=None) -> Tensor: ...
+    def div(x, y, name=None) -> Tensor: ...
+    def equal(x, y, name=None) -> Tensor: ...
+    def erf(x, name=None) -> Tensor: ...
+    def erfc(x, name=None) -> Tensor: ...
+    def exp(x, name=None) -> Tensor: ...
+    def expand_dims(input, axis=None, name=None, dim=None) -> Tensor: ...
+    def expm1(x, name=None) -> Tensor: ...
+    def fill(dims, value, name=None) -> Tensor: ...
+    def floor(x, name=None) -> Tensor: ...
+    def floor_div(x, y, name=None) -> Tensor: ...
+    def floordiv(x, y, name=None) -> Tensor: ...
+    def floormod(x, y, name=None) -> Tensor: ...
+    def gather(params, indices, validate_indices=None, name=None, axis=0) -> Tensor: ...
+    def gather_nd(params, indices, name=None) -> Tensor: ...
+    def greater(x, y, name=None) -> Tensor: ...
+    def greater_equal(x, y, name=None) -> Tensor: ...
+    def hessians(ys, xs, name='hessians', colocate_gradients_with_ops=False, gate_gradients=False, aggregation_method=None) -> Tensor: ...
+    def identity(input, name=None) -> Tensor: ...
+    def igamma(a, x, name=None) -> Tensor: ...
+    def igammac(a, x, name=None) -> Tensor: ...
+    def imag(input, name=None) -> Tensor: ...
+    def is_finite(x, name=None) -> Tensor: ...
+    def is_inf(x, name=None) -> Tensor: ...
+    def is_nan(x, name=None) -> Tensor: ...
+    def less(x, y, name=None) -> Tensor: ...
+    def less_equal(x, y, name=None) -> Tensor: ...
+    def lgamma(x, name=None) -> Tensor: ...
+    def log(x, name=None) -> Tensor: ...
+    def log1p(x, name=None) -> Tensor: ...
+    def logical_and(x, y, name=None) -> Tensor: ...
+    def logical_not(x, name=None) -> Tensor: ...
+    def logical_or(x, y, name=None) -> Tensor: ...
+    def matmul(a, b, transpose_a=False, transpose_b=False, adjoint_a=False, adjoint_b=False, a_is_sparse=False, b_is_sparse=False, name=None) -> Tensor: ...
+    def maximum(x, y, name=None) -> Tensor: ...
+    def meshgrid(*args, **kwargs) -> Tensor: ...
+    def minimum(x, y, name=None) -> Tensor: ...
+    def mod(x, y, name=None) -> Tensor: ...
+    def mul(x, y, name=None) -> Tensor: ...
+    def multiply(x, y, name=None) -> Tensor: ...
+    def negative(x, name=None) -> Tensor: ...
+    def norm(tensor, ord='euclidean', axis=None, keepdims=None, name=None) -> Tensor: ...
+    def not_equal(x, y, name=None) -> Tensor: ...
+    def one_hot(indices, depth, on_value=None, off_value=None, axis=None, dtype=None, name=None) -> Tensor: ...
+    def ones_like(tensor, dtype=None, name=None, optimize=True) -> Tensor: ...
+    def pad(tensor, paddings, mode='CONSTANT', name=None, constant_values=0) -> Tensor: ...
+    def polygamma(a, x, name=None) -> Tensor: ...
+    def pow(x, y, name=None) -> Tensor: ...
+    def quantize(input, min_range, max_range, T, mode='MIN_COMBINED', round_mode='HALF_AWAY_FROM_ZERO', name=None) -> Tensor: ...
+    def real(input, name=None) -> Tensor: ...
+    def realdiv(x, y, name=None) -> Tensor: ...
+    def reciprocal(x, name=None) -> Tensor: ...
+    def reduce_all(input_tensor, axis=None, keepdims=None, name=None, reduction_indices=None) -> Tensor: ...
+    def reduce_any(input_tensor, axis=None, keepdims=None, name=None, reduction_indices=None) -> Tensor: ...
+    def reduce_logsumexp(input_tensor, axis=None, keepdims=None, name=None, reduction_indices=None) -> Tensor: ...
+    def reduce_max(input_tensor, axis=None, keepdims=None, name=None, reduction_indices=None) -> Tensor: ...
+    def reduce_mean(input_tensor, axis=None, keepdims=None, name=None, reduction_indices=None) -> Tensor: ...
+    def reduce_min(input_tensor, axis=None, keepdims=None, name=None, reduction_indices=None) -> Tensor: ...
+    def reduce_prod(input_tensor, axis=None, keepdims=None, name=None, reduction_indices=None) -> Tensor: ...
+    def reduce_sum(input_tensor, axis=None, keepdims=None, name=None, reduction_indices=None) -> Tensor: ...
+    def reshape(tensor, shape, name=None) -> Tensor: ...
+    def reverse(tensor, axis, name=None) -> Tensor: ...
+    def rint(x, name=None) -> Tensor: ...
+    def round(x, name=None) -> Tensor: ...
+    def rsqrt(x, name=None) -> Tensor: ...
+    def scatter_nd(indices, updates, shape, name=None) -> Tensor: ...
+    def sign(x, name=None) -> Tensor: ...
+    def sin(x, name=None) -> Tensor: ...
+    def sinh(x, name=None) -> Tensor: ...
+    def size(input, name=None, out_type=tf.int32) -> Tensor: ...
+    def slice(input_, begin, size, name=None) -> Tensor: ...
+    def sqrt(x, name=None) -> Tensor: ...
+    def square(x, name=None) -> Tensor: ...
+    def squeeze(input, axis=None, name=None, squeeze_dims=None) -> Tensor: ...
+    def stop_gradient(input, name=None) -> Tensor: ...
+    def sub(x, y, name=None) -> Tensor: ...
+    def subtract(x, y, name=None) -> Tensor: ...
+    def tan(x, name=None) -> Tensor: ...
+    def tensordot(a, b, axes, name=None) -> Tensor: ...
+    def tile(input, multiples, name=None) -> Tensor: ...
+    def to_bfloat16(x, name='ToBFloat16') -> Tensor: ...
+    def to_complex128(x, name='ToComplex128') -> Tensor: ...
+    def to_complex64(x, name='ToComplex64') -> Tensor: ...
+    def to_double(x, name='ToDouble') -> Tensor: ...
+    def to_float(x, name='ToFloat') -> Tensor: ...
+    def to_int32(x, name='ToInt32') -> Tensor: ...
+    def to_int64(x, name='ToInt64') -> Tensor: ...
+    def transpose(a, perm=None, name='transpose', conjugate=False) -> Tensor: ...
+    def truediv(x, y, name=None) -> Tensor: ...
+    def truncatediv(x, y, name=None) -> Tensor: ...
+    def truncatemod(x, y, name=None) -> Tensor: ...
+    def unique(x, out_idx=tf.int32, name=None) -> Tensor: ...
+    def where(condition, x=None, y=None, name=None) -> Tensor: ...
+    def zeros_like(tensor, dtype=None, name=None, optimize=True) -> Tensor: ...
+    def zeta(x, q, name=None) -> Tensor: ...
+
+    def __add__(self, other) -> Tensor: ...
+    def __sub__(self, other) -> Tensor: ...
+    def __mul__(self, other) -> Tensor: ...
+    def __rdiv__(self, other) -> Tensor: ...
+    def __itruediv__(self, other) -> Tensor: ...
+    def __rsub__(self, other) -> Tensor: ...
+    def __isub__(self, other) -> Tensor: ...
+    def __imul__(self, other) -> Tensor: ...
+    def __rmul__(self, other) -> Tensor: ...
+    def __radd__(self, other) -> Tensor: ...
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/main.py b/experiments05/ant_umaze_1234/src/main.py
new file mode 100644
index 0000000..38aafb2
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/main.py
@@ -0,0 +1,232 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import pickle
+from collections import deque
+import tensorflow as tf
+import numpy as np
+from tqdm import tqdm
+
+import lunzi.nn as nn
+from lunzi.Logger import logger
+from slbo.utils.average_meter import AverageMeter
+from slbo.utils.flags import FLAGS
+from slbo.utils.dataset import Dataset, gen_dtype
+from slbo.utils.OU_noise import OUNoise
+from slbo.utils.normalizer import Normalizers
+from slbo.utils.tf_utils import get_tf_config
+from slbo.utils.runner import Runner
+from slbo.policies.gaussian_mlp_policy import GaussianMLPPolicy
+from slbo.envs.virtual_env import VirtualEnv
+from slbo.dynamics_model import DynamicsModel
+from slbo.v_function.mlp_v_function import MLPVFunction
+from slbo.partial_envs import make_env
+from slbo.loss.multi_step_loss import MultiStepLoss
+from slbo.algos.TRPO import TRPO
+from slbo.random_net import RandomNet
+
+
+def evaluate(settings, tag):
+    return_means = []
+    for runner, policy, name in settings:
+        runner.reset()
+        _, ep_infos = runner.run(policy, FLAGS.rollout.n_test_samples)
+        if name == 'Real Env':
+            returns = np.array([ep_info['success'] for ep_info in ep_infos])
+        else:
+            returns = np.array([ep_info['return'] for ep_info in ep_infos])
+        logger.info('Tag = %s, Reward on %s (%d episodes): mean = %.6f, std = %.6f', tag, name,
+                    len(returns), np.mean(returns), np.std(returns))
+
+        return_means.append(np.mean(returns))
+
+    return return_means
+
+
+
+def add_multi_step(src: Dataset, dst: Dataset):
+    n_envs = 1
+    dst.extend(src[:-n_envs])
+
+    ending = src[-n_envs:].copy()
+    ending.timeout = True
+    dst.extend(ending)
+
+
+def make_real_runner(n_envs):
+    from slbo.envs.batched_env import BatchedEnv
+    batched_env = BatchedEnv([make_env(FLAGS.env.id) for _ in range(n_envs)])
+    return Runner(batched_env, rescale_action=True, **FLAGS.runner.as_dict())
+
+
+def main():
+    FLAGS.set_seed()
+    FLAGS.freeze()
+
+    env = make_env(FLAGS.env.id)
+    dim_state = int(np.prod(env.observation_space.shape))
+    dim_action = int(np.prod(env.action_space.shape))
+
+    env.verify()
+
+    normalizers = Normalizers(dim_action=dim_action, dim_state=dim_state)
+
+    dtype = gen_dtype(env, 'state action next_state reward done timeout')
+    train_set = Dataset(dtype, FLAGS.rollout.max_buf_size)
+    dev_set = Dataset(dtype, FLAGS.rollout.max_buf_size)
+
+    policy = GaussianMLPPolicy(dim_state, dim_action, normalizer=normalizers.state, **FLAGS.policy.as_dict())
+    # batched noises
+    #noise = OUNoise(env.action_space, theta=FLAGS.OUNoise.theta, sigma=FLAGS.OUNoise.sigma, shape=(1, dim_action))
+    vfn = MLPVFunction(dim_state, [64, 64], normalizers.state)
+    model = DynamicsModel(dim_state, dim_action, normalizers, FLAGS.model.hidden_sizes)
+    random_net = RandomNet(dim_state, dim_action, normalizers, FLAGS.model.hidden_sizes)
+
+    virt_env = VirtualEnv(model, make_env(FLAGS.env.id), random_net, FLAGS.plan.n_envs,FLAGS.model.hidden_sizes[-1], 
+                            FLAGS.pc.bonus_scale,FLAGS.pc.lamb, opt_model=FLAGS.slbo.opt_model)
+    virt_runner = Runner(virt_env, **{**FLAGS.runner.as_dict(), 'max_steps': FLAGS.plan.max_steps})
+
+    criterion_map = {
+        'L1': nn.L1Loss(),
+        'L2': nn.L2Loss(),
+        'MSE': nn.MSELoss(),
+    }
+    criterion = criterion_map[FLAGS.model.loss]
+    loss_mod = MultiStepLoss(model, normalizers, dim_state, dim_action, criterion, FLAGS.model.multi_step)
+    loss_mod.build_backward(FLAGS.model.lr, FLAGS.model.weight_decay)
+    algo = TRPO(vfn=vfn, policy=policy, dim_state=dim_state, dim_action=dim_action, **FLAGS.TRPO.as_dict())
+
+    tf.get_default_session().run(tf.global_variables_initializer())
+
+    runners = {
+        'test': make_real_runner(4),
+        'collect': make_real_runner(1),
+        'dev': make_real_runner(1),
+        'train': make_real_runner(FLAGS.plan.n_envs) if FLAGS.algorithm == 'MF' else virt_runner,
+    }
+    settings = [(runners['test'], policy, 'Real Env'), (runners['train'], policy, 'Virt Env')]
+
+    saver = nn.ModuleDict({'policy': policy, 'model': model, 'vfn': vfn})
+    print(saver)
+
+    eval_real_returns = []
+    timesteps = []
+
+    if FLAGS.ckpt.model_load:
+        saver.load_state_dict(np.load(FLAGS.ckpt.model_load)[()])
+        logger.warning('Load model from %s', FLAGS.ckpt.model_load)
+
+    if FLAGS.ckpt.buf_load:
+        n_samples = 0
+        for i in range(FLAGS.ckpt.buf_load_index):
+            data = pickle.load(open(f'{FLAGS.ckpt.buf_load}/stage-{i}.inc-buf.pkl', 'rb'))
+            add_multi_step(data, train_set)
+            n_samples += len(data)
+        logger.warning('Loading %d samples from %s', n_samples, FLAGS.ckpt.buf_load)
+
+    max_ent_coef = 0
+    print("!!!!!!!!")
+    print(virt_env.bonus_scale)
+    for T in range(FLAGS.slbo.n_stages):
+        logger.info('------ Starting Stage %d --------', T)
+        eval_returns = evaluate(settings, 'episode')
+        eval_real_returns.append(eval_returns[0])
+        timesteps.append(T*FLAGS.rollout.n_train_samples)
+
+        if not FLAGS.use_prev:
+            train_set.clear()
+            dev_set.clear()
+
+        # collect data
+        recent_train_set, ep_infos = runners['collect'].run(policy, FLAGS.rollout.n_train_samples, render=False)
+        add_multi_step(recent_train_set, train_set)
+        add_multi_step(
+            runners['dev'].run(policy, FLAGS.rollout.n_dev_samples)[0],
+            dev_set,
+        )
+
+        returns = np.array([ep_info['return'] for ep_info in ep_infos])
+
+        if len(returns) > 0:
+            logger.info("episode: %s", np.mean(returns))
+
+        if T == 0:  # check
+            samples = train_set.sample_multi_step(100, 1, FLAGS.model.multi_step)
+            for i in range(FLAGS.model.multi_step - 1):
+                masks = 1 - (samples.done[i] | samples.timeout[i])[..., np.newaxis]
+                assert np.allclose(samples.state[i + 1] * masks, samples.next_state[i] * masks)
+
+        # recent_states = obsvs
+        # ref_actions = policy.eval('actions_mean actions_std', states=recent_states)
+        if FLAGS.rollout.normalizer == 'policy' or FLAGS.rollout.normalizer == 'uniform' and T == 0:
+            normalizers.state.update(recent_train_set.state)
+            normalizers.action.update(recent_train_set.action)
+            normalizers.diff.update(recent_train_set.next_state - recent_train_set.state)
+        #print(recent_train_set.state.shape)
+        virt_env.update_cov(recent_train_set.state,recent_train_set.action)
+
+        #if T == FLAGS.pc.bonus_stop_time:
+        #    virt_env.bonus_scale = 0.
+
+        for i in range(FLAGS.slbo.n_iters):
+            #if i % FLAGS.slbo.n_evaluate_iters == 0 and i != 0:
+                # cur_actions = policy.eval('actions_mean actions_std', states=recent_states)
+                # kl_old_new = gaussian_kl(*ref_actions, *cur_actions).sum(axis=1).mean()
+                # logger.info('KL(old || cur) = %.6f', kl_old_new)
+            #    evaluate(settings, 'iteration')
+
+            losses = deque(maxlen=FLAGS.slbo.n_model_iters)
+            grad_norm_meter = AverageMeter()
+            n_model_iters = FLAGS.slbo.n_model_iters
+            for _ in range(n_model_iters):
+                samples = train_set.sample_multi_step(FLAGS.model.train_batch_size, 1, FLAGS.model.multi_step)
+                _, train_loss, grad_norm = loss_mod.get_loss(
+                    samples.state, samples.next_state, samples.action, ~samples.done & ~samples.timeout,
+                    fetch='train loss grad_norm')
+                losses.append(train_loss.mean())
+                grad_norm_meter.update(grad_norm)
+                # ideally, we should define an Optimizer class, which takes parameters as inputs.
+                # The `update` method of `Optimizer` will invalidate all parameters during updates.
+                for param in model.parameters():
+                    param.invalidate()
+
+            if i % FLAGS.model.validation_freq == 0:
+                samples = train_set.sample_multi_step(
+                    FLAGS.model.train_batch_size, 1, FLAGS.model.multi_step)
+                loss = loss_mod.get_loss(
+                    samples.state, samples.next_state, samples.action, ~samples.done & ~samples.timeout)
+                loss = loss.mean()
+                if np.isnan(loss) or np.isnan(np.mean(losses)):
+                    logger.info('nan! %s %s', np.isnan(loss), np.isnan(np.mean(losses)))
+                logger.info('# Iter %3d: Loss = [train = %.3f, dev = %.3f], after %d steps, grad_norm = %.6f',
+                            i, np.mean(losses), loss, n_model_iters, grad_norm_meter.get())
+
+            for n_updates in tqdm(range(FLAGS.slbo.n_policy_iters)):
+                if FLAGS.algorithm != 'MF' and FLAGS.slbo.start == 'buffer':
+                    runners['train'].set_state(train_set.sample(FLAGS.plan.n_envs).state)
+                else:
+                    runners['train'].reset()
+
+                data, ep_infos = runners['train'].run(policy, FLAGS.plan.n_trpo_samples)
+                advantages, values = runners['train'].compute_advantage(vfn, data)
+                dist_mean, dist_std, vf_loss = algo.train(max_ent_coef, data, advantages, values)
+                returns = [info['return'] for info in ep_infos]
+                #logger.info('[TRPO] # %d: n_episodes = %d, returns: {mean = %.0f, std = %.0f}, '
+                #            'dist std = %.10f, dist mean = %.10f, vf_loss = %.3f',
+                #            n_updates, len(returns), np.mean(returns), np.std(returns) / np.sqrt(len(returns)),
+                #            dist_std, dist_mean, vf_loss)
+
+        if T % FLAGS.ckpt.n_save_stages == 0:
+            np.save(f'{FLAGS.log_dir}/stage-{T}', saver.state_dict())
+            np.save(f'{FLAGS.log_dir}/final', saver.state_dict())
+        if FLAGS.ckpt.n_save_stages == 1:
+            pickle.dump(recent_train_set, open(f'{FLAGS.log_dir}/stage-{T}.inc-buf.pkl', 'wb'))
+
+    eval_returns = evaluate(settings, 'episode')
+    eval_real_returns.append(eval_returns[0])
+    timesteps.append(T*FLAGS.rollout.n_train_samples)
+    np.save(f'{FLAGS.log_dir}/eval_real_returns', eval_real_returns)
+    np.save(f'{FLAGS.log_dir}/timesteps', timesteps)
+
+
+if __name__ == '__main__':
+    with tf.Session(config=get_tf_config()):
+        main()
diff --git a/experiments05/ant_umaze_1234/src/requirements.txt b/experiments05/ant_umaze_1234/src/requirements.txt
new file mode 100644
index 0000000..8991cc0
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/requirements.txt
@@ -0,0 +1,6 @@
+tensorflow
+numpy
+pyyaml
+termcolor
+gym
+json_tricks
diff --git a/experiments05/ant_umaze_1234/src/rllab_requirements.txt b/experiments05/ant_umaze_1234/src/rllab_requirements.txt
new file mode 100644
index 0000000..9fb2d37
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/rllab_requirements.txt
@@ -0,0 +1,7 @@
+theano
+cached_property
+pyopengl
+joblib
+mako
+mujoco_py
+
diff --git a/experiments05/ant_umaze_1234/src/run2.sh b/experiments05/ant_umaze_1234/src/run2.sh
new file mode 100644
index 0000000..7440dc5
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/run2.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+for env_name in $1; do
+    echo "=> Running environment ${env_name}"
+    #for random_seed in 1234 2314 2345 1235; do
+    for random_seed in 1234; do
+        python main.py -c configs/algos/slbo_bm_200k.yml configs/env_tingwu/${env_name}.yml \
+	    -s pc.bonus_scale=0.2 log_dir=./experiments02/${env_name}_${random_seed} seed=${random_seed}
+    done
+done
diff --git a/experiments05/ant_umaze_1234/src/run_experiments.sh b/experiments05/ant_umaze_1234/src/run_experiments.sh
new file mode 100644
index 0000000..e3f2ad7
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/run_experiments.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+for env_name in $1; do
+    echo "=> Running environment ${env_name}"
+    #for random_seed in 1234 2314 2345 1235; do
+    for random_seed in 1234; do
+        python main.py -c configs/algos/slbo_bm_200k.yml configs/env_tingwu/${env_name}.yml \
+	    -s pc.bonus_scale=0.5 log_dir=./experiments05/${env_name}_${random_seed} seed=${random_seed}
+    done
+done
diff --git a/experiments05/ant_umaze_1234/src/slbo/__init__.py b/experiments05/ant_umaze_1234/src/slbo/__init__.py
new file mode 100644
index 0000000..5c7f19c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/__init__.py
@@ -0,0 +1 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
diff --git a/experiments05/ant_umaze_1234/src/slbo/algos/TRPO.py b/experiments05/ant_umaze_1234/src/slbo/algos/TRPO.py
new file mode 100644
index 0000000..e8469e3
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/algos/TRPO.py
@@ -0,0 +1,183 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import List, Callable
+import tensorflow as tf
+import numpy as np
+import lunzi.nn as nn
+from lunzi import Tensor
+from lunzi.Logger import logger
+from slbo.utils.dataset import Dataset
+from slbo.policies import BaseNNPolicy
+from slbo.v_function import BaseVFunction
+
+
+def average_l2_norm(x):
+    return np.sqrt((x**2).mean())
+
+
+# for damping, modify func_Ax
+def conj_grad(mat_mul_vec: Callable[[np.ndarray], np.ndarray], b, n_iters=10, residual_tol=1e-10, verbose=False):
+    p = b.copy()
+    r = b.copy()
+    x = np.zeros_like(b)
+    r_dot_r = r.dot(r)
+
+    for i in range(n_iters):
+        if verbose:
+            logger.info('[CG] iters = %d, |Res| = %.6f, |x| = %.6f', i, r_dot_r, np.linalg.norm(x))
+        z = mat_mul_vec(p)
+        v = r_dot_r / p.dot(z)
+        x += v * p
+        r -= v * z
+        new_r_dot_r = r.dot(r)
+        if new_r_dot_r < residual_tol:
+            break
+        mu = new_r_dot_r / r_dot_r
+        p = r + mu * p
+        r_dot_r = new_r_dot_r
+    return x
+
+
+class TRPO(nn.Module):
+    def __init__(self, dim_state: int, dim_action: int, policy: BaseNNPolicy, vfn: BaseVFunction, max_kl: float,
+                 n_cg_iters: int, ent_coef=0.0, cg_damping=0.01, vf_lr=3e-4, n_vf_iters=3):
+        super().__init__()
+        self.dim_state = dim_state
+        self.policy = policy
+        self.ent_coef = ent_coef
+        self.vf = vfn
+        self.n_cg_iters = n_cg_iters
+        self.max_kl = max_kl
+        self.cg_damping = cg_damping
+        self.n_vf_iters = n_vf_iters
+        self.vf_lr = vf_lr
+
+        # doing backtrace, so don't need to separate.
+        self.flatten = nn.FlatParam(self.policy.parameters())
+        self.old_policy: nn.Module = policy.clone()
+
+        with self.scope:
+            self.op_returns = tf.placeholder(dtype=tf.float32, shape=[None], name='returns')
+            self.op_advantages = tf.placeholder(dtype=tf.float32, shape=[None], name='advantages')
+            self.op_states = tf.placeholder(dtype=tf.float32, shape=[None, dim_state], name='states')
+            self.op_actions = tf.placeholder(dtype=tf.float32, shape=[None, dim_action], name='actions')
+            self.op_feed_params = tf.placeholder(dtype=tf.float32, shape=[None], name='feed_params')
+
+            self.op_tangents = tf.placeholder(
+                dtype=tf.float32, shape=[nn.utils.n_parameters(self.policy.parameters())])
+            self.op_ent_coef = tf.placeholder(dtype=tf.float32, shape=[], name='ent_coef')
+
+        self.op_mean_kl, self.op_loss, self.op_dist_std, self.op_dist_mean, self.op_policy_loss = \
+            self(self.op_states, self.op_actions, self.op_advantages, self.op_ent_coef)
+
+        self.op_sync_old, self.op_hessian_vec_prod, self.op_flat_grad = \
+            self.compute_natural_grad(self.op_loss, self.op_mean_kl, self.op_tangents)
+
+        self.op_vf_loss, self.op_train_vf = self.compute_vf(self.op_states, self.op_returns)
+
+    def forward(self, states, actions, advantages, ent_coef):
+        old_distribution: tf.distributions.Normal = self.old_policy(states)
+        distribution: tf.distributions.Normal = self.policy(states)
+        mean_kl = old_distribution.kl_divergence(distribution).reduce_sum(axis=1).reduce_mean()
+        entropy = distribution.entropy().reduce_sum(axis=1).reduce_mean()
+        entropy_bonus = ent_coef * entropy
+
+        ratios: Tensor = (distribution.log_prob(actions) - old_distribution.log_prob(actions)) \
+            .reduce_sum(axis=1).exp()
+        # didn't output op_policy_loss since in principle it should be 0.
+        policy_loss = ratios.mul(advantages).reduce_mean()
+
+        # We're doing Gradient Ascent so this is, in fact, gain.
+        loss = policy_loss + entropy_bonus
+
+        return mean_kl, loss, distribution.stddev().log().reduce_mean().exp(), \
+            distribution.mean().norm(axis=1).reduce_mean() / np.sqrt(10), policy_loss
+
+    def compute_natural_grad(self, loss, mean_kl, tangents):
+        params = self.policy.parameters()
+        old_params = self.old_policy.parameters()
+        hessian_vec_prod = nn.utils.hessian_vec_prod(mean_kl, params, tangents)
+        flat_grad = nn.utils.parameters_to_vector(tf.gradients(loss, params))
+        sync_old = tf.group(*[tf.assign(old_v, new_v) for old_v, new_v in zip(old_params, params)])
+
+        return sync_old, hessian_vec_prod, flat_grad
+
+    def compute_vf(self, states, returns):
+        vf_loss = nn.MSELoss()(self.vf(states), returns).reduce_mean()
+        optimizer = tf.train.AdamOptimizer(self.vf_lr)
+        train_vf = optimizer.minimize(vf_loss)
+
+        return vf_loss, train_vf
+
+    @nn.make_method()
+    def get_vf_loss(self, states, returns) -> List[np.ndarray]: pass
+
+    @nn.make_method(fetch='sync_old')
+    def sync_old(self) -> List[np.ndarray]: pass
+
+    @nn.make_method(fetch='hessian_vec_prod')
+    def get_hessian_vec_prod(self, states, tangents, actions) -> List[np.ndarray]: pass
+
+    @nn.make_method(fetch='loss')
+    def get_loss(self, states, actions, advantages, ent_coef) -> List[np.ndarray]: pass
+
+    def train(self, ent_coef, samples, advantages, values):
+        returns = advantages + values
+        advantages = (advantages - advantages.mean()) / np.maximum(advantages.std(), 1e-8)
+        assert np.isfinite(advantages).all()
+        self.sync_old()
+        old_loss, grad, dist_std, mean_kl, dist_mean = self.get_loss(
+            samples.state, samples.action, advantages, ent_coef, fetch='loss flat_grad dist_std mean_kl dist_mean')
+
+        if np.allclose(grad, 0):
+            logger.info('Zero gradient, not updating...')
+            return
+
+        def fisher_vec_prod(x):
+            return self.get_hessian_vec_prod(samples.state, x, samples.action) + self.cg_damping * x
+
+        assert np.isfinite(grad).all()
+        nat_grad = conj_grad(fisher_vec_prod, grad, n_iters=self.n_cg_iters, verbose=False)
+
+        assert np.isfinite(nat_grad).all()
+
+        old_params = self.flatten.get_flat()
+        step_size = np.sqrt(2 * self.max_kl / nat_grad.dot(fisher_vec_prod(nat_grad)))
+
+        for _ in range(10):
+            new_params = old_params + nat_grad * step_size
+            self.flatten.set_flat(new_params)
+            loss, mean_kl = self.get_loss(samples.state, samples.action, advantages, ent_coef, fetch='loss mean_kl')
+            improve = loss - old_loss
+            if not np.isfinite([loss, mean_kl]).all():
+                logger.info('Got non-finite loss.')
+            elif mean_kl > self.max_kl * 1.5:
+                logger.info('Violated kl constraints, shrinking step... mean_kl = %.6f, max_kl = %.6f',
+                            mean_kl, self.max_kl)
+            elif improve < 0:
+                logger.info("Surrogate didn't improve, shrinking step... %.6f => %.6f", old_loss, loss)
+            else:
+                break
+            step_size *= 0.5
+        else:
+            logger.info("Couldn't find a good step.")
+            self.flatten.set_flat(old_params)
+        for param in self.policy.parameters():
+            param.invalidate()
+
+        # optimize value function
+        vf_dataset = Dataset.fromarrays([samples.state, returns],
+                                        dtype=[('state', ('f8', self.dim_state)), ('return_', 'f8')])
+        vf_loss = self.train_vf(vf_dataset)
+
+        return dist_mean, dist_std, vf_loss
+
+    def train_vf(self, dataset: Dataset):
+        for _ in range(self.n_vf_iters):
+            for subset in dataset.iterator(64):
+                self.get_vf_loss(subset.state, subset.return_, fetch='train_vf vf_loss')
+        for param in self.parameters():
+            param.invalidate()
+        vf_loss = self.get_vf_loss(dataset.state, dataset.return_, fetch='vf_loss')
+        return vf_loss
+
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/algos/__init__.py b/experiments05/ant_umaze_1234/src/slbo/algos/__init__.py
new file mode 100644
index 0000000..5c7f19c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/algos/__init__.py
@@ -0,0 +1 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
diff --git a/experiments05/ant_umaze_1234/src/slbo/dynamics_model.py b/experiments05/ant_umaze_1234/src/slbo/dynamics_model.py
new file mode 100644
index 0000000..19662ec
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/dynamics_model.py
@@ -0,0 +1,43 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import List
+import tensorflow as tf
+from lunzi import Tensor
+import lunzi.nn as nn
+from slbo.utils.normalizer import Normalizers
+from slbo.utils.multi_layer_perceptron import MultiLayerPerceptron
+
+
+class DynamicsModel(MultiLayerPerceptron):
+    op_loss: Tensor
+    op_train: Tensor
+    op_grad_norm: Tensor
+
+    def __init__(self, dim_state: int, dim_action: int, normalizers: Normalizers, hidden_sizes: List[int]):
+        initializer = tf.truncated_normal_initializer(mean=0.0, stddev=1e-5)
+
+        self.dim_state = dim_state
+        self.dim_action = dim_action
+        self.hidden_sizes = hidden_sizes
+        self.op_states = tf.placeholder(tf.float32, shape=[None, self.dim_state], name='states')
+        self.op_actions = tf.placeholder(tf.float32, shape=[None, self.dim_action], name='actions')
+        super().__init__([dim_state + dim_action, *hidden_sizes, dim_state],
+                         activation=nn.ReLU,
+                         weight_initializer=initializer, build=False)
+
+        self.normalizers = normalizers
+        self.build()
+
+    def build(self):
+        self.op_next_states = self.forward(self.op_states, self.op_actions)
+
+    def forward(self, states, actions):
+        assert actions.shape[-1] == self.dim_action
+        inputs = tf.concat([self.normalizers.state(states), actions.clip_by_value(-1., 1.)], axis=1)
+
+        normalized_diffs = super().forward(inputs)
+        next_states = states + self.normalizers.diff(normalized_diffs, inverse=True)
+        next_states = self.normalizers.state(self.normalizers.state(next_states).clip_by_value(-100, 100), inverse=True)
+        return next_states
+
+    def clone(self):
+        return DynamicsModel(self.dim_state, self.dim_action, self.normalizers, self.hidden_sizes)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/__init__.py b/experiments05/ant_umaze_1234/src/slbo/envs/__init__.py
new file mode 100644
index 0000000..7efdf01
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/__init__.py
@@ -0,0 +1,55 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+import abc
+import gym
+from slbo.utils.dataset import Dataset, gen_dtype
+from lunzi.Logger import logger
+
+
+class BaseBatchedEnv(gym.Env, abc.ABC):
+    # thought about using `@property @abc.abstractmethod` here but we don't need explicit `@property` function here.
+    n_envs: int
+
+    @abc.abstractmethod
+    def step(self, actions):
+        pass
+
+    def reset(self):
+        return self.partial_reset(range(self.n_envs))
+
+    @abc.abstractmethod
+    def partial_reset(self, indices):
+        pass
+
+    def set_state(self, state):
+        logger.warning('`set_state` is not implemented')
+
+
+class BaseModelBasedEnv(gym.Env, abc.ABC):
+    @abc.abstractmethod
+    def mb_step(self, states: np.ndarray, actions: np.ndarray, next_states: np.ndarray):
+        raise NotImplementedError
+
+    def verify(self, n=2000, eps=1e-4):
+        dataset = Dataset(gen_dtype(self, 'state action next_state reward done'), n)
+        state = self.reset()
+        for _ in range(n):
+            action = self.action_space.sample()
+            next_state, reward, done, _ = self.step(action)
+            dataset.append((state, action, next_state, reward, done))
+
+            state = next_state
+            if done:
+                state = self.reset()
+
+        rewards_, dones_ = self.mb_step(dataset.state, dataset.action, dataset.next_state)
+        diff = dataset.reward - rewards_
+        l_inf = np.abs(diff).max()
+        logger.info('rewarder difference: %.6f', l_inf)
+
+        assert np.allclose(dones_, dataset.done)
+        assert l_inf < eps
+
+    def seed(self, seed: int = None):
+        pass
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/batched_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/batched_env.py
new file mode 100644
index 0000000..cbe4bac
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/batched_env.py
@@ -0,0 +1,37 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from gym import Wrapper
+from . import BaseBatchedEnv
+
+
+class BatchedEnv(BaseBatchedEnv, Wrapper):
+    def __init__(self, envs):
+        super().__init__(envs[0])
+        self.envs = envs
+        self.n_envs = len(envs)
+
+    def step(self, actions):
+
+        buf, infos = [], []
+        for env, action in zip(self.envs, actions):
+            next_state, reward, done, info = env.step(action)
+            buf.append((next_state, reward, done))
+            infos.append(info)
+
+        return [*(np.array(x) for x in zip(*buf)), infos]
+
+    def reset(self):
+        return self.partial_reset(range(self.n_envs))
+
+    def partial_reset(self, indices):
+        states = []
+        for index in indices:
+            states.append(self.envs[index].reset())
+        return np.array(states)
+
+    def __repr__(self):
+        return f'Batch<{self.n_envs}x {self.env}>'
+
+    def set_state(self, state):
+        pass
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/__init__.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/ant.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/ant.xml
new file mode 100644
index 0000000..18ad38b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/ant.xml
@@ -0,0 +1,80 @@
+<mujoco model="ant">
+  <compiler angle="degree" coordinate="local" inertiafromgeom="true"/>
+  <option integrator="RK4" timestep="0.01"/>
+  <custom>
+    <numeric data="0.0 0.0 0.55 1.0 0.0 0.0 0.0 0.0 1.0 0.0 -1.0 0.0 -1.0 0.0 1.0" name="init_qpos"/>
+  </custom>
+  <default>
+    <joint armature="1" damping="1" limited="true"/>
+    <geom conaffinity="0" condim="3" density="5.0" friction="1 0.5 0.5" margin="0.01" rgba="0.8 0.6 0.4 1"/>
+  </default>
+  <asset>
+    <texture builtin="gradient" height="100" rgb1="1 1 1" rgb2="0 0 0" type="skybox" width="100"/>
+    <texture builtin="flat" height="1278" mark="cross" markrgb="1 1 1" name="texgeom" random="0.01" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" type="cube" width="127"/>
+    <texture builtin="checker" height="100" name="texplane" rgb1="0 0 0" rgb2="0.8 0.8 0.8" type="2d" width="100"/>
+    <material name="MatPlane" reflectance="0.5" shininess="1" specular="1" texrepeat="60 60" texture="texplane"/>
+    <material name="geom" texture="texgeom" texuniform="true"/>
+  </asset>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0 1.3" specular=".1 .1 .1"/>
+    <geom conaffinity="1" condim="3" material="MatPlane" name="floor" pos="0 0 0" rgba="0.8 0.9 0.8 1" size="40 40 40" type="plane"/>
+    <body name="torso" pos="0 0 0.75">
+      <geom name="torso_geom" pos="0 0 0" size="0.25" type="sphere"/>
+      <joint armature="0" damping="0" limited="false" margin="0.01" name="root" pos="0 0 0" type="free"/>
+      <body name="front_left_leg" pos="0 0 0">
+        <geom fromto="0.0 0.0 0.0 0.2 0.2 0.0" name="aux_1_geom" size="0.08" type="capsule"/>
+        <body name="aux_1" pos="0.2 0.2 0">
+          <joint axis="0 0 1" name="hip_1" pos="0.0 0.0 0.0" range="-30 30" type="hinge"/>
+          <geom fromto="0.0 0.0 0.0 0.2 0.2 0.0" name="left_leg_geom" size="0.08" type="capsule"/>
+          <body pos="0.2 0.2 0">
+            <joint axis="-1 1 0" name="ankle_1" pos="0.0 0.0 0.0" range="30 70" type="hinge"/>
+            <geom fromto="0.0 0.0 0.0 0.4 0.4 0.0" name="left_ankle_geom" size="0.08" type="capsule"/>
+          </body>
+        </body>
+      </body>
+      <body name="front_right_leg" pos="0 0 0">
+        <geom fromto="0.0 0.0 0.0 -0.2 0.2 0.0" name="aux_2_geom" size="0.08" type="capsule"/>
+        <body name="aux_2" pos="-0.2 0.2 0">
+          <joint axis="0 0 1" name="hip_2" pos="0.0 0.0 0.0" range="-30 30" type="hinge"/>
+          <geom fromto="0.0 0.0 0.0 -0.2 0.2 0.0" name="right_leg_geom" size="0.08" type="capsule"/>
+          <body pos="-0.2 0.2 0">
+            <joint axis="1 1 0" name="ankle_2" pos="0.0 0.0 0.0" range="-70 -30" type="hinge"/>
+            <geom fromto="0.0 0.0 0.0 -0.4 0.4 0.0" name="right_ankle_geom" size="0.08" type="capsule"/>
+          </body>
+        </body>
+      </body>
+      <body name="back_leg" pos="0 0 0">
+        <geom fromto="0.0 0.0 0.0 -0.2 -0.2 0.0" name="aux_3_geom" size="0.08" type="capsule"/>
+        <body name="aux_3" pos="-0.2 -0.2 0">
+          <joint axis="0 0 1" name="hip_3" pos="0.0 0.0 0.0" range="-30 30" type="hinge"/>
+          <geom fromto="0.0 0.0 0.0 -0.2 -0.2 0.0" name="back_leg_geom" size="0.08" type="capsule"/>
+          <body pos="-0.2 -0.2 0">
+            <joint axis="-1 1 0" name="ankle_3" pos="0.0 0.0 0.0" range="-70 -30" type="hinge"/>
+            <geom fromto="0.0 0.0 0.0 -0.4 -0.4 0.0" name="third_ankle_geom" size="0.08" type="capsule"/>
+          </body>
+        </body>
+      </body>
+      <body name="right_back_leg" pos="0 0 0">
+        <geom fromto="0.0 0.0 0.0 0.2 -0.2 0.0" name="aux_4_geom" size="0.08" type="capsule"/>
+        <body name="aux_4" pos="0.2 -0.2 0">
+          <joint axis="0 0 1" name="hip_4" pos="0.0 0.0 0.0" range="-30 30" type="hinge"/>
+          <geom fromto="0.0 0.0 0.0 0.2 -0.2 0.0" name="rightback_leg_geom" size="0.08" type="capsule"/>
+          <body pos="0.2 -0.2 0">
+            <joint axis="1 1 0" name="ankle_4" pos="0.0 0.0 0.0" range="30 70" type="hinge"/>
+            <geom fromto="0.0 0.0 0.0 0.4 -0.4 0.0" name="fourth_ankle_geom" size="0.08" type="capsule"/>
+          </body>
+        </body>
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="hip_4" gear="150"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="ankle_4" gear="150"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="hip_1" gear="150"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="ankle_1" gear="150"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="hip_2" gear="150"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="ankle_2" gear="150"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="hip_3" gear="150"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" joint="ankle_3" gear="150"/>
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/half_cheetah.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/half_cheetah.xml
new file mode 100644
index 0000000..b07aada
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/half_cheetah.xml
@@ -0,0 +1,95 @@
+<!-- Cheetah Model
+
+    The state space is populated with joints in the order that they are
+    defined in this file. The actuators also operate on joints.
+
+    State-Space (name/joint/parameter):
+        - rootx     slider      position (m)
+        - rootz     slider      position (m)
+        - rooty     hinge       angle (rad)
+        - bthigh    hinge       angle (rad)
+        - bshin     hinge       angle (rad)
+        - bfoot     hinge       angle (rad)
+        - fthigh    hinge       angle (rad)
+        - fshin     hinge       angle (rad)
+        - ffoot     hinge       angle (rad)
+        - rootx     slider      velocity (m/s)
+        - rootz     slider      velocity (m/s)
+        - rooty     hinge       angular velocity (rad/s)
+        - bthigh    hinge       angular velocity (rad/s)
+        - bshin     hinge       angular velocity (rad/s)
+        - bfoot     hinge       angular velocity (rad/s)
+        - fthigh    hinge       angular velocity (rad/s)
+        - fshin     hinge       angular velocity (rad/s)
+        - ffoot     hinge       angular velocity (rad/s)
+
+    Actuators (name/actuator/parameter):
+        - bthigh    hinge       torque (N m)
+        - bshin     hinge       torque (N m)
+        - bfoot     hinge       torque (N m)
+        - fthigh    hinge       torque (N m)
+        - fshin     hinge       torque (N m)
+        - ffoot     hinge       torque (N m)
+
+-->
+<mujoco model="cheetah">
+  <compiler angle="radian" coordinate="local" inertiafromgeom="true" settotalmass="14"/>
+  <default>
+    <joint armature=".1" damping=".01" limited="true" solimplimit="0 .8 .03" solreflimit=".02 1" stiffness="8"/>
+    <geom conaffinity="0" condim="3" contype="1" friction=".4 .1 .1" rgba="0.8 0.6 .4 1" solimp="0.0 0.8 0.01" solref="0.02 1"/>
+    <motor ctrllimited="true" ctrlrange="-1 1"/>
+  </default>
+  <size nstack="300000" nuser_geom="1"/>
+  <option gravity="0 0 -9.81" timestep="0.01"/>
+  <asset>
+    <texture builtin="gradient" height="100" rgb1="1 1 1" rgb2="0 0 0" type="skybox" width="100"/>
+    <texture builtin="flat" height="1278" mark="cross" markrgb="1 1 1" name="texgeom" random="0.01" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" type="cube" width="127"/>
+    <texture builtin="checker" height="100" name="texplane" rgb1="0 0 0" rgb2="0.8 0.8 0.8" type="2d" width="100"/>
+    <material name="MatPlane" reflectance="0.5" shininess="1" specular="1" texrepeat="60 60" texture="texplane"/>
+    <material name="geom" texture="texgeom" texuniform="true"/>
+  </asset>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0 1.3" specular=".1 .1 .1"/>
+    <geom conaffinity="1" condim="3" material="MatPlane" name="floor" pos="0 0 0" rgba="0.8 0.9 0.8 1" size="40 40 40" type="plane"/>
+    <body name="torso" pos="0 0 .7">
+      <joint armature="0" axis="1 0 0" damping="0" limited="false" name="rootx" pos="0 0 0" stiffness="0" type="slide"/>
+      <joint armature="0" axis="0 0 1" damping="0" limited="false" name="rootz" pos="0 0 0" stiffness="0" type="slide"/>
+      <joint armature="0" axis="0 1 0" damping="0" limited="false" name="rooty" pos="0 0 0" stiffness="0" type="hinge"/>
+      <geom fromto="-.5 0 0 .5 0 0" name="torso" size="0.046" type="capsule"/>
+      <geom axisangle="0 1 0 .87" name="head" pos=".6 0 .1" size="0.046 .15" type="capsule"/>
+      <!-- <site name='tip'  pos='.15 0 .11'/>-->
+      <body name="bthigh" pos="-.5 0 0">
+        <joint axis="0 1 0" damping="6" name="bthigh" pos="0 0 0" range="-.52 1.05" stiffness="240" type="hinge"/>
+        <geom axisangle="0 1 0 -3.8" name="bthigh" pos=".1 0 -.13" size="0.046 .145" type="capsule"/>
+        <body name="bshin" pos=".16 0 -.25">
+          <joint axis="0 1 0" damping="4.5" name="bshin" pos="0 0 0" range="-.785 .785" stiffness="180" type="hinge"/>
+          <geom axisangle="0 1 0 -2.03" name="bshin" pos="-.14 0 -.07" rgba="0.9 0.6 0.6 1" size="0.046 .15" type="capsule"/>
+          <body name="bfoot" pos="-.28 0 -.14">
+            <joint axis="0 1 0" damping="3" name="bfoot" pos="0 0 0" range="-.4 .785" stiffness="120" type="hinge"/>
+            <geom axisangle="0 1 0 -.27" name="bfoot" pos=".03 0 -.097" rgba="0.9 0.6 0.6 1" size="0.046 .094" type="capsule"/>
+          </body>
+        </body>
+      </body>
+      <body name="fthigh" pos=".5 0 0">
+        <joint axis="0 1 0" damping="4.5" name="fthigh" pos="0 0 0" range="-1 .7" stiffness="180" type="hinge"/>
+        <geom axisangle="0 1 0 .52" name="fthigh" pos="-.07 0 -.12" size="0.046 .133" type="capsule"/>
+        <body name="fshin" pos="-.14 0 -.24">
+          <joint axis="0 1 0" damping="3" name="fshin" pos="0 0 0" range="-1.2 .87" stiffness="120" type="hinge"/>
+          <geom axisangle="0 1 0 -.6" name="fshin" pos=".065 0 -.09" rgba="0.9 0.6 0.6 1" size="0.046 .106" type="capsule"/>
+          <body name="ffoot" pos=".13 0 -.18">
+            <joint axis="0 1 0" damping="1.5" name="ffoot" pos="0 0 0" range="-.5 .5" stiffness="60" type="hinge"/>
+            <geom axisangle="0 1 0 -.6" name="ffoot" pos=".045 0 -.07" rgba="0.9 0.6 0.6 1" size="0.046 .07" type="capsule"/>
+          </body>
+        </body>
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor gear="120" joint="bthigh" name="bthigh"/>
+    <motor gear="90" joint="bshin" name="bshin"/>
+    <motor gear="60" joint="bfoot" name="bfoot"/>
+    <motor gear="120" joint="fthigh" name="fthigh"/>
+    <motor gear="60" joint="fshin" name="fshin"/>
+    <motor gear="30" joint="ffoot" name="ffoot"/>
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/hopper.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/hopper.xml
new file mode 100644
index 0000000..b0ebc0e
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/hopper.xml
@@ -0,0 +1,44 @@
+<mujoco model="hopper">
+  <compiler angle="degree" coordinate="global" inertiafromgeom="true"/>
+  <default>
+    <joint armature="1" damping="1" limited="true"/>
+    <geom conaffinity="1" condim="1" contype="1" margin="0.001" material="geom" rgba="0.8 0.6 .4 1" solimp=".8 .8 .01" solref=".02 1"/>
+    <motor ctrllimited="true" ctrlrange="-.4 .4"/>
+  </default>
+  <option integrator="RK4" timestep="0.002"/>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0 1.3" specular=".1 .1 .1"/>
+    <geom conaffinity="1" condim="3" name="floor" pos="0 0 0" rgba="0.8 0.9 0.8 1" size="20 20 .125" type="plane" material="MatPlane"/>
+    <body name="torso" pos="0 0 1.25">
+      <joint armature="0" axis="1 0 0" damping="0" limited="false" name="rootx" pos="0 0 0" stiffness="0" type="slide"/>
+      <joint armature="0" axis="0 0 1" damping="0" limited="false" name="rootz" pos="0 0 0" ref="1.25" stiffness="0" type="slide"/>
+      <joint armature="0" axis="0 1 0" damping="0" limited="false" name="rooty" pos="0 0 1.25" stiffness="0" type="hinge"/>
+      <geom friction="0.9" fromto="0 0 1.45 0 0 1.05" name="torso_geom" size="0.05" type="capsule"/>
+      <body name="thigh" pos="0 0 1.05">
+        <joint axis="0 -1 0" name="thigh_joint" pos="0 0 1.05" range="-150 0" type="hinge"/>
+        <geom friction="0.9" fromto="0 0 1.05 0 0 0.6" name="thigh_geom" size="0.05" type="capsule"/>
+        <body name="leg" pos="0 0 0.35">
+          <joint axis="0 -1 0" name="leg_joint" pos="0 0 0.6" range="-150 0" type="hinge"/>
+          <geom friction="0.9" fromto="0 0 0.6 0 0 0.1" name="leg_geom" size="0.04" type="capsule"/>
+          <body name="foot" pos="0.13/2 0 0.1">
+            <joint axis="0 -1 0" name="foot_joint" pos="0 0 0.1" range="-45 45" type="hinge"/>
+            <geom friction="2.0" fromto="-0.13 0 0.1 0.26 0 0.1" name="foot_geom" size="0.06" type="capsule"/>
+          </body>
+        </body>
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="200.0" joint="thigh_joint"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="200.0" joint="leg_joint"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="200.0" joint="foot_joint"/>
+  </actuator>
+    <asset>
+        <texture type="skybox" builtin="gradient" rgb1=".4 .5 .6" rgb2="0 0 0"
+            width="100" height="100"/>        
+        <texture builtin="flat" height="1278" mark="cross" markrgb="1 1 1" name="texgeom" random="0.01" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" type="cube" width="127"/>
+        <texture builtin="checker" height="100" name="texplane" rgb1="0 0 0" rgb2="0.8 0.8 0.8" type="2d" width="100"/>
+        <material name="MatPlane" reflectance="0.5" shininess="1" specular="1" texrepeat="60 60" texture="texplane"/>
+        <material name="geom" texture="texgeom" texuniform="true"/>
+    </asset>
+</mujoco>
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/point.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/point.xml
new file mode 100644
index 0000000..e35ef3d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/point.xml
@@ -0,0 +1,31 @@
+<mujoco>
+  <compiler angle="degree" coordinate="local" inertiafromgeom="true"/>
+  <option integrator="RK4" timestep="0.02"/>
+  <default>
+    <joint armature="0" damping="0" limited="false"/>
+    <geom conaffinity="0" condim="3" density="100" friction="1 0.5 0.5" margin="0" rgba="0.8 0.6 0.4 1"/>
+  </default>
+  <asset>
+    <texture builtin="gradient" height="100" rgb1="1 1 1" rgb2="0 0 0" type="skybox" width="100"/>
+    <texture builtin="flat" height="1278" mark="cross" markrgb="1 1 1" name="texgeom" random="0.01" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" type="cube" width="127"/>
+    <texture builtin="checker" height="100" name="texplane" rgb1="0 0 0" rgb2="0.8 0.8 0.8" type="2d" width="100"/>
+    <material name="MatPlane" reflectance="0.5" shininess="1" specular="1" texrepeat="30 30" texture="texplane"/>
+    <material name="geom" texture="texgeom" texuniform="true"/>
+  </asset>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0 1.3" specular=".1 .1 .1"/>
+    <geom conaffinity="1" condim="3" material="MatPlane" name="floor" pos="0 0 0" rgba="0.8 0.9 0.8 1" size="40 40 40" type="plane"/>
+    <body name="torso" pos="0 0 0">
+      <geom name="pointbody" pos="0 0 0.5" size="0.5" type="sphere"/>
+      <geom name="pointarrow" pos="0.6 0 0.5" size="0.5 0.1 0.1" type="box"/>
+      <joint axis="1 0 0" name="ballx" pos="0 0 0" type="slide"/>
+      <joint axis="0 1 0" name="bally" pos="0 0 0" type="slide"/>
+      <joint axis="0 0 1" limited="false" name="rot" pos="0 0 0" type="hinge"/>
+    </body>
+  </worldbody>
+  <actuator>
+    <!-- Those are just dummy actuators for providing ranges -->
+    <motor ctrllimited="true" ctrlrange="-1 1" joint="ballx"/>
+    <motor ctrllimited="true" ctrlrange="-0.25 0.25" joint="rot"/>
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/pusher.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/pusher.xml
new file mode 100644
index 0000000..31a5ef7
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/pusher.xml
@@ -0,0 +1,91 @@
+<mujoco model="arm3d">
+  <compiler inertiafromgeom="true" angle="radian" coordinate="local"/>
+  <option timestep="0.01" gravity="0 0 0" iterations="20" integrator="Euler" />
+  
+  <default>
+    <joint armature='0.04' damping="1" limited="true"/>
+    <geom friction=".8 .1 .1" density="300" margin="0.002" condim="1" contype="0" conaffinity="0"/>
+  </default>
+  
+  <worldbody>
+    <light diffuse=".5 .5 .5" pos="0 0 3" dir="0 0 -1"/>
+    <geom name="table" type="plane" pos="0 0.5 -0.325" size="1 1 0.1" contype="1" conaffinity="1"/>
+
+    <body name="r_shoulder_pan_link" pos="0 -0.6 0">
+      <geom name="e1" type="sphere" rgba="0.6 0.6 0.6 1" pos="-0.06 0.05 0.2" size="0.05" />
+      <geom name="e2" type="sphere" rgba="0.6 0.6 0.6 1" pos=" 0.06 0.05 0.2" size="0.05" />
+      <geom name="e1p" type="sphere" rgba="0.1 0.1 0.1 1" pos="-0.06 0.09 0.2" size="0.03" />
+      <geom name="e2p" type="sphere" rgba="0.1 0.1 0.1 1" pos=" 0.06 0.09 0.2" size="0.03" />
+      <geom name="sp" type="capsule" fromto="0 0 -0.4 0 0 0.2" size="0.1" />
+      <joint name="r_shoulder_pan_joint" type="hinge" pos="0 0 0" axis="0 0 1" range="-2.2854 1.714602" damping="1.0" />
+
+      <body name="r_shoulder_lift_link" pos="0.1 0 0">
+        <geom name="sl" type="capsule" fromto="0 -0.1 0 0 0.1 0" size="0.1" />
+        <joint name="r_shoulder_lift_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.5236 1.3963" damping="1.0" />
+
+        <body name="r_upper_arm_roll_link" pos="0 0 0">
+          <geom name="uar" type="capsule" fromto="-0.1 0 0 0.1 0 0" size="0.02" />
+          <joint name="r_upper_arm_roll_joint" type="hinge" pos="0 0 0" axis="1 0 0" range="-1.5 1.7" damping="0.1" />
+
+          <body name="r_upper_arm_link" pos="0 0 0">
+            <geom name="ua" type="capsule" fromto="0 0 0 0.4 0 0" size="0.06" />
+
+            <body name="r_elbow_flex_link" pos="0.4 0 0">
+              <geom name="ef" type="capsule" fromto="0 -0.02 0 0.0 0.02 0" size="0.06" />
+              <joint name="r_elbow_flex_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-2.3213 0" damping="0.1" />
+
+              <body name="r_forearm_roll_link" pos="0 0 0">
+                <geom name="fr" type="capsule" fromto="-0.1 0 0 0.1 0 0" size="0.02" />
+                <joint name="r_forearm_roll_joint" type="hinge" limited="true" pos="0 0 0" axis="1 0 0" damping=".1" range="-1.5 1.5"/>
+
+                <body name="r_forearm_link" pos="0 0 0">
+                  <geom name="fa" type="capsule" fromto="0 0 0 0.291 0 0" size="0.05" />
+
+                  <body name="r_wrist_flex_link" pos="0.321 0 0">
+                    <geom name="wf" type="capsule" fromto="0 -0.02 0 0 0.02 0" size="0.01" />
+                    <joint name="r_wrist_flex_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-1.094 0" damping=".1" />
+
+                    <body name="r_wrist_roll_link" pos="0 0 0">
+                      <joint name="r_wrist_roll_joint" type="hinge" pos="0 0 0" limited="true" axis="1 0 0" damping="0.1" range="-1.5 1.5"/>
+                      <body name="tips_arm" pos="0 0 0">
+                        <geom name="tip_arml" type="sphere" pos="0.1 -0.1 0." size="0.01" />
+                        <geom name="tip_armr" type="sphere" pos="0.1 0.1 0." size="0.01" />
+                      </body>
+                      <geom type="capsule" fromto="0 -0.1 0. 0.0 +0.1 0" size="0.02" contype="1" conaffinity="1" />
+                      <geom type="capsule" fromto="0 -0.1 0. 0.1 -0.1 0" size="0.02" contype="1" conaffinity="1" />
+                      <geom type="capsule" fromto="0 +0.1 0. 0.1 +0.1 0." size="0.02" contype="1" conaffinity="1" />
+                    </body>
+                  </body>
+                </body>
+              </body>
+            </body>
+          </body>
+        </body>
+      </body>
+    </body>
+
+    <!--<body name="object" pos="0.55 -0.3 -0.275" >-->
+    <body name="object" pos="0.45 -0.05 -0.275" >
+      <geom rgba="1 1 1 0" type="sphere" size="0.05 0.05 0.05" density="0.00001" conaffinity="0"/>
+      <geom rgba="1 1 1 1" type="cylinder" size="0.05 0.05 0.05" density="0.00001" contype="1" conaffinity="0"/>
+      <joint name="obj_slidey" type="slide" pos="0 0 0" axis="0 1 0" range="-10.3213 10.3" damping="0.5"/>
+      <joint name="obj_slidex" type="slide" pos="0 0 0" axis="1 0 0" range="-10.3213 10.3" damping="0.5"/>
+    </body>
+
+    <body name="goal" pos="0.45 -0.05 -0.3230">
+      <geom rgba="1 0 0 1" type="cylinder" size="0.08 0.001 0.1" density='0.00001' contype="0" conaffinity="0"/>
+      <joint name="goal_slidey" type="slide" pos="0 0 0" axis="0 1 0" range="-10.3213 10.3" damping="0.5"/>
+      <joint name="goal_slidex" type="slide" pos="0 0 0" axis="1 0 0" range="-10.3213 10.3" damping="0.5"/> 
+    </body>
+  </worldbody>
+
+  <actuator>
+    <motor joint="r_shoulder_pan_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_shoulder_lift_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_upper_arm_roll_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_elbow_flex_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_forearm_roll_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_wrist_flex_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_wrist_roll_joint" ctrlrange="-2.0 2.0" ctrllimited="true"/>
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/reacher.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/reacher.xml
new file mode 100644
index 0000000..64a67b9
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/reacher.xml
@@ -0,0 +1,39 @@
+<mujoco model="reacher">
+	<compiler angle="radian" inertiafromgeom="true"/>
+	<default>
+		<joint armature="1" damping="1" limited="true"/>
+		<geom contype="0" friction="1 0.1 0.1" rgba="0.7 0.7 0 1"/>
+	</default>
+	<option gravity="0 0 -9.81" integrator="RK4" timestep="0.01"/>
+	<worldbody>
+		<!-- Arena -->
+		<geom conaffinity="0" contype="0" name="ground" pos="0 0 0" rgba="0.9 0.9 0.9 1" size="1 1 10" type="plane"/>
+		<geom conaffinity="0" fromto="-.3 -.3 .01 .3 -.3 .01" name="sideS" rgba="0.9 0.4 0.6 1" size=".02" type="capsule"/>
+		<geom conaffinity="0" fromto=" .3 -.3 .01 .3  .3 .01" name="sideE" rgba="0.9 0.4 0.6 1" size=".02" type="capsule"/>
+		<geom conaffinity="0" fromto="-.3  .3 .01 .3  .3 .01" name="sideN" rgba="0.9 0.4 0.6 1" size=".02" type="capsule"/>
+		<geom conaffinity="0" fromto="-.3 -.3 .01 -.3 .3 .01" name="sideW" rgba="0.9 0.4 0.6 1" size=".02" type="capsule"/>
+		<!-- Arm -->
+		<geom conaffinity="0" contype="0" fromto="0 0 0 0 0 0.02" name="root" rgba="0.9 0.4 0.6 1" size=".011" type="cylinder"/>
+		<body name="body0" pos="0 0 .01">
+			<geom fromto="0 0 0 0.1 0 0" name="link0" rgba="0.0 0.4 0.6 1" size=".01" type="capsule"/>
+			<joint axis="0 0 1" limited="false" name="joint0" pos="0 0 0" type="hinge"/>
+			<body name="body1" pos="0.1 0 0">
+				<joint axis="0 0 1" limited="true" name="joint1" pos="0 0 0" range="-3.0 3.0" type="hinge"/>
+				<geom fromto="0 0 0 0.1 0 0" name="link1" rgba="0.0 0.4 0.6 1" size=".01" type="capsule"/>
+				<body name="fingertip" pos="0.11 0 0">
+					<geom contype="0" name="fingertip" pos="0 0 0" rgba="0.0 0.8 0.6 1" size=".01" type="sphere"/>
+				</body>
+			</body>
+		</body>
+		<!-- Target -->
+		<body name="target" pos=".1 -.1 .01">
+			<joint armature="0" axis="1 0 0" damping="0" limited="true" name="target_x" pos="0 0 0" range="-.27 .27" ref=".1" stiffness="0" type="slide"/>
+			<joint armature="0" axis="0 1 0" damping="0" limited="true" name="target_y" pos="0 0 0" range="-.27 .27" ref="-.1" stiffness="0" type="slide"/>
+			<geom conaffinity="0" contype="0" name="target" pos="0 0 0" rgba="0.9 0.2 0.2 1" size=".009" type="sphere"/>
+		</body>
+	</worldbody>
+	<actuator>
+		<motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="200.0" joint="joint0"/>
+		<motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="200.0" joint="joint1"/>
+	</actuator>
+</mujoco>
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/swimmer.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/swimmer.xml
new file mode 100644
index 0000000..cda25da
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/swimmer.xml
@@ -0,0 +1,38 @@
+<mujoco model="swimmer">
+  <compiler angle="degree" coordinate="local" inertiafromgeom="true"/>
+  <option collision="predefined" density="4000" integrator="RK4" timestep="0.01" viscosity="0.1"/>
+  <default>
+    <geom conaffinity="1" condim="1" contype="1" material="geom" rgba="0.8 0.6 .4 1"/>
+    <joint armature='0.1'  />
+  </default>
+  <asset>
+    <texture builtin="gradient" height="100" rgb1="1 1 1" rgb2="0 0 0" type="skybox" width="100"/>
+    <texture builtin="flat" height="1278" mark="cross" markrgb="1 1 1" name="texgeom" random="0.01" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" type="cube" width="127"/>
+    <texture builtin="checker" height="100" name="texplane" rgb1="0 0 0" rgb2="0.8 0.8 0.8" type="2d" width="100"/>
+    <material name="MatPlane" reflectance="0.5" shininess="1" specular="1" texrepeat="30 30" texture="texplane"/>
+    <material name="geom" texture="texgeom" texuniform="true"/>
+  </asset>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0 1.3" specular=".1 .1 .1"/>
+    <geom conaffinity="1" condim="3" material="MatPlane" name="floor" pos="0 0 -0.1" rgba="0.8 0.9 0.8 1" size="40 40 0.1" type="plane"/>
+    <!--  ================= SWIMMER ================= /-->
+    <body name="torso" pos="0 0 0">
+      <geom density="1000" fromto="1.5 0 0 0.5 0 0" size="0.1" type="capsule"/>
+      <joint axis="1 0 0" name="slider1" pos="0 0 0" type="slide"/>
+      <joint axis="0 1 0" name="slider2" pos="0 0 0" type="slide"/>
+      <joint axis="0 0 1" name="rot" pos="0 0 0" type="hinge"/>
+      <body name="mid" pos="0.5 0 0">
+        <geom density="1000" fromto="0 0 0 -1 0 0" size="0.1" type="capsule"/>
+        <joint axis="0 0 1" limited="true" name="rot2" pos="0 0 0" range="-100 100" type="hinge"/>
+        <body name="back" pos="-1 0 0">
+          <geom density="1000" fromto="0 0 0 -1 0 0" size="0.1" type="capsule"/>
+          <joint axis="0 0 1" limited="true" name="rot3" pos="0 0 0" range="-100 100" type="hinge"/>
+        </body>
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor ctrllimited="true" ctrlrange="-1 1" gear="150.0" joint="rot2"/>
+    <motor ctrllimited="true" ctrlrange="-1 1" gear="150.0" joint="rot3"/>
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/walker2d.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/walker2d.xml
new file mode 100644
index 0000000..cbc074d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/assets/walker2d.xml
@@ -0,0 +1,61 @@
+<mujoco model="walker2d">
+  <compiler angle="degree" coordinate="global" inertiafromgeom="true"/>
+  <default>
+    <joint armature="0.01" damping=".1" limited="true"/>
+    <geom conaffinity="0" condim="3" contype="1" density="1000" friction=".7 .1 .1" rgba="0.8 0.6 .4 1"/>
+  </default>
+  <option integrator="RK4" timestep="0.002"/>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0 1.3" specular=".1 .1 .1"/>
+    <geom conaffinity="1" condim="3" name="floor" pos="0 0 0" rgba="0.8 0.9 0.8 1" size="40 40 40" type="plane" material="MatPlane"/>
+    <body name="torso" pos="0 0 1.25">
+      <joint armature="0" axis="1 0 0" damping="0" limited="false" name="rootx" pos="0 0 0" stiffness="0" type="slide"/>
+      <joint armature="0" axis="0 0 1" damping="0" limited="false" name="rootz" pos="0 0 0" ref="1.25" stiffness="0" type="slide"/>
+      <joint armature="0" axis="0 1 0" damping="0" limited="false" name="rooty" pos="0 0 1.25" stiffness="0" type="hinge"/>
+      <geom friction="0.9" fromto="0 0 1.45 0 0 1.05" name="torso_geom" size="0.05" type="capsule"/>
+      <body name="thigh" pos="0 0 1.05">
+        <joint axis="0 -1 0" name="thigh_joint" pos="0 0 1.05" range="-150 0" type="hinge"/>
+        <geom friction="0.9" fromto="0 0 1.05 0 0 0.6" name="thigh_geom" size="0.05" type="capsule"/>
+        <body name="leg" pos="0 0 0.35">
+          <joint axis="0 -1 0" name="leg_joint" pos="0 0 0.6" range="-150 0" type="hinge"/>
+          <geom friction="0.9" fromto="0 0 0.6 0 0 0.1" name="leg_geom" size="0.04" type="capsule"/>
+          <body name="foot" pos="0.2/2 0 0.1">
+            <joint axis="0 -1 0" name="foot_joint" pos="0 0 0.1" range="-45 45" type="hinge"/>
+            <geom friction="0.9" fromto="-0.0 0 0.1 0.2 0 0.1" name="foot_geom" size="0.06" type="capsule"/>
+          </body>
+        </body>
+      </body>
+      <!-- copied and then replace thigh->thigh_left, leg->leg_left, foot->foot_right -->
+      <body name="thigh_left" pos="0 0 1.05">
+        <joint axis="0 -1 0" name="thigh_left_joint" pos="0 0 1.05" range="-150 0" type="hinge"/>
+        <geom friction="0.9" fromto="0 0 1.05 0 0 0.6" name="thigh_left_geom" rgba=".7 .3 .6 1" size="0.05" type="capsule"/>
+        <body name="leg_left" pos="0 0 0.35">
+          <joint axis="0 -1 0" name="leg_left_joint" pos="0 0 0.6" range="-150 0" type="hinge"/>
+          <geom friction="0.9" fromto="0 0 0.6 0 0 0.1" name="leg_left_geom" rgba=".7 .3 .6 1" size="0.04" type="capsule"/>
+          <body name="foot_left" pos="0.2/2 0 0.1">
+            <joint axis="0 -1 0" name="foot_left_joint" pos="0 0 0.1" range="-45 45" type="hinge"/>
+            <geom friction="1.9" fromto="-0.0 0 0.1 0.2 0 0.1" name="foot_left_geom" rgba=".7 .3 .6 1" size="0.06" type="capsule"/>
+          </body>
+        </body>
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <!-- <motor joint="torso_joint" ctrlrange="-100.0 100.0" isctrllimited="true"/>-->
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="100" joint="thigh_joint"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="100" joint="leg_joint"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="100" joint="foot_joint"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="100" joint="thigh_left_joint"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="100" joint="leg_left_joint"/>
+    <motor ctrllimited="true" ctrlrange="-1.0 1.0" gear="100" joint="foot_left_joint"/>
+    <!-- <motor joint="finger2_rot" ctrlrange="-20.0 20.0" isctrllimited="true"/>-->
+  </actuator>
+    <asset>
+        <texture type="skybox" builtin="gradient" rgb1=".4 .5 .6" rgb2="0 0 0"
+            width="100" height="100"/>        
+        <texture builtin="flat" height="1278" mark="cross" markrgb="1 1 1" name="texgeom" random="0.01" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" type="cube" width="127"/>
+        <texture builtin="checker" height="100" name="texplane" rgb1="0 0 0" rgb2="0.8 0.8 0.8" type="2d" width="100"/>
+        <material name="MatPlane" reflectance="0.5" shininess="1" specular="1" texrepeat="60 60" texture="texplane"/>
+        <material name="geom" texture="texgeom" texuniform="true"/>
+    </asset>
+</mujoco>
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/__init__.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/__init__.py
new file mode 100644
index 0000000..eff23c0
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/__init__.py
@@ -0,0 +1,210 @@
+from gym.envs.registration import register
+
+register(
+    id='MBRLHalfCheetah-v0',
+    entry_point='envs.gym.half_cheetah:HalfCheetahEnv',
+    kwargs={'frame_skip': 5},
+    max_episode_steps=1000,
+)
+
+register(
+    id='MBRLWalker2d-v0',
+    entry_point='envs.gym.walker2d:Walker2dEnv',
+    kwargs={'frame_skip': 4},
+    max_episode_steps=1000,
+)
+
+register(
+    id='MBRLSwimmer-v0',
+    entry_point='envs.gym.swimmer:SwimmerEnv',
+    kwargs={'frame_skip': 4},
+    max_episode_steps=1000,
+)
+
+register(
+    id='MBRLAnt-v0',
+    entry_point='envs.gym.ant:AntEnv',
+    kwargs={'frame_skip': 5},
+    max_episode_steps=1000,
+)
+
+register(
+    id='MBRLHopper-v0',
+    entry_point='envs.gym.hopper:HopperEnv',
+    kwargs={'frame_skip': 4},
+    max_episode_steps=1000,
+)
+
+register(
+    id='MBRLReacher-v0',
+    entry_point='envs.gym.reacher:ReacherEnv',
+    max_episode_steps=50,
+)
+
+
+# second batch of environments
+
+register(
+    id='MBRLInvertedPendulum-v0',
+    entry_point='envs.gym.inverted_pendulum:InvertedPendulumEnv',
+    max_episode_steps=100,
+)
+register(
+    id='MBRLAcrobot-v0',
+    entry_point='envs.gym.acrobot:AcrobotEnv',
+    max_episode_steps=200,
+)
+register(
+    id='MBRLCartpole-v0',
+    entry_point='envs.gym.cartpole:CartPoleEnv',
+    max_episode_steps=200,
+
+)
+register(
+    id='MBRLMountain-v0',
+    entry_point='envs.gym.mountain_car:Continuous_MountainCarEnv',
+    max_episode_steps=200,
+
+)
+register(
+    id='MBRLPendulum-v0',
+    entry_point='envs.gym.pendulum:PendulumEnv',
+    max_episode_steps=200,
+)
+
+register(
+    id='gym_petsPusher-v0',
+    entry_point='envs.gym.pets_pusher:PusherEnv',
+    max_episode_steps=150,
+)
+register(
+    id='gym_petsReacher-v0',
+    entry_point='envs.gym.pets_reacher:Reacher3DEnv',
+    max_episode_steps=150,
+)
+register(
+    id='gym_petsCheetah-v0',
+    entry_point='envs.gym.pets_cheetah:HalfCheetahEnv',
+    max_episode_steps=1000,
+)
+
+# noisy env
+register(
+    id='gym_cheetahO01-v0',
+    entry_point='envs.gym.gym_cheetahO01:HalfCheetahEnv',
+    max_episode_steps=1000,
+)
+register(
+    id='gym_cheetahO001-v0',
+    entry_point='envs.gym.gym_cheetahO001:HalfCheetahEnv',
+    max_episode_steps=1000,
+)
+register(
+    id='gym_cheetahA01-v0',
+    entry_point='envs.gym.gym_cheetahA01:HalfCheetahEnv',
+    max_episode_steps=1000,
+)
+register(
+    id='gym_cheetahA003-v0',
+    entry_point='envs.gym.gym_cheetahA003:HalfCheetahEnv',
+    max_episode_steps=1000,
+)
+register(
+    id='gym_pendulumO01-v0',
+    entry_point='envs.gym.gym_pendulumO01:PendulumEnv',
+    max_episode_steps=200,
+)
+register(
+    id='gym_pendulumO001-v0',
+    entry_point='envs.gym.gym_pendulumO001:PendulumEnv',
+    max_episode_steps=200,
+)
+register(
+    id='gym_cartpoleO01-v0',
+    entry_point='envs.gym.gym_cartpoleO01:CartPoleEnv',
+    max_episode_steps=200,
+)
+register(
+    id='gym_cartpoleO001-v0',
+    entry_point='envs.gym.gym_cartpoleO001:CartPoleEnv',
+    max_episode_steps=200,
+)
+
+register(
+    id='gym_fant-v0',
+    entry_point='envs.gym.gym_fant:AntEnv',
+    max_episode_steps=1000,
+)
+register(
+    id='gym_fhopper-v0',
+    entry_point='envs.gym.gym_fhopper:HopperEnv',
+    max_episode_steps=1000,
+)
+register(
+    id='gym_fwalker2d-v0',
+    entry_point='envs.gym.gym_fwalker2d:Walker2dEnv',
+    max_episode_steps=1000,
+)
+register(
+    id='gym_fswimmer-v0',
+    entry_point='envs.gym.gym_fswimmer:fixedSwimmerEnv',
+    max_episode_steps=1000,
+)
+register(
+    id="gym_humanoid-v0",
+    entry_point='envs.gym.gym_humanoid:HumanoidEnv',
+    max_episode_steps=1000,
+)
+register(
+    id="gym_slimhumanoid-v0",
+    entry_point='envs.gym.gym_slimhumanoid:HumanoidEnv',
+    max_episode_steps=1000,
+)
+register(
+    id="gym_nostopslimhumanoid-v0",
+    entry_point='envs.gym.gym_nostopslimhumanoid:HumanoidEnv',
+    max_episode_steps=1000,
+)
+
+env_name_to_gym_registry = {
+    # first batch
+    "half_cheetah": "MBRLHalfCheetah-v0",
+    "swimmer": "MBRLSwimmer-v0",
+    "ant": "MBRLAnt-v0",
+    "hopper": "MBRLHopper-v0",
+    "reacher": "MBRLReacher-v0",
+    "walker2d": "MBRLWalker2d-v0",
+
+    # second batch
+    "invertedPendulum": "MBRLInvertedPendulum-v0",
+    "acrobot": 'MBRLAcrobot-v0',
+    "cartpole": 'MBRLCartpole-v0',
+    "mountain": 'MBRLMountain-v0',
+    "pendulum": 'MBRLPendulum-v0',
+
+    # the pets env
+    "gym_petsPusher": "gym_petsPusher-v0",
+    "gym_petsReacher": "gym_petsReacher-v0",
+    "gym_petsCheetah": "gym_petsCheetah-v0",
+
+    # the noise env
+    "gym_cheetahO01": "gym_cheetahO01-v0",
+    "gym_cheetahO001": "gym_cheetahO001-v0",
+    "gym_cheetahA01": "gym_cheetahA01-v0",
+    "gym_cheetahA003": "gym_cheetahA003-v0",
+
+    "gym_pendulumO01": "gym_pendulumO01-v0",
+    "gym_pendulumO001": "gym_pendulumO001-v0",
+
+    "gym_cartpoleO01": "gym_cartpoleO01-v0",
+    "gym_cartpoleO001": "gym_cartpoleO001-v0",
+
+    "gym_fant": "gym_fant-v0",
+    "gym_fswimmer": "gym_fswimmer-v0",
+    "gym_fhopper": "gym_fhopper-v0",
+    "gym_fwalker2d": "gym_fwalker2d-v0",
+
+    "gym_humanoid": "gym_humanoid-v0",
+    "gym_slimhumanoid": "gym_slimhumanoid-v0",
+    "gym_nostopslimhumanoid": "gym_nostopslimhumanoid-v0",
+}
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/acrobot.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/acrobot.py
new file mode 100644
index 0000000..1af57a6
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/acrobot.py
@@ -0,0 +1,357 @@
+"""classic Acrobot task"""
+from gym import core, spaces
+from gym.utils import seeding
+import numpy as np
+from numpy import sin, cos, pi
+from slbo.utils.dataset import Dataset, gen_dtype
+from lunzi.Logger import logger
+
+
+__copyright__ = "Copyright 2013, RLPy http://acl.mit.edu/RLPy"
+__credits__ = ["Alborz Geramifard", "Robert H. Klein", "Christoph Dann",
+               "William Dabney", "Jonathan P. How"]
+__license__ = "BSD 3-Clause"
+__author__ = "Christoph Dann <cdann@cdann.de>"
+
+# SOURCE:
+# https://github.com/rlpy/rlpy/blob/master/rlpy/Domains/Acrobot.py
+
+
+class AcrobotEnv(core.Env):
+
+    """
+    Acrobot is a 2-link pendulum with only the second joint actuated
+    Intitially, both links point downwards. The goal is to swing the
+    end-effector at a height at least the length of one link above the base.
+    Both links can swing freely and can pass by each other, i.e., they don't
+    collide when they have the same angle.
+    **STATE:**
+    The state consists of the two rotational joint angles and their velocities
+    [theta1 theta2 thetaDot1 thetaDot2]. An angle of 0 corresponds to corresponds
+    to the respective link pointing downwards (angles are in world coordinates).
+    **ACTIONS:**
+    The action is either applying +1, 0 or -1 torque on the joint between
+    the two pendulum links.
+    .. note::
+        The dynamics equations were missing some terms in the NIPS paper which
+        are present in the book. R. Sutton confirmed in personal correspondance
+        that the experimental results shown in the paper and the book were
+        generated with the equations shown in the book.
+        However, there is the option to run the domain with the paper equations
+        by setting book_or_nips = 'nips'
+    **REFERENCE:**
+    .. seealso::
+        R. Sutton: Generalization in Reinforcement Learning:
+        Successful Examples Using Sparse Coarse Coding (NIPS 1996)
+    .. seealso::
+        R. Sutton and A. G. Barto:
+        Reinforcement learning: An introduction.
+        Cambridge: MIT press, 1998.
+    .. warning::
+        This version of the domain uses the Runge-Kutta method for integrating
+        the system dynamics and is more realistic, but also considerably harder
+        than the original version which employs Euler integration,
+        see the AcrobotLegacy class.
+    """
+
+    metadata = {
+        'render.modes': ['human', 'rgb_array'],
+        'video.frames_per_second': 15
+    }
+
+    dt = .2
+
+    LINK_LENGTH_1 = 1.  # [m]
+    LINK_LENGTH_2 = 1.  # [m]
+    LINK_MASS_1 = 1.  #: [kg] mass of link 1
+    LINK_MASS_2 = 1.  #: [kg] mass of link 2
+    LINK_COM_POS_1 = 0.5  #: [m] position of the center of mass of link 1
+    LINK_COM_POS_2 = 0.5  #: [m] position of the center of mass of link 2
+    LINK_MOI = 1.  #: moments of inertia for both links
+
+    MAX_VEL_1 = 4 * np.pi
+    MAX_VEL_2 = 9 * np.pi
+
+    AVAIL_TORQUE = [-1., 0., +1]
+
+    torque_noise_max = 0.
+
+    #: use dynamics equations from the nips paper or the book
+    book_or_nips = "book"
+    action_arrow = None
+    domain_fig = None
+    actions_num = 3
+
+    def __init__(self):
+        self.viewer = None
+        high = np.array([1.0, 1.0, 1.0, 1.0, self.MAX_VEL_1, self.MAX_VEL_2])
+        low = -high
+        self.observation_space = spaces.Box(low, high)
+        self.action_space = spaces.Box(np.array([-1.0]), np.array([1.0]))
+        self.state = None
+        self._seed()
+
+    def _seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def _reset(self):
+        self.state = self.np_random.uniform(low=-0.1, high=0.1, size=(4,))
+        return self._get_ob()
+
+    def _step(self, a):
+        # Discretize
+        if a[0] < -.33:
+            action = 0
+        elif a[0] < .33:
+            action = 1
+        else:
+            action = 2
+
+        s = self.state
+        reward = -np.cos(s[0]) - np.cos(s[1] + s[0])
+        torque = self.AVAIL_TORQUE[action]
+
+        # Add noise to the force action
+        if self.torque_noise_max > 0:
+            torque += self.np_random.uniform(-self.torque_noise_max, self.torque_noise_max)
+
+        # Now, augment the state with our force action so it can be passed to
+        # _dsdt
+        s_augmented = np.append(s, torque)
+
+        ns = rk4(self._dsdt, s_augmented, [0, self.dt])
+        # only care about final timestep of integration returned by integrator
+        ns = ns[-1]
+        ns = ns[:4]  # omit action
+        # ODEINT IS TOO SLOW!
+        # ns_continuous = integrate.odeint(self._dsdt, self.s_continuous, [0, self.dt])
+        # self.s_continuous = ns_continuous[-1] # We only care about the state
+        # at the ''final timestep'', self.dt
+
+        ns[0] = wrap(ns[0], -pi, pi)
+        ns[1] = wrap(ns[1], -pi, pi)
+        ns[2] = bound(ns[2], -self.MAX_VEL_1, self.MAX_VEL_1)
+        ns[3] = bound(ns[3], -self.MAX_VEL_2, self.MAX_VEL_2)
+        self.state = ns
+        # terminal = self._terminal()
+        terminal = False
+        # reward = -1. if not terminal else 0.
+        return (self._get_ob(), reward, terminal, {})
+
+    def _get_ob(self):
+        s = self.state
+        return np.array([cos(s[0]), np.sin(s[0]), cos(s[1]), sin(s[1]), s[2], s[3]])
+
+    def _terminal(self):
+        s = self.state
+        return bool(-np.cos(s[0]) - np.cos(s[1] + s[0]) > 1.)
+
+    def _dsdt(self, s_augmented, t):
+        m1 = self.LINK_MASS_1
+        m2 = self.LINK_MASS_2
+        l1 = self.LINK_LENGTH_1
+        lc1 = self.LINK_COM_POS_1
+        lc2 = self.LINK_COM_POS_2
+        I1 = self.LINK_MOI
+        I2 = self.LINK_MOI
+        g = 9.8
+        a = s_augmented[-1]
+        s = s_augmented[:-1]
+        theta1 = s[0]
+        theta2 = s[1]
+        dtheta1 = s[2]
+        dtheta2 = s[3]
+        d1 = m1 * lc1 ** 2 + m2 * \
+            (l1 ** 2 + lc2 ** 2 + 2 * l1 * lc2 * np.cos(theta2)) + I1 + I2
+        d2 = m2 * (lc2 ** 2 + l1 * lc2 * np.cos(theta2)) + I2
+        phi2 = m2 * lc2 * g * np.cos(theta1 + theta2 - np.pi / 2.)
+        phi1 = - m2 * l1 * lc2 * dtheta2 ** 2 * np.sin(theta2) \
+               - 2 * m2 * l1 * lc2 * dtheta2 * dtheta1 * np.sin(theta2)  \
+            + (m1 * lc1 + m2 * l1) * g * np.cos(theta1 - np.pi / 2) + phi2
+        if self.book_or_nips == "nips":
+            # the following line is consistent with the description in the
+            # paper
+            ddtheta2 = (a + d2 / d1 * phi1 - phi2) / \
+                (m2 * lc2 ** 2 + I2 - d2 ** 2 / d1)
+        else:
+            # the following line is consistent with the java implementation and the
+            # book
+            ddtheta2 = (a + d2 / d1 * phi1 - m2 * l1 * lc2 * dtheta1 ** 2 * np.sin(theta2) - phi2) \
+                / (m2 * lc2 ** 2 + I2 - d2 ** 2 / d1)
+        ddtheta1 = -(d2 * ddtheta2 + phi1) / d1
+        return (dtheta1, dtheta2, ddtheta1, ddtheta2, 0.)
+
+    def _render(self, mode='human', close=False):
+        if close:
+            if self.viewer is not None:
+                self.viewer.close()
+                self.viewer = None
+            return
+        from gym.envs.classic_control import rendering
+
+        s = self.state
+
+        if self.viewer is None:
+            self.viewer = rendering.Viewer(500, 500)
+            self.viewer.set_bounds(-2.2, 2.2, -2.2, 2.2)
+
+        if s is None:
+            return None
+
+        p1 = [-self.LINK_LENGTH_1 *
+              np.cos(s[0]), self.LINK_LENGTH_1 * np.sin(s[0])]
+
+        p2 = [p1[0] - self.LINK_LENGTH_2 * np.cos(s[0] + s[1]),
+              p1[1] + self.LINK_LENGTH_2 * np.sin(s[0] + s[1])]
+
+        xys = np.array([[0, 0], p1, p2])[:, ::-1]
+        thetas = [s[0] - np.pi / 2, s[0] + s[1] - np.pi / 2]
+
+        self.viewer.draw_line((-2.2, 1), (2.2, 1))
+        for ((x, y), th) in zip(xys, thetas):
+            l, r, t, b = 0, 1, .1, -.1
+            jtransform = rendering.Transform(rotation=th, translation=(x, y))
+            link = self.viewer.draw_polygon([(l, b), (l, t), (r, t), (r, b)])
+            link.add_attr(jtransform)
+            link.set_color(0, .8, .8)
+            circ = self.viewer.draw_circle(.1)
+            circ.set_color(.8, .8, 0)
+            circ.add_attr(jtransform)
+
+        return self.viewer.render(return_rgb_array=(mode == 'rgb_array'))
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        """
+            def height(obs):
+                h1 = obs[0]  # Height of first arm
+                h2 = obs[0] * obs[2] - obs[1] * obs[3]  # Height of second arm
+                return -(h1 + h2)  # total height
+
+            start_height = height(data_dict['start_state'])
+        """
+        h1 = obs[:, 0]  # Height of first arm
+        h2 = obs[:, 0] * obs[:, 2] - obs[:, 1] * obs[:, 3]  # Height of second arm
+        return (h1 + h2)
+
+    def verify(self, n=2000, eps=1e-4):
+        dataset = Dataset(gen_dtype(self, 'state action next_state reward done'), n)
+        state = self.reset()
+        for _ in range(n):
+            action = self.action_space.sample()
+            next_state, reward, done, _ = self.step(action)
+            dataset.append((state, action, next_state, reward, done))
+
+            state = next_state
+            if done:
+                state = self.reset()
+
+        rewards_, dones_ = self.mb_step(dataset.state, dataset.action, dataset.next_state)
+        diff = dataset.reward - rewards_
+        l_inf = np.abs(diff).max()
+        logger.info('rewarder difference: %.6f', l_inf)
+
+        assert np.allclose(dones_, dataset.done)
+        assert l_inf < eps
+
+
+def wrap(x, m, M):
+    """
+    :param x: a scalar
+    :param m: minimum possible value in range
+    :param M: maximum possible value in range
+    Wraps ``x`` so m <= x <= M; but unlike ``bound()`` which
+    truncates, ``wrap()`` wraps x around the coordinate system defined by m,M.\n
+    For example, m = -180, M = 180 (degrees), x = 360 --> returns 0.
+    """
+    diff = M - m
+    while x > M:
+        x = x - diff
+    while x < m:
+        x = x + diff
+    return x
+
+
+def bound(x, m, M=None):
+    """
+    :param x: scalar
+    Either have m as scalar, so bound(x,m,M) which returns m <= x <= M *OR*
+    have m as length 2 vector, bound(x,m, <IGNORED>) returns m[0] <= x <= m[1].
+    """
+    if M is None:
+        M = m[1]
+        m = m[0]
+    # bound x between min (m) and Max (M)
+    return min(max(x, m), M)
+
+
+def rk4(derivs, y0, t, *args, **kwargs):
+    """
+    Integrate 1D or ND system of ODEs using 4-th order Runge-Kutta.
+    This is a toy implementation which may be useful if you find
+    yourself stranded on a system w/o scipy.  Otherwise use
+    :func:`scipy.integrate`.
+    *y0*
+        initial state vector
+    *t*
+        sample times
+    *derivs*
+        returns the derivative of the system and has the
+        signature ``dy = derivs(yi, ti)``
+    *args*
+        additional arguments passed to the derivative function
+    *kwargs*
+        additional keyword arguments passed to the derivative function
+    Example 1 ::
+        ## 2D system
+        def derivs6(x,t):
+            d1 =  x[0] + 2*x[1]
+            d2 =  -3*x[0] + 4*x[1]
+            return (d1, d2)
+        dt = 0.0005
+        t = arange(0.0, 2.0, dt)
+        y0 = (1,2)
+        yout = rk4(derivs6, y0, t)
+    Example 2::
+        ## 1D system
+        alpha = 2
+        def derivs(x,t):
+            return -alpha*x + exp(-t)
+        y0 = 1
+        yout = rk4(derivs, y0, t)
+    If you have access to scipy, you should probably be using the
+    scipy.integrate tools rather than this function.
+    """
+
+    try:
+        Ny = len(y0)
+    except TypeError:
+        yout = np.zeros((len(t),), np.float_)
+    else:
+        yout = np.zeros((len(t), Ny), np.float_)
+
+    yout[0] = y0
+    i = 0
+
+    for i in np.arange(len(t) - 1):
+
+        thist = t[i]
+        dt = t[i + 1] - thist
+        dt2 = dt / 2.0
+        y0 = yout[i]
+
+        k1 = np.asarray(derivs(y0, thist, *args, **kwargs))
+        k2 = np.asarray(derivs(y0 + dt2 * k1, thist + dt2, *args, **kwargs))
+        k3 = np.asarray(derivs(y0 + dt2 * k2, thist + dt2, *args, **kwargs))
+        k4 = np.asarray(derivs(y0 + dt * k3, thist + dt, *args, **kwargs))
+        yout[i + 1] = y0 + dt / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)
+    return yout
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/ant.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/ant.py
new file mode 100644
index 0000000..a2699aa
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/ant.py
@@ -0,0 +1,81 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class AntEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=5):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/ant.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        old_ob = self._get_obs()
+        self.do_simulation(action, self.frame_skip)
+
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+        ob = self._get_obs()
+
+        reward_ctrl = -0.1 * np.square(action).sum()
+        reward_run = old_ob[13]
+        reward_height = -3.0 * np.square(old_ob[0] - 0.57)
+        reward = reward_run + reward_ctrl + reward_height + 1.0
+        done = False
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            # (self.model.data.qpos.flat[:1] - self.prev_qpos[:1]) / self.dt,
+            # self.get_body_comvel("torso")[:1],
+            self.model.data.qpos.flat[2:],
+            self.model.data.qvel.flat,
+        ])
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def reset_model(self):
+        qpos = self.init_qpos + self.np_random.uniform(size=self.model.nq, low=-.1, high=.1)
+        qvel = self.init_qvel + self.np_random.randn(self.model.nv) * .1
+        self.set_state(qpos, qvel)
+        # self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 13]
+        reward_height = -3.0 * np.square(obs[:, 0] - 0.57)
+        reward = reward_run + reward_ctrl + reward_height + 1.0
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        # reward_height = -3.0 * tf.square(next_obs[:, 0] - 0.57)
+        reward = reward_run + reward_ctrl # + reward_height
+        return -reward
+        """
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/cartpole.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/cartpole.xml
new file mode 100644
index 0000000..284a58c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/cartpole.xml
@@ -0,0 +1,35 @@
+<mujoco model="cartpole">
+	<compiler inertiafromgeom="true"/>
+	<default>
+		<joint armature="0" damping="1" limited="true"/>
+		<geom contype="0" friction="1 0.1 0.1" rgba="0.7 0.7 0 1"/>
+		<tendon/>
+		<motor ctrlrange="-3 3" ctrllimited='true'/>
+	</default>
+    <asset>
+		<texture type="skybox" builtin="checker" rgb1="1 1 1" rgb2="1 1 1"
+                    width="256" height="256"/>
+        <texture name="texgeom" type="cube" builtin="flat" mark="cross" width="127" height="1278" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" markrgb="1 1 1" random="0.01" />
+		<texture name="texplane" type="2d" builtin="checker" rgb1=".5 .5 .5" rgb2=".5 .5 .5" width="100" height="100" />
+        <texture name="texplane_show" type="2d" builtin="checker" rgb1="0 0 0" rgb2="0.9 0.9 0.9" width="100" height="100" />
+        <material name='MatPlane' texture="texplane" shininess="1" texrepeat="30 30" specular="1"  reflectance="0.5" />
+        <material name='geom' texture="texgeom" texuniform="true" />
+ 	</asset>
+	<option gravity="0 0 -9.81" integrator="RK4" timestep="0.02"/>
+	<size nstack="3000"/>
+	<worldbody>
+		<geom name="rail" pos="0 0 0" quat="0.707 0 0.707 0" rgba="0.3 0.3 0.7 1" size="0.02 3" type="capsule"/>
+		<body name="cart" pos="0 0 0">
+			<joint axis="1 0 0" limited="true" name="slider" pos="0 0 0" range="-2.5 2.5" type="slide"/>
+			<geom name="cart" pos="0 0 0" quat="0.707 0 0.707 0" size="0.1 0.1" type="capsule"/>
+			<body name="pole" pos="0 0 0">
+				<joint axis="0 1 0" limited="false" name="hinge" pos="0 0 0" range="-180 180" type="hinge"/>
+				<geom fromto="0 0 0 0.001 0 -0.6" name="cpole" rgba="0 0.7 0.7 1" size="0.049 0.3" type="capsule"/>
+			</body>
+		</body>
+	</worldbody>
+	<actuator>
+		<motor gear="100" joint="slider" name="slide"/>
+	</actuator>
+</mujoco>
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/fixed_swimmer.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/fixed_swimmer.xml
new file mode 100644
index 0000000..142f344
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/fixed_swimmer.xml
@@ -0,0 +1,43 @@
+<mujoco model="swimmer">
+  <compiler angle="degree" coordinate="local" inertiafromgeom="true"/>
+  <option collision="predefined" density="4000" integrator="RK4" timestep="0.01" viscosity="0.1"/>
+  <default>
+    <geom conaffinity="1" condim="1" contype="1" material="geom" rgba="0.8 0.6 .4 1"/>
+    <joint armature='0.1'  />
+  </default>
+  <asset>
+    <texture builtin="gradient" height="100" rgb1="1 1 1" rgb2="0 0 0" type="skybox" width="100"/>
+    <texture builtin="flat" height="1278" mark="cross" markrgb="1 1 1" name="texgeom" random="0.01" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" type="cube" width="127"/>
+    <texture builtin="checker" height="100" name="texplane" rgb1="0 0 0" rgb2="0.8 0.8 0.8" type="2d" width="100"/>
+    <material name="MatPlane" reflectance="0.5" shininess="1" specular="1" texrepeat="30 30" texture="texplane"/>
+    <material name="geom" texture="texgeom" texuniform="true"/>
+  </asset>
+
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0 1.3" specular=".1 .1 .1"/>
+    <geom conaffinity="1" condim="3" material="MatPlane" name="floor" pos="0 0 -0.1" rgba="0.8 0.9 0.8 1" size="40 40 0.1" type="plane"/>
+    <body name="podBody_1" pos="0 0 0">
+      <geom name='pod_1' density="1000" fromto="0 0 0 -1 0 0" size="0.1" type="capsule"/>
+      <joint axis="1 0 0" name="slider1" pos="0 0 0" type="slide"/>
+      <joint axis="0 1 0" name="slider2" pos="0 0 0" type="slide"/>
+      <joint axis="0 0 1" name="rot_1" pos="-1.5 0 0" type="hinge"/>
+      <site name="tip" pos="0 0 0" size="0.02 0.02"/>
+      <body name="podBody_2" pos="-1 0 0">
+        <geom name='pod_2' density="1000" fromto="0 0 0 -1 0 0" size="0.1" type="capsule"/>
+        <joint axis="0 0 1" limited="true" name="rot_2" pos="0 0 0" range="-100 100" type="hinge"/>
+        
+        <body name="podBody_3" pos="-1 0 0">
+          <geom name='pod_3' density="1000" fromto="0 0 0 -1 0 0" size="0.1" type="capsule"/>
+          <joint axis="0 0 1" limited="true" name="rot_3" pos="0 0 0" range="-100 100" type="hinge"/>
+        
+        </body>
+
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor ctrllimited="true" ctrlrange="-1 1" gear="150.0" joint="rot_2"/>
+    <motor ctrllimited="true" ctrlrange="-1 1" gear="150.0" joint="rot_3"/>
+  </actuator>
+
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/half_cheetah.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/half_cheetah.xml
new file mode 100644
index 0000000..40a1cb6
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/half_cheetah.xml
@@ -0,0 +1,95 @@
+<!-- Cheetah Model
+
+    The state space is populated with joints in the order that they are
+    defined in this file. The actuators also operate on joints.
+
+    State-Space (name/joint/parameter):
+        - rootx     slider      position (m)
+        - rootz     slider      position (m)
+        - rooty     hinge       angle (rad)
+        - bthigh    hinge       angle (rad)
+        - bshin     hinge       angle (rad)
+        - bfoot     hinge       angle (rad)
+        - fthigh    hinge       angle (rad)
+        - fshin     hinge       angle (rad)
+        - ffoot     hinge       angle (rad)
+        - rootx     slider      velocity (m/s)
+        - rootz     slider      velocity (m/s)
+        - rooty     hinge       angular velocity (rad/s)
+        - bthigh    hinge       angular velocity (rad/s)
+        - bshin     hinge       angular velocity (rad/s)
+        - bfoot     hinge       angular velocity (rad/s)
+        - fthigh    hinge       angular velocity (rad/s)
+        - fshin     hinge       angular velocity (rad/s)
+        - ffoot     hinge       angular velocity (rad/s)
+
+    Actuators (name/actuator/parameter):
+        - bthigh    hinge       torque (N m)
+        - bshin     hinge       torque (N m)
+        - bfoot     hinge       torque (N m)
+        - fthigh    hinge       torque (N m)
+        - fshin     hinge       torque (N m)
+        - ffoot     hinge       torque (N m)
+
+-->
+<mujoco model="cheetah">
+  <compiler angle="radian" coordinate="local" inertiafromgeom="true" settotalmass="14"/>
+  <default>
+    <joint armature=".1" damping=".01" limited="true" solimplimit="0 .8 .03" solreflimit=".02 1" stiffness="8"/>
+    <geom conaffinity="0" condim="3" contype="1" friction=".4 .1 .1" rgba="0.8 0.6 .4 1" solimp="0.0 0.8 0.01" solref="0.02 1"/>
+    <motor ctrllimited="true" ctrlrange="-1 1"/>
+  </default>
+  <size nstack="300000" nuser_geom="1"/>
+  <option gravity="0 0 -9.81" timestep="0.01"/>
+  <asset>
+    <texture builtin="gradient" height="100" rgb1="1 1 1" rgb2="0 0 0" type="skybox" width="100"/>
+    <texture builtin="flat" height="1278" mark="cross" markrgb="1 1 1" name="texgeom" random="0.01" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" type="cube" width="127"/>
+    <texture builtin="checker" height="100" name="texplane" rgb1="0 0 0" rgb2="0.8 0.8 0.8" type="2d" width="100"/>
+    <material name="MatPlane" reflectance="0.5" shininess="1" specular="1" texrepeat="150 150" texture="texplane"/>
+    <material name="geom" texture="texgeom" texuniform="true"/>
+  </asset>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0 1.3" specular=".1 .1 .1"/>
+    <geom conaffinity="1" condim="3" material="MatPlane" name="floor" pos="0 0 0" rgba="0.8 0.9 0.8 1" size="200 200 200" type="plane"/>
+    <body name="torso" pos="0 0 .7">
+      <joint armature="0" axis="1 0 0" damping="0" limited="false" name="rootx" pos="0 0 0" stiffness="0" type="slide"/>
+      <joint armature="0" axis="0 0 1" damping="0" limited="false" name="rootz" pos="0 0 0" stiffness="0" type="slide"/>
+      <joint armature="0" axis="0 1 0" damping="0" limited="false" name="rooty" pos="0 0 0" stiffness="0" type="hinge"/>
+      <geom fromto="-.5 0 0 .5 0 0" name="torso" size="0.046" type="capsule"/>
+      <geom axisangle="0 1 0 .87" name="head" pos=".6 0 .1" size="0.046 .15" type="capsule"/>
+      <!-- <site name='tip'  pos='.15 0 .11'/>-->
+      <body name="bthigh" pos="-.5 0 0">
+        <joint axis="0 1 0" damping="6" name="bthigh" pos="0 0 0" range="-.52 1.05" stiffness="240" type="hinge"/>
+        <geom axisangle="0 1 0 -3.8" name="bthigh" pos=".1 0 -.13" size="0.046 .145" type="capsule"/>
+        <body name="bshin" pos=".16 0 -.25">
+          <joint axis="0 1 0" damping="4.5" name="bshin" pos="0 0 0" range="-.785 .785" stiffness="180" type="hinge"/>
+          <geom axisangle="0 1 0 -2.03" name="bshin" pos="-.14 0 -.07" rgba="0.9 0.6 0.6 1" size="0.046 .15" type="capsule"/>
+          <body name="bfoot" pos="-.28 0 -.14">
+            <joint axis="0 1 0" damping="3" name="bfoot" pos="0 0 0" range="-.4 .785" stiffness="120" type="hinge"/>
+            <geom axisangle="0 1 0 -.27" name="bfoot" pos=".03 0 -.097" rgba="0.9 0.6 0.6 1" size="0.046 .094" type="capsule"/>
+          </body>
+        </body>
+      </body>
+      <body name="fthigh" pos=".5 0 0">
+        <joint axis="0 1 0" damping="4.5" name="fthigh" pos="0 0 0" range="-1 .7" stiffness="180" type="hinge"/>
+        <geom axisangle="0 1 0 .52" name="fthigh" pos="-.07 0 -.12" size="0.046 .133" type="capsule"/>
+        <body name="fshin" pos="-.14 0 -.24">
+          <joint axis="0 1 0" damping="3" name="fshin" pos="0 0 0" range="-1.2 .87" stiffness="120" type="hinge"/>
+          <geom axisangle="0 1 0 -.6" name="fshin" pos=".065 0 -.09" rgba="0.9 0.6 0.6 1" size="0.046 .106" type="capsule"/>
+          <body name="ffoot" pos=".13 0 -.18">
+            <joint axis="0 1 0" damping="1.5" name="ffoot" pos="0 0 0" range="-.5 .5" stiffness="60" type="hinge"/>
+            <geom axisangle="0 1 0 -.6" name="ffoot" pos=".045 0 -.07" rgba="0.9 0.6 0.6 1" size="0.046 .07" type="capsule"/>
+          </body>
+        </body>
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor gear="120" joint="bthigh" name="bthigh"/>
+    <motor gear="90" joint="bshin" name="bshin"/>
+    <motor gear="60" joint="bfoot" name="bfoot"/>
+    <motor gear="120" joint="fthigh" name="fthigh"/>
+    <motor gear="60" joint="fshin" name="fshin"/>
+    <motor gear="30" joint="ffoot" name="ffoot"/>
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/pusher.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/pusher.xml
new file mode 100644
index 0000000..9e81b01
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/pusher.xml
@@ -0,0 +1,101 @@
+<mujoco model="arm3d">
+  <compiler inertiafromgeom="true" angle="radian" coordinate="local"/>
+  <option timestep="0.01" gravity="0 0 0" iterations="20" integrator="Euler" />
+  
+  <default>
+    <joint armature='0.04' damping="1" limited="true"/>
+    <geom friction=".8 .1 .1" density="300" margin="0.002" condim="1" contype="0" conaffinity="0"/>
+  </default>
+  <asset>
+    <texture type="skybox" builtin="checker" rgb1="1 1 1" rgb2="1 1 1"
+             width="256" height="256"/>
+    <texture name="texgeom" type="cube" builtin="flat" mark="cross" width="127" height="1278" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" markrgb="1 1 1" random="0.01" />
+    <texture name="texplane" type="2d" builtin="checker" rgb1=".5 .5 .5" rgb2=".5 .5 .5" width="100" height="100" />
+    <texture name="texplane_show" type="2d" builtin="checker" rgb1="0 0 0" rgb2="0.9 0.9 0.9" width="100" height="100" />
+    <material name='MatPlane' texture="texplane" shininess="1" texrepeat="30 30" specular="1"  reflectance="0.5" />
+    <material name='geom' texture="texgeom" texuniform="true" />
+  </asset>
+
+  <worldbody>
+    <light diffuse=".5 .5 .5" pos="0 0 3" dir="0 0 -1"/>
+    <geom name="table" type="plane" pos="0 0.5 -0.325" size="1 1 0.1" contype="1" conaffinity="1"/>
+
+    <body name="r_shoulder_pan_link" pos="0 -0.6 0">
+      <geom name="e1" type="sphere" rgba="0.6 0.6 0.6 1" pos="-0.06 0.05 0.2" size="0.05" />
+      <geom name="e2" type="sphere" rgba="0.6 0.6 0.6 1" pos=" 0.06 0.05 0.2" size="0.05" />
+      <geom name="e1p" type="sphere" rgba="0.1 0.1 0.1 1" pos="-0.06 0.09 0.2" size="0.03" />
+      <geom name="e2p" type="sphere" rgba="0.1 0.1 0.1 1" pos=" 0.06 0.09 0.2" size="0.03" />
+      <geom name="sp" type="capsule" fromto="0 0 -0.4 0 0 0.2" size="0.1" />
+      <!--<joint name="r_shoulder_pan_joint" type="hinge" pos="0 0 0" axis="0 0 1" range="-2.2854 1.714602" damping="1.0" />-->
+      <joint name="r_shoulder_pan_joint" type="hinge" pos="0 0 0" axis="0 0 1" range="-2.2854 2.0" damping="1.0" />
+
+      <body name="r_shoulder_lift_link" pos="0.1 0 0">
+        <geom name="sl" type="capsule" fromto="0 -0.1 0 0 0.1 0" size="0.1" />
+        <joint name="r_shoulder_lift_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.5236 1.3963" damping="1.0" />
+
+        <body name="r_upper_arm_roll_link" pos="0 0 0">
+          <geom name="uar" type="capsule" fromto="-0.1 0 0 0.1 0 0" size="0.02" />
+          <joint name="r_upper_arm_roll_joint" type="hinge" pos="0 0 0" axis="1 0 0" range="-1.5 1.7" damping="0.1" />
+
+          <body name="r_upper_arm_link" pos="0 0 0">
+            <geom name="ua" type="capsule" fromto="0 0 0 0.4 0 0" size="0.06" />
+
+            <body name="r_elbow_flex_link" pos="0.4 0 0">
+              <geom name="ef" type="capsule" fromto="0 -0.02 0 0.0 0.02 0" size="0.06" />
+              <joint name="r_elbow_flex_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-2.3213 0" damping="0.1" />
+
+              <body name="r_forearm_roll_link" pos="0 0 0">
+                <geom name="fr" type="capsule" fromto="-0.1 0 0 0.1 0 0" size="0.02" />
+                <joint name="r_forearm_roll_joint" type="hinge" limited="true" pos="0 0 0" axis="1 0 0" damping=".1" range="-1.5 1.5"/>
+
+                <body name="r_forearm_link" pos="0 0 0">
+                  <geom name="fa" type="capsule" fromto="0 0 0 0.291 0 0" size="0.05" />
+
+                  <body name="r_wrist_flex_link" pos="0.321 0 0">
+                    <geom name="wf" type="capsule" fromto="0 -0.02 0 0 0.02 0" size="0.01" />
+                    <joint name="r_wrist_flex_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-1.094 0" damping=".1" />
+
+                    <body name="r_wrist_roll_link" pos="0 0 0">
+                      <joint name="r_wrist_roll_joint" type="hinge" pos="0 0 0" limited="true" axis="1 0 0" damping="0.1" range="-1.5 1.5"/>
+                      <body name="tips_arm" pos="0 0 0">
+                        <geom name="tip_arml" type="sphere" pos="0.1 -0.1 0." size="0.01" />
+                        <geom name="tip_armr" type="sphere" pos="0.1 0.1 0." size="0.01" />
+                      </body>
+                      <geom type="capsule" fromto="0 -0.1 0. 0.0 +0.1 0" size="0.02" contype="1" conaffinity="1" />
+                      <geom type="capsule" fromto="0 -0.1 0. 0.1 -0.1 0" size="0.02" contype="1" conaffinity="1" />
+                      <geom type="capsule" fromto="0 +0.1 0. 0.1 +0.1 0." size="0.02" contype="1" conaffinity="1" />
+                    </body>
+                  </body>
+                </body>
+              </body>
+            </body>
+          </body>
+        </body>
+      </body>
+    </body>
+
+    <!--<body name="object" pos="0.55 -0.3 -0.275" >-->
+    <body name="object" pos="0.45 -0.05 -0.275" >
+      <geom rgba="1 1 1 0" type="sphere" size="0.05 0.05 0.05" density="0.00001" conaffinity="0"/>
+      <geom rgba="1 1 1 1" type="cylinder" size="0.05 0.05 0.05" density="0.00001" contype="1" conaffinity="0"/>
+      <joint name="obj_slidey" type="slide" pos="0 0 0" axis="0 1 0" range="-10.3213 10.3" damping="0.5"/>
+      <joint name="obj_slidex" type="slide" pos="0 0 0" axis="1 0 0" range="-10.3213 10.3" damping="0.5"/>
+    </body>
+
+    <body name="goal" pos="0.45 -0.05 -0.3230">
+      <geom rgba="1 0 0 1" type="cylinder" size="0.08 0.001 0.1" density='0.00001' contype="0" conaffinity="0"/>
+      <joint name="goal_slidey" type="slide" pos="0 0 0" axis="0 1 0" range="-10.3213 10.3" damping="0.5"/>
+      <joint name="goal_slidex" type="slide" pos="0 0 0" axis="1 0 0" range="-10.3213 10.3" damping="0.5"/> 
+    </body>
+  </worldbody>
+
+  <actuator>
+    <motor joint="r_shoulder_pan_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_shoulder_lift_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_upper_arm_roll_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_elbow_flex_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_forearm_roll_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_wrist_flex_joint" ctrlrange="-2.0 2.0" ctrllimited="true" />
+    <motor joint="r_wrist_roll_joint" ctrlrange="-2.0 2.0" ctrllimited="true"/>
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/reacher3d.xml b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/reacher3d.xml
new file mode 100644
index 0000000..a51c71b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/assets/reacher3d.xml
@@ -0,0 +1,154 @@
+<mujoco model="arm3d">
+
+    <compiler inertiafromgeom="true" angle="radian" coordinate="local" />
+    <option timestep="0.01" gravity="0 0 0" iterations="20" integrator="RK4" />
+    <default>
+        <joint armature="0.04" damping="1" limited="true" />
+        <geom friction=".5 .1 .1" margin="0.002" condim="1" contype="0" conaffinity="0" />
+    </default>
+    <asset>
+        <texture type="skybox" builtin="checker" rgb1="1 1 1" rgb2="1 1 1"
+                 width="256" height="256"/>
+        <texture name="texgeom" type="cube" builtin="flat" mark="cross" width="127" height="1278" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" markrgb="1 1 1" random="0.01" />
+        <texture name="texplane" type="2d" builtin="checker" rgb1=".5 .5 .5" rgb2=".5 .5 .5" width="100" height="100" />
+        <texture name="texplane_show" type="2d" builtin="checker" rgb1="0 0 0" rgb2="0.9 0.9 0.9" width="100" height="100" />
+        <material name='MatPlane' texture="texplane" shininess="1" texrepeat="30 30" specular="1"  reflectance="0.5" />
+        <material name='geom' texture="texgeom" texuniform="true" />
+    </asset>
+    <worldbody>
+        <light pos="0 0 5" />
+        <body name="r_shoulder_pan_link" pos="0 -0.188 0">
+            <geom name="e1" type="sphere" rgba="0.6 0.6 0.6 1" pos="-0.06 0.05 0.2" size="0.05" />
+            <geom name="e2" type="sphere" rgba="0.6 0.6 0.6 1" pos=" 0.06 0.05 0.2" size="0.05" />
+            <geom name="e1p" type="sphere" rgba="0.1 0.1 0.1 1" pos="-0.06 0.09 0.2" size="0.03" />
+            <geom name="e2p" type="sphere" rgba="0.1 0.1 0.1 1" pos=" 0.06 0.09 0.2" size="0.03" />
+            <geom name="sp" type="capsule" fromto="0 0 -0.4 0 0 0.2" size="0.1" />
+            <joint name="r_shoulder_pan_joint" type="hinge" pos="0 0 0" axis="0 0 1" range="-2.2854 1.714602" damping="10.0" />
+
+            <body name="r_shoulder_lift_link" pos="0.1 0 0">
+                <geom name="sl" type="capsule" fromto="0 -0.1 0 0 0.1 0" size="0.1" />
+                <joint name="r_shoulder_lift_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.5236 1.3963" damping="10.0" />
+
+                <body name="r_upper_arm_roll_link" pos="0 0 0">
+                    <geom name="uar" type="capsule" fromto="-0.1 0 0 0.1 0 0" size="0.02" />
+                    <joint name="r_upper_arm_roll_joint" type="hinge" pos="0 0 0" axis="1 0 0" range="-3.9 0.8" damping="0.1" />
+
+                    <body name="r_upper_arm_link" pos="0 0 0">
+                        <geom name="ua" type="capsule" fromto="0 0 0 0.4 0 0" size="0.06" />
+
+                        <body name="r_elbow_flex_link" pos="0.4 0 0">
+                            <geom name="ef" type="capsule" fromto="0 -0.02 0 0.0 0.02 0" size="0.06" />
+                            <joint name="r_elbow_flex_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-2.3213 0" damping="1.0" />
+
+                            <body name="r_forearm_roll_link" pos="0 0 0">
+                                <geom name="fr" type="capsule" fromto="-0.1 0 0 0.1 0 0" size="0.02" />
+                                <joint name="r_forearm_roll_joint" type="hinge" limited="false" pos="0 0 0" axis="1 0 0" damping=".1" />
+
+                                <body name="r_forearm_link" pos="0 0 0">
+                                    <geom name="fa" type="capsule" fromto="0 0 0 0.321 0 0" size="0.05" />
+
+                                    <body name="r_wrist_flex_link" pos="0.321 0 0">
+                                        <geom name="wf" type="capsule" fromto="0 -0.02 0 0 0.02 0" size="0.01" />
+                                        <joint name="r_wrist_flex_joint" type="hinge" pos="0 0 0" axis="0 1 0" range="-2.094 0" damping=".1" />
+
+                                        <body name="r_wrist_roll_link" pos="0 0 0">
+                                            <geom name="wr" type="capsule" fromto="-0.02 0 0 0.02 0 0" size="0.01" />
+                                            <joint name="r_wrist_roll_joint" type="hinge" pos="0 0 0" limited="false" axis="1 0 0" damping="0.1" />
+
+                                            <body name="r_gripper_palm_link" pos="0 0 0">
+                                                <geom name="pl" type="capsule" fromto="0.05 0 -0.02 0.05 0 0.02" size="0.05" />
+
+                                                <!--
+                                                <body name="r_gripper_tool_frame" pos="0.18 0 0">
+                                                    <site name="leg_bottom" pos="0 0 -0.15" size="0.01" />
+                                                    <site name="leg_top" pos="0 0 0.15" size="0.01" />
+
+                                                    <body name="ball" pos="0 0 0">
+                                                        <geom name="ball_geom" rgba="0.8 0.6 0.6 1" type="cylinder" fromto="0 0 -0.15 0 0 0.15" size="0.028" density="2000" contype="2" conaffinity="1" />
+                                                    </body>
+                                                </body>
+                                                -->
+
+                                                <body name="r_gripper_l_finger_link" pos="0.07691 0.03 0">
+                                                    <geom name="gf3" type="capsule" fromto="0 0 0 0.09137 0.00495 0" size="0.01" />
+
+                                                    <body name="r_gripper_l_finger_tip_link" pos="0.09137 0.00495 0">
+                                                        <geom name="gf4" type="capsule" fromto="0 0 0 0.09137 0.0 0" size="0.01" />
+                                                    </body>
+                                                </body>
+
+                                                <body name="r_gripper_r_finger_link" pos="0.07691 -0.03 0">
+                                                    <geom name="gf1" type="capsule" fromto="0 0 0 0.09137 -0.00495 0" size="0.01" />
+
+                                                    <body name="r_gripper_r_finger_tip_link" pos="0.09137 -0.00495 0">
+                                                        <geom name="gf2" type="capsule" fromto="0 0 0 0.09137 0.0 0" size="0.01" />
+                                                    </body>
+                                                </body>
+                                            </body>
+                                        </body>
+                                    </body>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                </body>
+            </body>
+        </body>
+
+        <!--
+        <body name="g1" pos="0.034 0.3 -0.47" axisangle="0 1 0 0.05">
+            <geom name="g1" rgba="0.2 0.2 0.2 1" type="box" size="0.003 0.01 0.05" contype="1" conaffinity="1" />
+        </body>
+
+        <body name="g2" pos="-0.034 0.3 -0.47" axisangle="0 1 0 -0.05">
+            <geom name="g2" rgba="0.2 0.2 0.2 1" type="box" size="0.003 0.01 0.05" contype="1" conaffinity="1" />
+        </body>
+
+        <body name="g3" pos="0.0 0.334 -0.47" axisangle="1 0 0 -0.05">
+            <geom name="g3" rgba="0.2 0.2 0.2 1" type="box" size="0.01 0.003 0.05" contype="1" conaffinity="1" />
+        </body>
+
+        <body name="g4" pos="0.0 0.266 -0.47" axisangle="1 0 0 0.05">
+            <geom name="g4" rgba="0.2 0.2 0.2 1" type="box" size="0.01 0.003 0.05" contype="1" conaffinity="1" />
+        </body>
+
+        <body name="fl" pos="0.0 0.3 -0.55">
+            <geom name="fl" rgba="0.2 0.2 0.2 1" type="box" size="0.2 0.2 0.05" contype="1" conaffinity="1" />
+        </body>
+
+        <body name="w1" pos="0.216 0.3 -0.45">
+            <geom name="w1" rgba="0.2 0.2 0.2 1" type="box" size="0.183 0.3 0.05" contype="1" conaffinity="1" />
+        </body>
+
+        <body name="w2" pos="-0.216 0.3 -0.45">
+            <geom name="w2" rgba="0.2 0.2 0.2 1" type="box" size="0.183 0.3 0.05" contype="1" conaffinity="1" />
+        </body>
+
+        <body name="w3" pos="0.0 0.516 -0.45">
+            <geom name="w3" rgba="0.2 0.2 0.2 1" type="box" size="0.032 0.183 0.05" contype="1" conaffinity="1" />
+        </body>
+
+        <body name="w4" pos="0.0 0.084 -0.45">
+            <geom name="w4" rgba="0.2 0.2 0.2 1" type="box" size="0.032 0.183 0.05" contype="1" conaffinity="1" />
+        </body>
+        -->
+
+        <body name="target" pos="0 0.25 0">
+            <joint armature="0" axis="1 0 0" damping="0" limited="false" name="target_x" pos="0 0 0" ref="0" stiffness="0" type="slide"/>
+            <joint armature="0" axis="0 1 0" damping="0" limited="false" name="target_y" pos="0 0 0" ref="0.25" stiffness="0" type="slide"/>
+            <joint armature="0" axis="0 0 1" damping="0" limited="false" name="target_z" pos="0 0 0" ref="0" stiffness="0" type="slide"/>
+            <geom conaffinity="0" contype="0" name="target" pos="0 0 0" rgba="0.9 0.2 0.2 1" size=".035" type="sphere"/>
+        </body>
+    </worldbody>
+
+    <actuator>
+        <motor joint="r_shoulder_pan_joint" ctrlrange="-20.0 20.0" ctrllimited="true" />
+        <motor joint="r_shoulder_lift_joint" ctrlrange="-20.0 20.0" ctrllimited="true" />
+        <motor joint="r_upper_arm_roll_joint" ctrlrange="-20.0 20.0" ctrllimited="true" />
+        <motor joint="r_elbow_flex_joint" ctrlrange="-20.0 20.0" ctrllimited="true" />
+        <motor joint="r_forearm_roll_joint" ctrlrange="-20.0 20.0" ctrllimited="true" />
+        <motor joint="r_wrist_flex_joint" ctrlrange="-20.0 20.0" ctrllimited="true" />
+        <motor joint="r_wrist_roll_joint" ctrlrange="-20.0 20.0" ctrllimited="true" />
+    </actuator>
+
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/cartpole.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/cartpole.py
new file mode 100644
index 0000000..ddc3d41
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/cartpole.py
@@ -0,0 +1,193 @@
+"""
+Classic cart-pole system implemented by Rich Sutton et al.
+Copied from https://webdocs.cs.ualberta.ca/~sutton/book/code/pole.c
+"""
+
+import logging
+import math
+import gym
+from gym import spaces
+from gym.utils import seeding
+import numpy as np
+from slbo.utils.dataset import Dataset, gen_dtype
+
+
+logger = logging.getLogger(__name__)
+
+
+class CartPoleEnv(gym.Env):
+    metadata = {
+        'render.modes': ['human', 'rgb_array'],
+        'video.frames_per_second': 50
+    }
+
+    def __init__(self):
+        self.gravity = 9.8
+        self.masscart = 1.0
+        self.masspole = 0.1
+        self.total_mass = (self.masspole + self.masscart)
+        self.length = 0.5  # actually half the pole's length
+        self.polemass_length = (self.masspole * self.length)
+        self.force_mag = 10.0
+        self.tau = 0.02  # seconds between state updates
+
+        # Angle at which to fail the episode
+        self.theta_threshold_radians = 12 * 2 * math.pi / 360
+        self.x_threshold = 2.4
+
+        # Angle limit set to 2 * theta_threshold_radians so failing observation is still within bounds
+        high = np.array([
+            self.x_threshold * 2,
+            np.finfo(np.float32).max,
+            self.theta_threshold_radians * 2,
+            np.finfo(np.float32).max])
+
+        # self.action_space = spaces.Discrete(2)
+        self.action_space = \
+            spaces.Box(low=np.array([-1.0]), high=np.array([1.0]))
+        self.observation_space = spaces.Box(-high, high)
+
+        self._seed()
+        self.viewer = None
+        self.state = None
+
+        self.steps_beyond_done = None
+
+    def _seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def _step(self, action):
+        action = 1 if action[0] > .0 else 0
+        # assert self.action_space.contains(action), "%r (%s) invalid" % (action, type(action))
+        state = self.state
+        obs = self.state
+        reward = np.cos(obs[2]) - 0.01 * (obs[0] ** 2)
+
+        x, x_dot, theta, theta_dot = state
+        force = self.force_mag if action == 1 else -self.force_mag
+        costheta = math.cos(theta)
+        sintheta = math.sin(theta)
+        temp = (force + self.polemass_length * theta_dot * theta_dot * sintheta) / self.total_mass
+        thetaacc = (self.gravity * sintheta - costheta * temp) / (self.length * (4.0 / 3.0 - self.masspole * costheta * costheta / self.total_mass))
+        xacc = temp - self.polemass_length * thetaacc * costheta / self.total_mass
+        x = x + self.tau * x_dot
+        x_dot = x_dot + self.tau * xacc
+        theta = theta + self.tau * theta_dot
+        theta_dot = theta_dot + self.tau * thetaacc
+        self.state = (x, x_dot, theta, theta_dot)
+        '''
+        done = x < -self.x_threshold \
+            or x > self.x_threshold \
+            or theta < -self.theta_threshold_radians \
+            or theta > self.theta_threshold_radians
+        done = bool(done)
+
+        if not done:
+            reward = 1.0
+        elif self.steps_beyond_done is None:
+            # Pole just fell!
+            self.steps_beyond_done = 0
+            reward = 1.0
+        else:
+            if self.steps_beyond_done == 0:
+                logger.warning("You are calling 'step()' even though this environment has already returned done = True. You should always call 'reset()' once you receive 'done = True' -- any further steps are undefined behavior.")
+            self.steps_beyond_done += 1
+            reward = 0.0
+        '''
+        done = False
+        self.steps_beyond_done = None
+
+        return np.array(self.state), reward, done, {}
+
+    def _reset(self):
+        self.state = self.np_random.uniform(low=-0.05, high=0.05, size=(4,))
+        self.steps_beyond_done = None
+        return np.array(self.state)
+
+    def _render(self, mode='human', close=False):
+        if close:
+            if self.viewer is not None:
+                self.viewer.close()
+                self.viewer = None
+            return
+
+        screen_width = 600
+        screen_height = 400
+
+        world_width = self.x_threshold * 2
+        scale = screen_width / world_width
+        carty = 100  # TOP OF CART
+        polewidth = 10.0
+        polelen = scale * 1.0
+        cartwidth = 50.0
+        cartheight = 30.0
+
+        if self.viewer is None:
+            from gym.envs.classic_control import rendering
+            self.viewer = rendering.Viewer(screen_width, screen_height)
+            l, r, t, b = -cartwidth / 2, cartwidth / 2, cartheight / 2, -cartheight / 2
+            axleoffset = cartheight / 4.0
+            cart = rendering.FilledPolygon([(l, b), (l, t), (r, t), (r, b)])
+            self.carttrans = rendering.Transform()
+            cart.add_attr(self.carttrans)
+            self.viewer.add_geom(cart)
+            l, r, t, b = -polewidth / 2, polewidth / 2, polelen - polewidth / 2, -polewidth / 2
+            pole = rendering.FilledPolygon([(l, b), (l, t), (r, t), (r, b)])
+            pole.set_color(.8, .6, .4)
+            self.poletrans = rendering.Transform(translation=(0, axleoffset))
+            pole.add_attr(self.poletrans)
+            pole.add_attr(self.carttrans)
+            self.viewer.add_geom(pole)
+            self.axle = rendering.make_circle(polewidth / 2)
+            self.axle.add_attr(self.poletrans)
+            self.axle.add_attr(self.carttrans)
+            self.axle.set_color(.5, .5, .8)
+            self.viewer.add_geom(self.axle)
+            self.track = rendering.Line((0, carty), (screen_width, carty))
+            self.track.set_color(0, 0, 0)
+            self.viewer.add_geom(self.track)
+
+        if self.state is None:
+            return None
+
+        x = self.state
+        cartx = x[0] * scale + screen_width / 2.0  # MIDDLE OF CART
+        self.carttrans.set_translation(cartx, carty)
+        self.poletrans.set_rotation(-x[2])
+
+        return self.viewer.render(return_rgb_array=(mode == 'rgb_array'))
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        x = obs[:, 0]
+        theta = obs[:, 2]
+        return -(np.cos(theta) - 0.01 * (x ** 2))
+
+    def verify(self, n=2000, eps=1e-4):
+        dataset = Dataset(gen_dtype(self, 'state action next_state reward done'), n)
+        state = self.reset()
+        for _ in range(n):
+            action = self.action_space.sample()
+            next_state, reward, done, _ = self.step(action)
+            dataset.append((state, action, next_state, reward, done))
+
+            state = next_state
+            if done:
+                state = self.reset()
+
+        rewards_, dones_ = self.mb_step(dataset.state, dataset.action, dataset.next_state)
+        diff = dataset.reward - rewards_
+        l_inf = np.abs(diff).max()
+        logger.info('rewarder difference: %.6f', l_inf)
+
+        assert np.allclose(dones_, dataset.done)
+        assert l_inf < eps
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cartpoleO001.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cartpoleO001.py
new file mode 100644
index 0000000..2407b55
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cartpoleO001.py
@@ -0,0 +1,178 @@
+"""
+Classic cart-pole system implemented by Rich Sutton et al.
+Copied from https://webdocs.cs.ualberta.ca/~sutton/book/code/pole.c
+"""
+
+import logging
+import math
+import gym
+from gym import spaces
+from gym.utils import seeding
+import numpy as np
+
+
+logger = logging.getLogger(__name__)
+
+
+class CartPoleEnv(gym.Env):
+    metadata = {
+        'render.modes': ['human', 'rgb_array'],
+        'video.frames_per_second': 50
+    }
+
+    def __init__(self):
+        self.gravity = 9.8
+        self.masscart = 1.0
+        self.masspole = 0.1
+        self.total_mass = (self.masspole + self.masscart)
+        self.length = 0.5  # actually half the pole's length
+        self.polemass_length = (self.masspole * self.length)
+        self.force_mag = 10.0
+        self.tau = 0.02  # seconds between state updates
+
+        # Angle at which to fail the episode
+        self.theta_threshold_radians = 12 * 2 * math.pi / 360
+        self.x_threshold = 2.4
+
+        # Angle limit set to 2 * theta_threshold_radians so failing observation is still within bounds
+        high = np.array([
+            self.x_threshold * 2,
+            np.finfo(np.float32).max,
+            self.theta_threshold_radians * 2,
+            np.finfo(np.float32).max])
+
+        # self.action_space = spaces.Discrete(2)
+        self.action_space = \
+            spaces.Box(low=np.array([-1.0]), high=np.array([1.0]))
+        self.observation_space = spaces.Box(-high, high)
+
+        self._seed()
+        self.viewer = None
+        self.state = None
+
+        self.steps_beyond_done = None
+
+    def _seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def _step(self, action):
+        action = 1 if action[0] > .0 else 0
+        # assert self.action_space.contains(action), "%r (%s) invalid" % (action, type(action))
+        state = self.state
+        obs = self.state
+        reward = np.cos(obs[2]) - 0.01 * (obs[0] ** 2)
+
+        x, x_dot, theta, theta_dot = state
+        force = self.force_mag if action == 1 else -self.force_mag
+        costheta = math.cos(theta)
+        sintheta = math.sin(theta)
+        temp = (force + self.polemass_length * theta_dot * theta_dot * sintheta) / self.total_mass
+        thetaacc = (self.gravity * sintheta - costheta * temp) / (self.length * (4.0 / 3.0 - self.masspole * costheta * costheta / self.total_mass))
+        xacc = temp - self.polemass_length * thetaacc * costheta / self.total_mass
+        x = x + self.tau * x_dot
+        x_dot = x_dot + self.tau * xacc
+        theta = theta + self.tau * theta_dot
+        theta_dot = theta_dot + self.tau * thetaacc
+        self.state = (x, x_dot, theta, theta_dot)
+        '''
+        done = x < -self.x_threshold \
+            or x > self.x_threshold \
+            or theta < -self.theta_threshold_radians \
+            or theta > self.theta_threshold_radians
+        done = bool(done)
+
+        if not done:
+            reward = 1.0
+        elif self.steps_beyond_done is None:
+            # Pole just fell!
+            self.steps_beyond_done = 0
+            reward = 1.0
+        else:
+            if self.steps_beyond_done == 0:
+                logger.warning("You are calling 'step()' even though this environment has already returned done = True. You should always call 'reset()' once you receive 'done = True' -- any further steps are undefined behavior.")
+            self.steps_beyond_done += 1
+            reward = 0.0
+        '''
+        done = False
+        self.steps_beyond_done = None
+
+        ob = np.array(self.state)
+        ob += np.random.uniform(low=-0.01, high=0.01, size=ob.shape)
+
+        return ob, reward, done, {}
+
+    def _reset(self):
+        self.state = self.np_random.uniform(low=-0.05, high=0.05, size=(4,))
+        self.steps_beyond_done = None
+        return np.array(self.state)
+
+    def _render(self, mode='human', close=False):
+        if close:
+            if self.viewer is not None:
+                self.viewer.close()
+                self.viewer = None
+            return
+
+        screen_width = 600
+        screen_height = 400
+
+        world_width = self.x_threshold * 2
+        scale = screen_width / world_width
+        carty = 100  # TOP OF CART
+        polewidth = 10.0
+        polelen = scale * 1.0
+        cartwidth = 50.0
+        cartheight = 30.0
+
+        if self.viewer is None:
+            from gym.envs.classic_control import rendering
+            self.viewer = rendering.Viewer(screen_width, screen_height)
+            l, r, t, b = -cartwidth / 2, cartwidth / 2, cartheight / 2, -cartheight / 2
+            axleoffset = cartheight / 4.0
+            cart = rendering.FilledPolygon([(l, b), (l, t), (r, t), (r, b)])
+            self.carttrans = rendering.Transform()
+            cart.add_attr(self.carttrans)
+            self.viewer.add_geom(cart)
+            l, r, t, b = -polewidth / 2, polewidth / 2, polelen - polewidth / 2, -polewidth / 2
+            pole = rendering.FilledPolygon([(l, b), (l, t), (r, t), (r, b)])
+            pole.set_color(.8, .6, .4)
+            self.poletrans = rendering.Transform(translation=(0, axleoffset))
+            pole.add_attr(self.poletrans)
+            pole.add_attr(self.carttrans)
+            self.viewer.add_geom(pole)
+            self.axle = rendering.make_circle(polewidth / 2)
+            self.axle.add_attr(self.poletrans)
+            self.axle.add_attr(self.carttrans)
+            self.axle.set_color(.5, .5, .8)
+            self.viewer.add_geom(self.axle)
+            self.track = rendering.Line((0, carty), (screen_width, carty))
+            self.track.set_color(0, 0, 0)
+            self.viewer.add_geom(self.track)
+
+        if self.state is None:
+            return None
+
+        x = self.state
+        cartx = x[0] * scale + screen_width / 2.0  # MIDDLE OF CART
+        self.carttrans.set_translation(cartx, carty)
+        self.poletrans.set_rotation(-x[2])
+
+        return self.viewer.render(return_rgb_array=(mode == 'rgb_array'))
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        x = obs[:, 0]
+        theta = obs[:, 2]
+        return -(np.cos(theta) - 0.01 * (x ** 2))
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cartpoleO01.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cartpoleO01.py
new file mode 100644
index 0000000..62516c3
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cartpoleO01.py
@@ -0,0 +1,177 @@
+"""
+Classic cart-pole system implemented by Rich Sutton et al.
+Copied from https://webdocs.cs.ualberta.ca/~sutton/book/code/pole.c
+"""
+
+import logging
+import math
+import gym
+from gym import spaces
+from gym.utils import seeding
+import numpy as np
+
+logger = logging.getLogger(__name__)
+
+
+class CartPoleEnv(gym.Env):
+    metadata = {
+        'render.modes': ['human', 'rgb_array'],
+        'video.frames_per_second': 50
+    }
+
+    def __init__(self):
+        self.gravity = 9.8
+        self.masscart = 1.0
+        self.masspole = 0.1
+        self.total_mass = (self.masspole + self.masscart)
+        self.length = 0.5  # actually half the pole's length
+        self.polemass_length = (self.masspole * self.length)
+        self.force_mag = 10.0
+        self.tau = 0.02  # seconds between state updates
+
+        # Angle at which to fail the episode
+        self.theta_threshold_radians = 12 * 2 * math.pi / 360
+        self.x_threshold = 2.4
+
+        # Angle limit set to 2 * theta_threshold_radians so failing observation is still within bounds
+        high = np.array([
+            self.x_threshold * 2,
+            np.finfo(np.float32).max,
+            self.theta_threshold_radians * 2,
+            np.finfo(np.float32).max])
+
+        # self.action_space = spaces.Discrete(2)
+        self.action_space = \
+            spaces.Box(low=np.array([-1.0]), high=np.array([1.0]))
+        self.observation_space = spaces.Box(-high, high)
+
+        self._seed()
+        self.viewer = None
+        self.state = None
+
+        self.steps_beyond_done = None
+
+    def _seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def _step(self, action):
+        action = 1 if action[0] > .0 else 0
+        # assert self.action_space.contains(action), "%r (%s) invalid" % (action, type(action))
+        state = self.state
+        obs = self.state
+        reward = np.cos(obs[2]) - 0.01 * (obs[0] ** 2)
+
+        x, x_dot, theta, theta_dot = state
+        force = self.force_mag if action == 1 else -self.force_mag
+        costheta = math.cos(theta)
+        sintheta = math.sin(theta)
+        temp = (force + self.polemass_length * theta_dot * theta_dot * sintheta) / self.total_mass
+        thetaacc = (self.gravity * sintheta - costheta * temp) / (self.length * (4.0 / 3.0 - self.masspole * costheta * costheta / self.total_mass))
+        xacc = temp - self.polemass_length * thetaacc * costheta / self.total_mass
+        x = x + self.tau * x_dot
+        x_dot = x_dot + self.tau * xacc
+        theta = theta + self.tau * theta_dot
+        theta_dot = theta_dot + self.tau * thetaacc
+        self.state = (x, x_dot, theta, theta_dot)
+        '''
+        done = x < -self.x_threshold \
+            or x > self.x_threshold \
+            or theta < -self.theta_threshold_radians \
+            or theta > self.theta_threshold_radians
+        done = bool(done)
+
+        if not done:
+            reward = 1.0
+        elif self.steps_beyond_done is None:
+            # Pole just fell!
+            self.steps_beyond_done = 0
+            reward = 1.0
+        else:
+            if self.steps_beyond_done == 0:
+                logger.warning("You are calling 'step()' even though this environment has already returned done = True. You should always call 'reset()' once you receive 'done = True' -- any further steps are undefined behavior.")
+            self.steps_beyond_done += 1
+            reward = 0.0
+        '''
+        done = False
+        self.steps_beyond_done = None
+
+        ob = np.array(self.state)
+        ob += np.random.uniform(low=-0.1, high=0.1, size=ob.shape)
+
+        return ob, reward, done, {}
+
+    def _reset(self):
+        self.state = self.np_random.uniform(low=-0.05, high=0.05, size=(4,))
+        self.steps_beyond_done = None
+        return np.array(self.state)
+
+    def _render(self, mode='human', close=False):
+        if close:
+            if self.viewer is not None:
+                self.viewer.close()
+                self.viewer = None
+            return
+
+        screen_width = 600
+        screen_height = 400
+
+        world_width = self.x_threshold * 2
+        scale = screen_width / world_width
+        carty = 100  # TOP OF CART
+        polewidth = 10.0
+        polelen = scale * 1.0
+        cartwidth = 50.0
+        cartheight = 30.0
+
+        if self.viewer is None:
+            from gym.envs.classic_control import rendering
+            self.viewer = rendering.Viewer(screen_width, screen_height)
+            l, r, t, b = -cartwidth / 2, cartwidth / 2, cartheight / 2, -cartheight / 2
+            axleoffset = cartheight / 4.0
+            cart = rendering.FilledPolygon([(l, b), (l, t), (r, t), (r, b)])
+            self.carttrans = rendering.Transform()
+            cart.add_attr(self.carttrans)
+            self.viewer.add_geom(cart)
+            l, r, t, b = -polewidth / 2, polewidth / 2, polelen - polewidth / 2, -polewidth / 2
+            pole = rendering.FilledPolygon([(l, b), (l, t), (r, t), (r, b)])
+            pole.set_color(.8, .6, .4)
+            self.poletrans = rendering.Transform(translation=(0, axleoffset))
+            pole.add_attr(self.poletrans)
+            pole.add_attr(self.carttrans)
+            self.viewer.add_geom(pole)
+            self.axle = rendering.make_circle(polewidth / 2)
+            self.axle.add_attr(self.poletrans)
+            self.axle.add_attr(self.carttrans)
+            self.axle.set_color(.5, .5, .8)
+            self.viewer.add_geom(self.axle)
+            self.track = rendering.Line((0, carty), (screen_width, carty))
+            self.track.set_color(0, 0, 0)
+            self.viewer.add_geom(self.track)
+
+        if self.state is None:
+            return None
+
+        x = self.state
+        cartx = x[0] * scale + screen_width / 2.0  # MIDDLE OF CART
+        self.carttrans.set_translation(cartx, carty)
+        self.poletrans.set_rotation(-x[2])
+
+        return self.viewer.render(return_rgb_array=(mode == 'rgb_array'))
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        x = obs[:, 0]
+        theta = obs[:, 2]
+        return -(np.cos(theta) - 0.01 * (x ** 2))
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahA003.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahA003.py
new file mode 100644
index 0000000..e759126
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahA003.py
@@ -0,0 +1,81 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from slbo.envs import BaseModelBasedEnv
+from gym.envs.mujoco import mujoco_env
+
+
+class HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=5):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/half_cheetah.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        action = np.array(action)
+        action += np.random.uniform(low=-0.03, high=0.03, size=action.shape)
+        start_ob = self._get_obs()
+        reward_run = start_ob[8]
+
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+        reward_ctrl = -0.1 * np.square(action).sum()
+
+        reward = reward_run + reward_ctrl
+        done = False
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat,
+        ])
+
+    def reset_model(self):
+        qpos = self.init_qpos + \
+            self.np_random.uniform(low=-.1, high=.1, size=self.model.nq)
+        qvel = self.init_qvel + self.np_random.randn(self.model.nv) * .1
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 8]
+        reward = reward_run + reward_ctrl
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahA01.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahA01.py
new file mode 100644
index 0000000..e496056
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahA01.py
@@ -0,0 +1,81 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=5):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/half_cheetah.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        action = np.array(action)
+        action += np.random.uniform(low=-0.1, high=0.1, size=action.shape)
+        start_ob = self._get_obs()
+        reward_run = start_ob[8]
+
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+        reward_ctrl = -0.1 * np.square(action).sum()
+
+        reward = reward_run + reward_ctrl
+        done = False
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat,
+        ])
+
+    def reset_model(self):
+        qpos = self.init_qpos + \
+            self.np_random.uniform(low=-.1, high=.1, size=self.model.nq)
+        qvel = self.init_qvel + self.np_random.randn(self.model.nv) * .1
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 8]
+        reward = reward_run + reward_ctrl
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahO001.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahO001.py
new file mode 100644
index 0000000..252505f
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahO001.py
@@ -0,0 +1,80 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=5):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/half_cheetah.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        start_ob = self._get_obs()
+        reward_run = start_ob[8]
+
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+        reward_ctrl = -0.1 * np.square(action).sum()
+
+        reward = reward_run + reward_ctrl
+        done = False
+        ob += np.random.uniform(low=-0.01, high=0.01, size=ob.shape)
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat,
+        ])
+
+    def reset_model(self):
+        qpos = self.init_qpos + \
+            self.np_random.uniform(low=-.1, high=.1, size=self.model.nq)
+        qvel = self.init_qvel + self.np_random.randn(self.model.nv) * .1
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 8]
+        reward = reward_run + reward_ctrl
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahO01.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahO01.py
new file mode 100644
index 0000000..4e6fe93
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_cheetahO01.py
@@ -0,0 +1,80 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=5):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/half_cheetah.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        start_ob = self._get_obs()
+        reward_run = start_ob[8]
+
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+        reward_ctrl = -0.1 * np.square(action).sum()
+
+        reward = reward_run + reward_ctrl
+        done = False
+        ob += np.random.uniform(low=-0.1, high=0.1, size=ob.shape)
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat,
+        ])
+
+    def reset_model(self):
+        qpos = self.init_qpos + \
+            self.np_random.uniform(low=-.1, high=.1, size=self.model.nq)
+        qvel = self.init_qvel + self.np_random.randn(self.model.nv) * .1
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 8]
+        reward = reward_run + reward_ctrl
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fant.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fant.py
new file mode 100644
index 0000000..29633e2
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fant.py
@@ -0,0 +1,84 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+
+from slbo.envs import BaseModelBasedEnv
+
+
+class AntEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=5):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/ant.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        old_ob = self._get_obs()
+        self.do_simulation(action, self.frame_skip)
+
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+        ob = self._get_obs()
+
+        reward_ctrl = -0.1 * np.square(action).sum()
+        reward_run = old_ob[13]
+        reward_height = -3.0 * np.square(old_ob[0] - 0.57)
+
+        # the alive bonus
+        height = ob[0]
+        done = (height > 1.0) or (height < 0.2)
+        alive_reward = float(not done)
+
+        reward = reward_run + reward_ctrl + reward_height + alive_reward
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[2:],
+            self.model.data.qvel.flat,
+        ])
+
+    def reset_model(self):
+        qpos = self.init_qpos + \
+            self.np_random.uniform(size=self.model.nq, low=-.1, high=.1)
+        qvel = self.init_qvel + self.np_random.randn(self.model.nv) * .1
+        self.set_state(qpos, qvel)
+        # self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 13]
+        reward_height = -3.0 * np.square(obs[:, 0] - 0.57)
+
+        height = next_obs[:, 0]
+        done = np.logical_or((height > 1.0), (height < 0.2))
+        alive_reward = 1.0 - np.array(done, dtype=np.float)
+
+        reward = reward_run + reward_ctrl + reward_height + alive_reward
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+
+    def mb_step(self, states, actions, next_states):
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        height = next_states[:, 0]
+        done = np.logical_or((height > 1.0), (height < 0.2))
+        return rewards, done
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fhopper.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fhopper.py
new file mode 100644
index 0000000..84edf3d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fhopper.py
@@ -0,0 +1,91 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class HopperEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=4):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/hopper.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        old_ob = self._get_obs()
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+
+        reward_ctrl = -0.1 * np.square(action).sum()
+        reward_run = old_ob[5]
+        reward_height = -3.0 * np.square(old_ob[0] - 1.3)
+        height, ang = ob[0], ob[1]
+        done = (height <= 0.7) or (abs(ang) >= 0.2)
+        alive_reward = float(not done)
+        reward = reward_run + reward_ctrl + reward_height + alive_reward
+
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat,
+        ])
+
+    def reset_model(self):
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-.005, high=.005, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-.005, high=.005, size=self.model.nv)
+        )
+        self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 2
+        self.viewer.cam.distance = self.model.stat.extent * 0.75
+        self.viewer.cam.lookat[2] += .8
+        self.viewer.cam.elevation = -20
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 5]
+        reward_height = -3.0 * np.square(obs[:, 0] - 1.3)
+        height, ang = next_obs[:, 0], next_obs[:, 1]
+        done = np.logical_or(height <= 0.7, abs(ang) >= 0.2)
+        alive_reward = 1.0 - np.array(done, dtype=np.float)
+        reward = reward_run + reward_ctrl + reward_height + alive_reward
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        # reward_height = -3.0 * tf.square(next_obs[:, 1] - 1.3)
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+        raise NotImplementedError
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        height, ang = next_states[:, 0], next_states[:, 1]
+        done = np.logical_or(height <= 0.7, abs(ang) >= 0.2)
+        return rewards, done
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fswimmer.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fswimmer.py
new file mode 100644
index 0000000..86bdc80
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fswimmer.py
@@ -0,0 +1,69 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+import os
+
+
+class fixedSwimmerEnv(mujoco_env.MujocoEnv, utils.EzPickle):
+
+    def __init__(self):
+        dir_path = os.path.dirname(os.path.realpath(__file__))
+        mujoco_env.MujocoEnv.__init__(self, '%s/assets/fixed_swimmer.xml' % dir_path, 4)
+        utils.EzPickle.__init__(self)
+
+    def _step(self, a):
+        ctrl_cost_coeff = 0.0001
+
+        """
+        xposbefore = self.model.data.qpos[0, 0]
+        self.do_simulation(a, self.frame_skip)
+        xposafter = self.model.data.qpos[0, 0]
+        """
+
+        self.xposbefore = self.model.data.site_xpos[0][0] / self.dt
+        self.do_simulation(a, self.frame_skip)
+        self.xposafter = self.model.data.site_xpos[0][0] / self.dt
+        self.pos_diff = self.xposafter - self.xposbefore
+
+        reward_fwd = self.xposafter - self.xposbefore
+        reward_ctrl = - ctrl_cost_coeff * np.square(a).sum()
+        reward = reward_fwd + reward_ctrl
+        ob = self._get_obs()
+        return ob, reward, False, dict(reward_fwd=reward_fwd, reward_ctrl=reward_ctrl)
+
+    def _get_obs(self):
+        qpos = self.model.data.qpos
+        qvel = self.model.data.qvel
+        return np.concatenate([qpos.flat[2:], qvel.flat, self.pos_diff.flat])
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def reset_model(self):
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-.1, high=.1, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-.1, high=.1, size=self.model.nv)
+        )
+        return self._get_obs()
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.0001 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, -1]
+        reward = reward_run + reward_ctrl
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fwalker2d.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fwalker2d.py
new file mode 100644
index 0000000..25006d3
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_fwalker2d.py
@@ -0,0 +1,99 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class Walker2dEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=4):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/walker2d.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        old_ob = self._get_obs()
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+
+        reward_ctrl = -0.1 * np.square(action).sum()
+        reward_run = old_ob[8]
+        reward_height = -3.0 * np.square(old_ob[0] - 1.3)
+
+        height, ang = ob[0], ob[1]
+        done = (height >= 2.0) or (height <= 0.8) or (abs(ang) >= 1.0)
+        alive_reward = float(not done)
+
+        reward = reward_run + reward_ctrl + reward_height + alive_reward
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat
+        ])
+
+    def reset_model(self):
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-.005, high=.005, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-.005, high=.005, size=self.model.nv)
+        )
+        self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 2
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+        self.viewer.cam.lookat[2] += .8
+        self.viewer.cam.elevation = -20
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 8]
+        reward_height = -3.0 * np.square(next_obs[:, 0] - 1.3)
+        height, ang = next_obs[:, 0], next_obs[:, 1]
+        done = np.logical_or(
+            np.logical_or(height >= 2.0, height <= 0.8),
+            np.abs(ang) >= 1.0
+        )
+        alive_reward = 1.0 - np.array(done, dtype=np.float)
+        reward = reward_run + reward_ctrl + reward_height + alive_reward
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        # reward_height = -3.0 * tf.square(next_obs[:, 1] - 1.3)
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+        raise NotImplementedError
+
+    def verify(self):
+        pass
+
+    def mb_step(self, states, actions, next_states):
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        height, ang = next_states[:, 0], next_states[:, 1]
+        done = np.logical_or(
+            np.logical_or(height >= 2.0, height <= 0.8),
+            np.abs(ang) >= 1.0
+        )
+        return rewards, done
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_humanoid.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_humanoid.py
new file mode 100644
index 0000000..7d220ba
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_humanoid.py
@@ -0,0 +1,89 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+import numpy as np
+from gym.envs.mujoco import mujoco_env
+from gym import utils
+from slbo.envs import BaseModelBasedEnv
+
+
+class HumanoidEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self):
+        mujoco_env.MujocoEnv.__init__(self, 'humanoid.xml', 5)
+        utils.EzPickle.__init__(self)
+
+    def _get_obs(self):
+        data = self.model.data
+        return np.concatenate([data.qpos.flat[2:],
+                               data.qvel.flat,
+                               data.cinert.flat,
+                               data.cvel.flat,
+                               data.qfrc_actuator.flat,
+                               data.cfrc_ext.flat])
+
+    def _step(self, a):
+        data = self.model.data
+        action = a
+        if getattr(self, 'action_space', None):
+            action = np.clip(a, self.action_space.low,
+                             self.action_space.high)
+
+        # reward
+        alive_bonus = 5.0
+        lin_vel_cost = 0.25 / 0.015 * data.qvel.flat[0]
+        quad_ctrl_cost = 0.1 * np.square(action).sum()
+        quad_impact_cost = .5e-6 * np.square(data.cfrc_ext).sum()
+        quad_impact_cost = min(quad_impact_cost, 10)
+
+        self.do_simulation(action, self.frame_skip)
+        reward = lin_vel_cost - quad_ctrl_cost - quad_impact_cost + alive_bonus
+        qpos = self.model.data.qpos
+        done = bool((qpos[2] < 1.0) or (qpos[2] > 2.0))
+        return self._get_obs(), reward, done, dict(reward_linvel=lin_vel_cost, reward_quadctrl=-quad_ctrl_cost, reward_alive=alive_bonus, reward_impact=-quad_impact_cost)
+
+    def reset_model(self):
+        c = 0.01
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-c, high=c, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-c, high=c, size=self.model.nv,)
+        )
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 1
+        self.viewer.cam.distance = self.model.stat.extent * 1.0
+        self.viewer.cam.lookat[2] += .8
+        self.viewer.cam.elevation = -20
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = 0.25 / 0.015 * obs[:, 22]
+
+        quad_impact_cost = .5e-6 * np.square(obs[:, -84:]).sum()
+        quad_impact_cost = min(quad_impact_cost, 10)
+
+        height = next_obs[:, 0]
+        done = np.logical_or((height > 2.0), (height < 1.0))
+        alive_reward = 5 * (1.0 - np.array(done, dtype=np.float))
+
+        reward = reward_run + reward_ctrl + (-quad_impact_cost) + alive_reward
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+
+        height = next_states[:, 0]
+        done = np.logical_or((height > 2.0), (height < 1.0))
+        return rewards, done
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_nostopslimhumanoid.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_nostopslimhumanoid.py
new file mode 100644
index 0000000..1c87b20
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_nostopslimhumanoid.py
@@ -0,0 +1,81 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+import numpy as np
+from gym.envs.mujoco import mujoco_env
+from gym import utils
+from slbo.envs import BaseModelBasedEnv
+
+
+class HumanoidEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self):
+        mujoco_env.MujocoEnv.__init__(self, 'humanoid.xml', 5)
+        utils.EzPickle.__init__(self)
+
+    def _get_obs(self):
+        data = self.model.data
+        return np.concatenate([data.qpos.flat[2:],
+                               data.qvel.flat])
+
+    def _step(self, a):
+        data = self.model.data
+        action = a
+        if getattr(self, 'action_space', None):
+            action = np.clip(a, self.action_space.low,
+                             self.action_space.high)
+        qpos = self.model.data.qpos
+        done = bool((qpos[2] < 1.0) or (qpos[2] > 2.0))
+
+        # reward
+        alive_bonus = 5 * (1 - float(done))
+        lin_vel_cost = 0.25 / 0.015 * data.qvel.flat[0]
+        quad_ctrl_cost = 0.1 * np.square(action).sum()
+        quad_impact_cost = 0.0
+
+        self.do_simulation(action, self.frame_skip)
+        reward = lin_vel_cost - quad_ctrl_cost - quad_impact_cost + alive_bonus
+        done = False
+        return self._get_obs(), reward, done, dict(reward_linvel=lin_vel_cost, reward_quadctrl=-quad_ctrl_cost, reward_alive=alive_bonus, reward_impact=-quad_impact_cost)
+
+    def reset_model(self):
+        c = 0.01
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-c, high=c, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-c, high=c, size=self.model.nv,)
+        )
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 1
+        self.viewer.cam.distance = self.model.stat.extent * 1.0
+        self.viewer.cam.lookat[2] += .8
+        self.viewer.cam.elevation = -20
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = 0.25 / 0.015 * obs[:, 22]
+
+        quad_impact_cost = 0.0
+
+        height = next_obs[:, 0]
+        done = np.logical_or((height > 2.0), (height < 1.0))
+        alive_reward = 5 * (1.0 - np.array(done, dtype=np.float))
+
+        reward = reward_run + reward_ctrl + (-quad_impact_cost) + alive_reward
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_pendulumO001.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_pendulumO001.py
new file mode 100644
index 0000000..de873df
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_pendulumO001.py
@@ -0,0 +1,138 @@
+import gym
+from gym import spaces
+from gym.utils import seeding
+import numpy as np
+from os import path
+
+
+class PendulumEnv(gym.Env):
+    metadata = {
+        'render.modes': ['human', 'rgb_array'],
+        'video.frames_per_second': 30
+    }
+
+    def __init__(self):
+        self.max_speed = 8
+        self.max_torque = 2.
+        self.dt = .05
+        self.viewer = None
+
+        high = np.array([1., 1., self.max_speed])
+        self.action_space = spaces.Box(low=-self.max_torque, high=self.max_torque, shape=(1,))
+        self.observation_space = spaces.Box(low=-high, high=high)
+
+        self._seed()
+
+    def _seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def _step(self, u):
+        th, thdot = self.state  # th := theta
+        '''
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+        '''
+
+        # for the reward
+        y, x, thetadot = np.cos(th), np.sin(th), thdot
+        u = np.clip(u, -self.max_torque, self.max_torque)[0]
+        costs = y + .1 * np.abs(x) + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        reward = -costs
+
+        g = 10.
+        m = 1.
+        l = 1.
+        dt = self.dt
+
+        self.last_u = u  # for rendering
+        # costs = angle_normalize(th) ** 2 + .1 * thdot ** 2 + .001 * (u ** 2)
+
+        newthdot = thdot + (-3 * g / (2 * l) * np.sin(th + np.pi) + 3. / (m * l ** 2) * u) * dt
+        newth = th + newthdot * dt
+        newthdot = np.clip(newthdot, -self.max_speed, self.max_speed)  # pylint: disable=E1111
+
+        self.state = np.array([newth, newthdot])
+        ob = self._get_obs()
+        ob += np.random.uniform(low=-0.01, high=0.01, size=ob.shape)
+        return ob, reward, False, {}
+
+    def _reset(self):
+        high = np.array([np.pi, 1])
+        self.state = self.np_random.uniform(low=-high, high=high)
+        self.last_u = None
+        return self._get_obs()
+
+    def _get_obs(self):
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+
+    def _render(self, mode='human', close=False):
+        if close:
+            if self.viewer is not None:
+                self.viewer.close()
+                self.viewer = None
+            return
+
+        if self.viewer is None:
+            from gym.envs.classic_control import rendering
+            self.viewer = rendering.Viewer(500, 500)
+            self.viewer.set_bounds(-2.2, 2.2, -2.2, 2.2)
+            rod = rendering.make_capsule(1, .2)
+            rod.set_color(.8, .3, .3)
+            self.pole_transform = rendering.Transform()
+            rod.add_attr(self.pole_transform)
+            self.viewer.add_geom(rod)
+            axle = rendering.make_circle(.05)
+            axle.set_color(0, 0, 0)
+            self.viewer.add_geom(axle)
+            fname = path.join(path.dirname(__file__), "assets/clockwise.png")
+            self.img = rendering.Image(fname, 1., 1.)
+            self.imgtrans = rendering.Transform()
+            self.img.add_attr(self.imgtrans)
+
+        self.viewer.add_onetime(self.img)
+        self.pole_transform.set_rotation(self.state[0] + np.pi / 2)
+        if self.last_u:
+            self.imgtrans.scale = (-self.last_u / 2, np.abs(self.last_u) / 2)
+
+        return self.viewer.render(return_rgb_array=(mode == 'rgb_array'))
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        """
+        dist_vec = obs[:, -3:]
+        reward_dist = - np.linalg.norm(dist_vec, axis=1)
+        reward_ctrl = - np.sum(np.square(acts), axis=1)
+        reward = reward_dist + reward_ctrl
+
+        # for the reward
+        y, x, thetadot = np.cos(th), np.sin(th), thdot
+        u = np.clip(u, -self.max_torque, self.max_torque)[0]
+        costs = y + .1 * x + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        reward = -costs
+
+        def _get_obs(self):
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+
+        """
+        y, x, thetadot = obs[:, 0], obs[:, 1], obs[:, 2]
+        u = np.clip(acts[:, 0], -self.max_torque, self.max_torque)
+        costs = y + .1 * np.abs(x) + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        return costs
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
+
+
+def angle_normalize(x):
+    return (((x + np.pi) % (2 * np.pi)) - np.pi)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_pendulumO01.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_pendulumO01.py
new file mode 100644
index 0000000..dbd460d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_pendulumO01.py
@@ -0,0 +1,138 @@
+import gym
+from gym import spaces
+from gym.utils import seeding
+import numpy as np
+from os import path
+
+
+class PendulumEnv(gym.Env):
+    metadata = {
+        'render.modes': ['human', 'rgb_array'],
+        'video.frames_per_second': 30
+    }
+
+    def __init__(self):
+        self.max_speed = 8
+        self.max_torque = 2.
+        self.dt = .05
+        self.viewer = None
+
+        high = np.array([1., 1., self.max_speed])
+        self.action_space = spaces.Box(low=-self.max_torque, high=self.max_torque, shape=(1,))
+        self.observation_space = spaces.Box(low=-high, high=high)
+
+        self._seed()
+
+    def _seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def _step(self, u):
+        th, thdot = self.state  # th := theta
+        '''
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+        '''
+
+        # for the reward
+        y, x, thetadot = np.cos(th), np.sin(th), thdot
+        u = np.clip(u, -self.max_torque, self.max_torque)[0]
+        costs = y + .1 * np.abs(x) + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        reward = -costs
+
+        g = 10.
+        m = 1.
+        l = 1.
+        dt = self.dt
+
+        self.last_u = u  # for rendering
+        # costs = angle_normalize(th) ** 2 + .1 * thdot ** 2 + .001 * (u ** 2)
+
+        newthdot = thdot + (-3 * g / (2 * l) * np.sin(th + np.pi) + 3. / (m * l ** 2) * u) * dt
+        newth = th + newthdot * dt
+        newthdot = np.clip(newthdot, -self.max_speed, self.max_speed)  # pylint: disable=E1111
+
+        self.state = np.array([newth, newthdot])
+        ob = self._get_obs()
+        ob += np.random.uniform(low=-0.1, high=0.1, size=ob.shape)
+        return ob, reward, False, {}
+
+    def _reset(self):
+        high = np.array([np.pi, 1])
+        self.state = self.np_random.uniform(low=-high, high=high)
+        self.last_u = None
+        return self._get_obs()
+
+    def _get_obs(self):
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+
+    def _render(self, mode='human', close=False):
+        if close:
+            if self.viewer is not None:
+                self.viewer.close()
+                self.viewer = None
+            return
+
+        if self.viewer is None:
+            from gym.envs.classic_control import rendering
+            self.viewer = rendering.Viewer(500, 500)
+            self.viewer.set_bounds(-2.2, 2.2, -2.2, 2.2)
+            rod = rendering.make_capsule(1, .2)
+            rod.set_color(.8, .3, .3)
+            self.pole_transform = rendering.Transform()
+            rod.add_attr(self.pole_transform)
+            self.viewer.add_geom(rod)
+            axle = rendering.make_circle(.05)
+            axle.set_color(0, 0, 0)
+            self.viewer.add_geom(axle)
+            fname = path.join(path.dirname(__file__), "assets/clockwise.png")
+            self.img = rendering.Image(fname, 1., 1.)
+            self.imgtrans = rendering.Transform()
+            self.img.add_attr(self.imgtrans)
+
+        self.viewer.add_onetime(self.img)
+        self.pole_transform.set_rotation(self.state[0] + np.pi / 2)
+        if self.last_u:
+            self.imgtrans.scale = (-self.last_u / 2, np.abs(self.last_u) / 2)
+
+        return self.viewer.render(return_rgb_array=(mode == 'rgb_array'))
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        """
+        dist_vec = obs[:, -3:]
+        reward_dist = - np.linalg.norm(dist_vec, axis=1)
+        reward_ctrl = - np.sum(np.square(acts), axis=1)
+        reward = reward_dist + reward_ctrl
+
+        # for the reward
+        y, x, thetadot = np.cos(th), np.sin(th), thdot
+        u = np.clip(u, -self.max_torque, self.max_torque)[0]
+        costs = y + .1 * x + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        reward = -costs
+
+        def _get_obs(self):
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+
+        """
+        y, x, thetadot = obs[:, 0], obs[:, 1], obs[:, 2]
+        u = np.clip(acts[:, 0], -self.max_torque, self.max_torque)
+        costs = y + .1 * np.abs(x) + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        return costs
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
+
+
+def angle_normalize(x):
+    return (((x + np.pi) % (2 * np.pi)) - np.pi)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_slimhumanoid.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_slimhumanoid.py
new file mode 100644
index 0000000..cfaf6ad
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/gym_slimhumanoid.py
@@ -0,0 +1,82 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+import numpy as np
+from gym.envs.mujoco import mujoco_env
+from gym import utils
+from slbo.envs import BaseModelBasedEnv
+
+
+class HumanoidEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self):
+        mujoco_env.MujocoEnv.__init__(self, 'humanoid.xml', 5)
+        utils.EzPickle.__init__(self)
+
+    def _get_obs(self):
+        data = self.model.data
+        return np.concatenate([data.qpos.flat[2:],
+                               data.qvel.flat])
+
+    def _step(self, a):
+        data = self.model.data
+        action = a
+        if getattr(self, 'action_space', None):
+            action = np.clip(a, self.action_space.low,
+                             self.action_space.high)
+
+        # reward
+        alive_bonus = 5.0
+        lin_vel_cost = 0.25 / 0.015 * data.qvel.flat[0]
+        quad_ctrl_cost = 0.1 * np.square(action).sum()
+        quad_impact_cost = 0.0
+
+        self.do_simulation(action, self.frame_skip)
+        reward = lin_vel_cost - quad_ctrl_cost - quad_impact_cost + alive_bonus
+        qpos = self.model.data.qpos
+        done = bool((qpos[2] < 1.0) or (qpos[2] > 2.0))
+        return self._get_obs(), reward, done, dict(reward_linvel=lin_vel_cost, reward_quadctrl=-quad_ctrl_cost, reward_alive=alive_bonus, reward_impact=-quad_impact_cost)
+
+    def reset_model(self):
+        c = 0.01
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-c, high=c, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-c, high=c, size=self.model.nv,)
+        )
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 1
+        self.viewer.cam.distance = self.model.stat.extent * 1.0
+        self.viewer.cam.lookat[2] += .8
+        self.viewer.cam.elevation = -20
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = 0.25 / 0.015 * obs[:, 22]
+
+        quad_impact_cost = 0.0
+
+        height = next_obs[:, 0]
+        done = np.logical_or((height > 2.0), (height < 1.0))
+        alive_reward = 5 * (1.0 - np.array(done, dtype=np.float))
+
+        reward = reward_run + reward_ctrl + (-quad_impact_cost) + alive_reward
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        height = next_states[:, 0]
+        done = np.logical_or((height > 2.0), (height < 1.0))
+        return rewards, done
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/half_cheetah.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/half_cheetah.py
new file mode 100644
index 0000000..97be1c5
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/half_cheetah.py
@@ -0,0 +1,76 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=5):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/half_cheetah.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        start_ob = self._get_obs()
+        reward_run = start_ob[8]
+
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+        reward_ctrl = -0.1 * np.square(action).sum()
+
+        reward = reward_run + reward_ctrl
+        done = False
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat,
+        ])
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                             self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def reset_model(self):
+        qpos = self.init_qpos + \
+            self.np_random.uniform(low=-.1, high=.1, size=self.model.nq)
+        qvel = self.init_qvel + self.np_random.randn(self.model.nv) * .1
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 8]
+        reward = reward_run + reward_ctrl
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        raise NotImplementedError
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/hopper.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/hopper.py
new file mode 100644
index 0000000..bb2f509
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/hopper.py
@@ -0,0 +1,84 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class HopperEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=4):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/hopper.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        old_ob = self._get_obs()
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+
+        reward_ctrl = -0.1 * np.square(action).sum()
+        reward_run = old_ob[5]
+        reward_height = -3.0 * np.square(old_ob[0] - 1.3)
+        reward = reward_run + reward_ctrl + reward_height + 1.0
+
+        done = False
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat,
+        ])
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def reset_model(self):
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-.005, high=.005, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-.005, high=.005, size=self.model.nv)
+        )
+        self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 2
+        self.viewer.cam.distance = self.model.stat.extent * 0.75
+        self.viewer.cam.lookat[2] += .8
+        self.viewer.cam.elevation = -20
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 5]
+        reward_height = -3.0 * np.square(obs[:, 0] - 1.3)
+        reward = reward_run + reward_ctrl + reward_height + 1.0
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        # reward_height = -3.0 * tf.square(next_obs[:, 1] - 1.3)
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+        raise NotImplementedError
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/inverted_pendulum.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/inverted_pendulum.py
new file mode 100644
index 0000000..f05af7b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/inverted_pendulum.py
@@ -0,0 +1,74 @@
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.utils.dataset import Dataset, gen_dtype
+from lunzi.Logger import logger
+
+
+class InvertedPendulumEnv(mujoco_env.MujocoEnv, utils.EzPickle):
+
+    def __init__(self):
+        utils.EzPickle.__init__(self)
+        mujoco_env.MujocoEnv.__init__(self, 'inverted_pendulum.xml', 2)
+
+    def _step(self, a):
+        # reward = 1.0
+        reward = self._get_reward()
+        self.do_simulation(a, self.frame_skip)
+        ob = self._get_obs()
+        # notdone = np.isfinite(ob).all() and (np.abs(ob[1]) <= .2)
+        # done = not notdone
+        done = False
+        return ob, reward, done, {}
+
+    def reset_model(self):
+        qpos = self.init_qpos + self.np_random.uniform(size=self.model.nq, low=-0.01, high=0.01)
+        qvel = self.init_qvel + self.np_random.uniform(size=self.model.nv, low=-0.01, high=0.01)
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def _get_reward(self):
+        old_ob = self._get_obs()
+        reward = -((old_ob[1]) ** 2)
+        return reward
+
+    def _get_obs(self):
+        return np.concatenate([self.model.data.qpos, self.model.data.qvel]).ravel()
+
+    def viewer_setup(self):
+        v = self.viewer
+        v.cam.trackbodyid = 0
+        v.cam.distance = v.model.stat.extent
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        return ((obs[:, 1]) ** 2)
+
+    def verify(self, n=2000, eps=1e-4):
+        dataset = Dataset(gen_dtype(self, 'state action next_state reward done'), n)
+        state = self.reset()
+        for _ in range(n):
+            action = self.action_space.sample()
+            next_state, reward, done, _ = self.step(action)
+            dataset.append((state, action, next_state, reward, done))
+
+            state = next_state
+            if done:
+                state = self.reset()
+
+        rewards_, dones_ = self.mb_step(dataset.state, dataset.action, dataset.next_state)
+        diff = dataset.reward - rewards_
+        l_inf = np.abs(diff).max()
+        logger.info('rewarder difference: %.6f', l_inf)
+
+        assert np.allclose(dones_, dataset.done)
+        assert l_inf < eps
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/mountain_car.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/mountain_car.py
new file mode 100644
index 0000000..01ed157
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/mountain_car.py
@@ -0,0 +1,199 @@
+# -*- coding: utf-8 -*-
+"""
+@author: Olivier Sigaud
+A merge between two sources:
+* Adaptation of the MountainCar Environment from the "FAReinforcement" library
+of Jose Antonio Martin H. (version 1.0), adapted by  'Tom Schaul, tom@idsia.ch'
+and then modified by Arnaud de Broissia
+* the OpenAI/gym MountainCar environment
+itself from
+https://webdocs.cs.ualberta.ca/~sutton/MountainCar/MountainCar1.cp
+"""
+
+import math
+import gym
+from gym import spaces
+from gym.utils import seeding
+import numpy as np
+from slbo.utils.dataset import Dataset, gen_dtype
+from lunzi.Logger import logger
+
+
+class Continuous_MountainCarEnv(gym.Env):
+    metadata = {
+        'render.modes': ['human', 'rgb_array'],
+        'video.frames_per_second': 30
+    }
+
+    def __init__(self):
+        self.min_action = -1.0
+        self.max_action = 1.0
+        self.min_position = -1.2
+        self.max_position = 0.6
+        self.max_speed = 0.07
+        self.goal_position = 0.45  # was 0.5 in gym, 0.45 in Arnaud de Broissia's version
+        self.power = 0.0015
+
+        self.low_state = np.array([self.min_position, -self.max_speed])
+        self.high_state = np.array([self.max_position, self.max_speed])
+
+        self.viewer = None
+
+        self.action_space = spaces.Box(self.min_action, self.max_action, shape=(1,))
+        self.observation_space = spaces.Box(self.low_state, self.high_state)
+
+        self._seed()
+        self.reset()
+
+    def _seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def _step(self, action):
+
+        position = self.state[0]
+        velocity = self.state[1]
+        force = min(max(action[0], -1.0), 1.0)
+        #reward = position
+
+        velocity += force * self.power - 0.0025 * math.cos(3 * position)
+        if (velocity > self.max_speed):
+            velocity = self.max_speed
+        if (velocity < -self.max_speed):
+            velocity = -self.max_speed
+        position += velocity
+        if (position > self.max_position):
+            position = self.max_position
+        if (position < self.min_position):
+            position = self.min_position
+        if (position == self.min_position and velocity < 0):
+            velocity = 0
+
+
+        done = bool(position >= self.goal_position)
+
+        reward = 0
+        if done:
+            reward = 100.0
+        reward -= math.pow(action[0], 2) * 0.1
+
+
+        #done = False
+        self.state = np.array([position, velocity])
+        return self.state, reward, done, {}
+
+    def _reset(self):
+        self.state = np.array([self.np_random.uniform(low=-0.6, high=-0.4), 0])
+        return np.array(self.state)
+
+#    def get_state(self):
+#        return self.state
+
+    def _height(self, xs):
+        return np.sin(3 * xs) * .45 + .55
+
+    def _render(self, mode='human', close=False):
+        if close:
+            if self.viewer is not None:
+                self.viewer.close()
+                self.viewer = None
+            return
+
+        screen_width = 600
+        screen_height = 400
+
+        world_width = self.max_position - self.min_position
+        scale = screen_width / world_width
+        carwidth = 40
+        carheight = 20
+
+        if self.viewer is None:
+            from gym.envs.classic_control import rendering
+            self.viewer = rendering.Viewer(screen_width, screen_height)
+            xs = np.linspace(self.min_position, self.max_position, 100)
+            ys = self._height(xs)
+            xys = list(zip((xs - self.min_position) * scale, ys * scale))
+
+            self.track = rendering.make_polyline(xys)
+            self.track.set_linewidth(4)
+            self.viewer.add_geom(self.track)
+
+            clearance = 10
+
+            l, r, t, b = -carwidth / 2, carwidth / 2, carheight, 0
+            car = rendering.FilledPolygon([(l, b), (l, t), (r, t), (r, b)])
+            car.add_attr(rendering.Transform(translation=(0, clearance)))
+            self.cartrans = rendering.Transform()
+            car.add_attr(self.cartrans)
+            self.viewer.add_geom(car)
+            frontwheel = rendering.make_circle(carheight / 2.5)
+            frontwheel.set_color(.5, .5, .5)
+            frontwheel.add_attr(rendering.Transform(translation=(carwidth / 4, clearance)))
+            frontwheel.add_attr(self.cartrans)
+            self.viewer.add_geom(frontwheel)
+            backwheel = rendering.make_circle(carheight / 2.5)
+            backwheel.add_attr(rendering.Transform(translation=(-carwidth / 4, clearance)))
+            backwheel.add_attr(self.cartrans)
+            backwheel.set_color(.5, .5, .5)
+            self.viewer.add_geom(backwheel)
+            flagx = (self.goal_position - self.min_position) * scale
+            flagy1 = self._height(self.goal_position) * scale
+            flagy2 = flagy1 + 50
+            flagpole = rendering.Line((flagx, flagy1), (flagx, flagy2))
+            self.viewer.add_geom(flagpole)
+            flag = rendering.FilledPolygon([(flagx, flagy2), (flagx, flagy2 - 10), (flagx + 25, flagy2 - 5)])
+            flag.set_color(.8, .8, 0)
+            self.viewer.add_geom(flag)
+
+        pos = self.state[0]
+        self.cartrans.set_translation((pos - self.min_position) * scale, self._height(pos) * scale)
+        self.cartrans.set_rotation(math.cos(3 * pos))
+
+        return self.viewer.render(return_rgb_array=(mode == 'rgb_array'))
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        dones = rewards > 0
+        return rewards, dones
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        """
+        position = self.state[0]
+        velocity = self.state[1]
+        force = min(max(action[0], -1.0), 1.0)
+        reward = position
+        """
+        positions = next_obs[:,0]
+        rewards = np.zeros(len(positions))
+        for i in range(len(rewards)):
+            if positions[i] >= self.goal_position:
+                rewards[i] = 100.0
+
+        rewards = rewards - np.power(acts[:,0], 2) * 0.1
+
+        return -rewards
+
+    def verify(self, n=2000, eps=1e-4):
+        dataset = Dataset(gen_dtype(self, 'state action next_state reward done'), n)
+        state = self.reset()
+        for _ in range(n):
+            action = self.action_space.sample()
+            next_state, reward, done, _ = self.step(action)
+            dataset.append((state, action, next_state, reward, done))
+
+            state = next_state
+            if done:
+                state = self.reset()
+
+        rewards_, dones_ = self.mb_step(dataset.state, dataset.action, dataset.next_state)
+        diff = dataset.reward - rewards_
+        l_inf = np.abs(diff).max()
+        logger.info('rewarder difference: %.6f', l_inf)
+
+        assert np.allclose(dones_, dataset.done)
+        assert l_inf < eps
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pendulum.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pendulum.py
new file mode 100644
index 0000000..a64b39c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pendulum.py
@@ -0,0 +1,155 @@
+import gym
+from gym import spaces
+from gym.utils import seeding
+import numpy as np
+from os import path
+from slbo.utils.dataset import Dataset, gen_dtype
+from lunzi.Logger import logger
+
+
+class PendulumEnv(gym.Env):
+    metadata = {
+        'render.modes': ['human', 'rgb_array'],
+        'video.frames_per_second': 30
+    }
+
+    def __init__(self):
+        self.max_speed = 8
+        self.max_torque = 2.
+        self.dt = .05
+        self.viewer = None
+
+        high = np.array([1., 1., self.max_speed])
+        self.action_space = spaces.Box(low=-self.max_torque, high=self.max_torque, shape=(1,))
+        self.observation_space = spaces.Box(low=-high, high=high)
+
+        self._seed()
+
+    def _seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def _step(self, u):
+        th, thdot = self.state  # th := theta
+        '''
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+        '''
+
+        # for the reward
+        y, x, thetadot = np.cos(th), np.sin(th), thdot
+        u = np.clip(u, -self.max_torque, self.max_torque)[0]
+        costs = y + .1 * np.abs(x) + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        reward = -costs
+
+        g = 10.
+        m = 1.
+        l = 1.
+        dt = self.dt
+
+        self.last_u = u  # for rendering
+        # costs = angle_normalize(th) ** 2 + .1 * thdot ** 2 + .001 * (u ** 2)
+
+        newthdot = thdot + (-3 * g / (2 * l) * np.sin(th + np.pi) + 3. / (m * l ** 2) * u) * dt
+        newth = th + newthdot * dt
+        newthdot = np.clip(newthdot, -self.max_speed, self.max_speed)  # pylint: disable=E1111
+
+        self.state = np.array([newth, newthdot])
+        return self._get_obs(), reward, False, {}
+
+    def _reset(self):
+        high = np.array([np.pi, 1])
+        self.state = self.np_random.uniform(low=-high, high=high)
+        self.last_u = None
+        return self._get_obs()
+
+    def _get_obs(self):
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+
+    def _render(self, mode='human', close=False):
+        if close:
+            if self.viewer is not None:
+                self.viewer.close()
+                self.viewer = None
+            return
+
+        if self.viewer is None:
+            from gym.envs.classic_control import rendering
+            self.viewer = rendering.Viewer(500, 500)
+            self.viewer.set_bounds(-2.2, 2.2, -2.2, 2.2)
+            rod = rendering.make_capsule(1, .2)
+            rod.set_color(.8, .3, .3)
+            self.pole_transform = rendering.Transform()
+            rod.add_attr(self.pole_transform)
+            self.viewer.add_geom(rod)
+            axle = rendering.make_circle(.05)
+            axle.set_color(0, 0, 0)
+            self.viewer.add_geom(axle)
+            fname = path.join(path.dirname(__file__), "assets/clockwise.png")
+            self.img = rendering.Image(fname, 1., 1.)
+            self.imgtrans = rendering.Transform()
+            self.img.add_attr(self.imgtrans)
+
+        self.viewer.add_onetime(self.img)
+        self.pole_transform.set_rotation(self.state[0] + np.pi / 2)
+        if self.last_u:
+            self.imgtrans.scale = (-self.last_u / 2, np.abs(self.last_u) / 2)
+
+        return self.viewer.render(return_rgb_array=(mode == 'rgb_array'))
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        """
+        dist_vec = obs[:, -3:]
+        reward_dist = - np.linalg.norm(dist_vec, axis=1)
+        reward_ctrl = - np.sum(np.square(acts), axis=1)
+        reward = reward_dist + reward_ctrl
+
+        # for the reward
+        y, x, thetadot = np.cos(th), np.sin(th), thdot
+        u = np.clip(u, -self.max_torque, self.max_torque)[0]
+        costs = y + .1 * x + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        reward = -costs
+
+        def _get_obs(self):
+        theta, thetadot = self.state
+        return np.array([np.cos(theta), np.sin(theta), thetadot])
+
+        """
+        y, x, thetadot = obs[:, 0], obs[:, 1], obs[:, 2]
+        u = np.clip(acts[:, 0], -self.max_torque, self.max_torque)
+        costs = y + .1 * np.abs(x) + .1 * (thetadot ** 2) + .001 * (u ** 2)
+        return costs
+
+    def verify(self, n=2000, eps=1e-4):
+        dataset = Dataset(gen_dtype(self, 'state action next_state reward done'), n)
+        state = self.reset()
+        for _ in range(n):
+            action = self.action_space.sample()
+            next_state, reward, done, _ = self.step(action)
+            dataset.append((state, action, next_state, reward, done))
+
+            state = next_state
+            if done:
+                state = self.reset()
+
+        rewards_, dones_ = self.mb_step(dataset.state, dataset.action, dataset.next_state)
+        diff = dataset.reward - rewards_
+        l_inf = np.abs(diff).max()
+        logger.info('rewarder difference: %.6f', l_inf)
+
+        assert np.allclose(dones_, dataset.done)
+        assert l_inf < eps
+
+
+def angle_normalize(x):
+    return (((x + np.pi) % (2 * np.pi)) - np.pi)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_cartpole.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_cartpole.py
new file mode 100644
index 0000000..a048535
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_cartpole.py
@@ -0,0 +1,53 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+
+
+class CartpoleEnv(mujoco_env.MujocoEnv, utils.EzPickle):
+    PENDULUM_LENGTH = 0.6
+
+    def __init__(self):
+        utils.EzPickle.__init__(self)
+        dir_path = os.path.dirname(os.path.realpath(__file__))
+        mujoco_env.MujocoEnv.__init__(self, '%s/assets/cartpole.xml' % dir_path, 2)
+
+    def _step(self, a):
+        self.do_simulation(a, self.frame_skip)
+        ob = self._get_obs()
+
+        cost_lscale = CartpoleEnv.PENDULUM_LENGTH
+        reward = np.exp(
+            -np.sum(np.square(self._get_ee_pos(ob) - np.array([0.0, CartpoleEnv.PENDULUM_LENGTH]))) / (cost_lscale ** 2)
+        )
+        reward -= 0.01 * np.sum(np.square(a))
+
+        done = False
+        return ob, reward, done, {}
+
+    def reset_model(self):
+        qpos = self.init_qpos + np.random.normal(0, 0.1, np.shape(self.init_qpos))
+        qvel = self.init_qvel + np.random.normal(0, 0.1, np.shape(self.init_qvel))
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def _get_obs(self):
+        return np.concatenate([self.model.data.qpos, self.model.data.qvel]).ravel()
+
+    @staticmethod
+    def _get_ee_pos(x):
+        x0, theta = x[0], x[1]
+        return np.array([
+            x0 - CartpoleEnv.PENDULUM_LENGTH * np.sin(theta),
+            -CartpoleEnv.PENDULUM_LENGTH * np.cos(theta)
+        ])
+
+    def viewer_setup(self):
+        v = self.viewer
+        v.cam.trackbodyid = 0
+        v.cam.distance = v.model.stat.extent
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_cheetah.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_cheetah.py
new file mode 100644
index 0000000..1f73b66
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_cheetah.py
@@ -0,0 +1,54 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+
+
+class HalfCheetahEnv(mujoco_env.MujocoEnv, utils.EzPickle):
+
+    def __init__(self):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.realpath(__file__))
+        mujoco_env.MujocoEnv.__init__(self, '%s/assets/half_cheetah.xml' % dir_path, 5)
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+
+        reward_ctrl = -0.1 * np.square(action).sum()
+        reward_run = ob[0] - 0.0 * np.square(ob[2])
+        reward = reward_run + reward_ctrl
+
+        done = False
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            (self.model.data.qpos.flat[:1] - self.prev_qpos[:1]) / self.dt,
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat,
+        ])
+
+    def reset_model(self):
+        qpos = self.init_qpos + np.random.normal(loc=0, scale=0.001, size=self.model.nq)
+        qvel = self.init_qvel + np.random.normal(loc=0, scale=0.001, size=self.model.nv)
+        self.set_state(qpos, qvel)
+        self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        return self._get_obs()
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 0]
+        reward = reward_run + reward_ctrl
+        return -reward
+
+    def viewer_setup(self):
+        self.viewer.cam.distance = self.model.stat.extent * 0.25
+        self.viewer.cam.elevation = -55
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_pusher.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_pusher.py
new file mode 100644
index 0000000..854f477
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_pusher.py
@@ -0,0 +1,85 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+
+
+class PusherEnv(mujoco_env.MujocoEnv, utils.EzPickle):
+
+    def __init__(self):
+        dir_path = os.path.dirname(os.path.realpath(__file__))
+        mujoco_env.MujocoEnv.__init__(self, '%s/assets/pusher.xml' % dir_path, 4)
+        utils.EzPickle.__init__(self)
+        self.reset_model()
+
+    def _step(self, a):
+        obj_pos = self.get_body_com("object"),
+        vec_1 = obj_pos - self.get_body_com("tips_arm")
+        vec_2 = obj_pos - self.get_body_com("goal")
+
+        reward_near = -np.sum(np.abs(vec_1))
+        reward_dist = -np.sum(np.abs(vec_2))
+        reward_ctrl = -np.square(a).sum()
+        reward = 1.25 * reward_dist + 0.1 * reward_ctrl + 0.5 * reward_near
+
+        self.do_simulation(a, self.frame_skip)
+        ob = self._get_obs()
+        done = False
+        return ob, reward, done, {}
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = -1
+        self.viewer.cam.distance = 4.0
+
+    def reset_model(self):
+        qpos = self.init_qpos
+
+        self.goal_pos = np.asarray([0, 0])
+        self.cylinder_pos = np.array([-0.25, 0.15]) + np.random.normal(0, 0.025, [2])
+
+        qpos[-4:-2] = self.cylinder_pos
+        qpos[-2:] = self.goal_pos
+        qvel = self.init_qvel + \
+            self.np_random.uniform(low=-0.005, high=0.005, size=self.model.nv)
+        qvel[-4:] = 0
+        self.set_state(qpos, qvel)
+        self.ac_goal_pos = self.get_body_com("goal")
+
+        return self._get_obs()
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[:7],
+            self.model.data.qvel.flat[:7],
+            self.get_body_com("tips_arm"),
+            self.get_body_com("object"),
+            self.get_body_com("goal"),
+        ])
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        """
+        to_w, og_w = 0.5, 1.25
+        tip_pos, obj_pos, goal_pos = obs[:, 14:17], obs[:, 17:20], obs[:, -3:]
+
+        tip_obj_dist = np.sum(np.abs(tip_pos - obj_pos), axis=1)
+        obj_goal_dist = np.sum(np.abs(goal_pos - obj_pos), axis=1)
+        return to_w * tip_obj_dist + og_w * obj_goal_dist
+
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 8]
+        reward = reward_run + reward_ctrl
+        """
+        to_w, og_w = 0.5, 1.25
+        tip_pos, obj_pos, goal_pos = obs[:, 14:17], obs[:, 17:20], obs[:, -3:]
+
+        tip_obj_dist = -np.sum(np.abs(tip_pos - obj_pos), axis=1)
+        obj_goal_dist = -np.sum(np.abs(goal_pos - obj_pos), axis=1)
+        ctrl_reward = -0.1 * np.sum(np.square(acts), axis=1)
+
+        reward = to_w * tip_obj_dist + og_w * obj_goal_dist + ctrl_reward
+        return -reward
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_reacher.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_reacher.py
new file mode 100644
index 0000000..ba419ac
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/pets_reacher.py
@@ -0,0 +1,95 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+
+
+class Reacher3DEnv(mujoco_env.MujocoEnv, utils.EzPickle):
+
+    def __init__(self):
+        self.viewer = None
+        utils.EzPickle.__init__(self)
+        dir_path = os.path.dirname(os.path.realpath(__file__))
+        self.goal = np.zeros(3)
+        mujoco_env.MujocoEnv.__init__(self, os.path.join(dir_path, 'assets/reacher3d.xml'), 2)
+
+    def _step(self, a):
+        self.do_simulation(a, self.frame_skip)
+        ob = self._get_obs()
+        reward = -np.sum(np.square(self.get_EE_pos(ob[None]) - self.goal))
+        reward -= 0.01 * np.square(a).sum()
+        done = False
+        return ob, reward, done, dict(reward_dist=0, reward_ctrl=0)
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 1
+        self.viewer.cam.distance = 2.5
+        self.viewer.cam.elevation = -30
+        self.viewer.cam.azimuth = 270
+
+    def reset_model(self):
+        qpos, qvel = np.copy(self.init_qpos), np.copy(self.init_qvel)
+        qpos[-3:] += np.random.normal(loc=0, scale=0.1, size=[3])
+        qvel[-3:] = 0
+        self.goal = qpos[-3:]
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def _get_obs(self):
+        raw_obs = np.concatenate([
+            self.model.data.qpos.flat, self.model.data.qvel.flat[:-3],
+        ])
+
+        EE_pos = np.reshape(self.get_EE_pos(raw_obs[None]), [-1])
+
+        return np.concatenate([raw_obs, EE_pos])
+
+    def get_EE_pos(self, states):
+        theta1, theta2, theta3, theta4, theta5, theta6, theta7 = \
+            states[:, :1], states[:, 1:2], states[:, 2:3], states[:, 3:4], states[:, 4:5], states[:, 5:6], states[:, 6:]
+
+        rot_axis = np.concatenate([np.cos(theta2) * np.cos(theta1), np.cos(theta2) * np.sin(theta1), -np.sin(theta2)],
+                                  axis=1)
+        rot_perp_axis = np.concatenate([-np.sin(theta1), np.cos(theta1), np.zeros(theta1.shape)], axis=1)
+        cur_end = np.concatenate([
+            0.1 * np.cos(theta1) + 0.4 * np.cos(theta1) * np.cos(theta2),
+            0.1 * np.sin(theta1) + 0.4 * np.sin(theta1) * np.cos(theta2) - 0.188,
+            -0.4 * np.sin(theta2)
+        ], axis=1)
+
+        for length, hinge, roll in [(0.321, theta4, theta3), (0.16828, theta6, theta5)]:
+            perp_all_axis = np.cross(rot_axis, rot_perp_axis)
+            x = np.cos(hinge) * rot_axis
+            y = np.sin(hinge) * np.sin(roll) * rot_perp_axis
+            z = -np.sin(hinge) * np.cos(roll) * perp_all_axis
+            new_rot_axis = x + y + z
+            new_rot_perp_axis = np.cross(new_rot_axis, rot_axis)
+            new_rot_perp_axis[np.linalg.norm(new_rot_perp_axis, axis=1) < 1e-30] = \
+                rot_perp_axis[np.linalg.norm(new_rot_perp_axis, axis=1) < 1e-30]
+            new_rot_perp_axis /= np.linalg.norm(new_rot_perp_axis, axis=1, keepdims=True)
+            rot_axis, rot_perp_axis, cur_end = new_rot_axis, new_rot_perp_axis, cur_end + length * new_rot_axis
+
+        return cur_end
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        """
+        def obs_cost_fn(self, obs):
+            self.ENV.goal = obs[:, 7: 10]
+            ee_pos = obs[:, -3:]
+            return np.sum(np.square(ee_pos - self.ENV.goal), axis=1)
+
+        @staticmethod
+        def ac_cost_fn(acs):
+            return 0.01 * np.sum(np.square(acs), axis=1)
+        """
+        reward_ctrl = -0.01 * np.sum(np.square(acts), axis=1)
+        goal = obs[:, 7: 10]
+        ee_pos = obs[:, -3:]
+
+        reward = -np.sum(np.square(ee_pos - goal), axis=1) + reward_ctrl
+        return -reward
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/reacher.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/reacher.py
new file mode 100644
index 0000000..636cdde
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/reacher.py
@@ -0,0 +1,66 @@
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class ReacherEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self):
+        utils.EzPickle.__init__(self)
+        mujoco_env.MujocoEnv.__init__(self, 'reacher.xml', 2)
+
+    def _step(self, a):
+        vec = self.get_body_com("fingertip") - self.get_body_com("target")
+
+        if getattr(self, 'action_space', None):
+            a = np.clip(a, self.action_space.low,
+                        self.action_space.high)
+        reward_dist = - np.linalg.norm(vec)
+        reward_ctrl = - np.square(a).sum()
+        reward = reward_dist + reward_ctrl
+        self.do_simulation(a, self.frame_skip)
+        ob = self._get_obs()
+        done = False
+        return ob, reward, done, dict(reward_dist=reward_dist, reward_ctrl=reward_ctrl)
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 0
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                             self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def reset_model(self):
+        qpos = self.np_random.uniform(low=-0.1, high=0.1, size=self.model.nq) + self.init_qpos
+        while True:
+            self.goal = self.np_random.uniform(low=-.2, high=.2, size=2)
+            if np.linalg.norm(self.goal) < 2:
+                break
+        qpos[-2:] = self.goal
+        qvel = self.init_qvel + self.np_random.uniform(low=-.005, high=.005, size=self.model.nv)
+        qvel[-2:] = 0
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def _get_obs(self):
+        theta = self.model.data.qpos.flat[:2]
+        return np.concatenate([
+            np.cos(theta),
+            np.sin(theta),
+            self.model.data.qpos.flat[2:],
+            self.model.data.qvel.flat[:2],
+            self.get_body_com("fingertip") - self.get_body_com("target")
+        ])
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        dist_vec = obs[:, -3:]
+        reward_dist = - np.linalg.norm(dist_vec, axis=1)
+        reward_ctrl = - np.sum(np.square(acts), axis=1)
+        reward = reward_dist + reward_ctrl
+        return -reward
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/readme.md b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/readme.md
new file mode 100644
index 0000000..28f84a0
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/readme.md
@@ -0,0 +1,5 @@
+# reference
+
+1. mbbl/env/gym_env/walker.py or mbbl/env/gym_env/reacher.py 
+
+2. https://github.com/openai/gym/blob/v0.7.4/gym/envs/mujoco/half_cheetah.py
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/swimmer.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/swimmer.py
new file mode 100644
index 0000000..33e8d79
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/swimmer.py
@@ -0,0 +1,77 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class SwimmerEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=4):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/swimmer.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        old_ob = self._get_obs()
+        self.do_simulation(action, self.frame_skip)
+
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+        ob = self._get_obs()
+
+        reward_ctrl = -0.0001 * np.square(action).sum()
+        reward_run = old_ob[3]
+        reward = reward_run + reward_ctrl
+
+        done = False
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            # (self.model.data.qpos.flat[:1] - self.prev_qpos[:1]) / self.dt,
+            # self.get_body_comvel("torso")[:1],
+            self.model.data.qpos.flat[2:],
+            self.model.data.qvel.flat,
+        ])
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                             self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def reset_model(self):
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-.1, high=.1, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-.1, high=.1, size=self.model.nv)
+        )
+        self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        return self._get_obs()
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.0001 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 3]
+        reward = reward_run + reward_ctrl
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        """
+        reward_ctrl = -0.0001 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+        raise NotImplementedError
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/walker2d.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/walker2d.py
new file mode 100644
index 0000000..1031b32
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym/walker2d.py
@@ -0,0 +1,84 @@
+from __future__ import division
+from __future__ import print_function
+from __future__ import absolute_import
+
+import os
+
+import numpy as np
+from gym import utils
+from gym.envs.mujoco import mujoco_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class Walker2dEnv(mujoco_env.MujocoEnv, utils.EzPickle, BaseModelBasedEnv):
+
+    def __init__(self, frame_skip=4):
+        self.prev_qpos = None
+        dir_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+        mujoco_env.MujocoEnv.__init__(
+            self, '%s/assets/walker2d.xml' % dir_path, frame_skip=frame_skip
+        )
+        utils.EzPickle.__init__(self)
+
+    def _step(self, action):
+        old_ob = self._get_obs()
+        self.do_simulation(action, self.frame_skip)
+        ob = self._get_obs()
+
+        if getattr(self, 'action_space', None):
+            action = np.clip(action, self.action_space.low,
+                             self.action_space.high)
+
+        reward_ctrl = -0.1 * np.square(action).sum()
+        reward_run = old_ob[8]
+        reward_height = -3.0 * np.square(old_ob[0] - 1.3)
+        reward = reward_run + reward_ctrl + reward_height + 1.0
+
+        done = False
+        return ob, reward, done, {}
+
+    def _get_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat[1:],
+            self.model.data.qvel.flat
+        ])
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        if getattr(self, 'action_space', None):
+            actions = np.clip(actions, self.action_space.low,
+                              self.action_space.high)
+        rewards = - self.cost_np_vec(states, actions, next_states)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def reset_model(self):
+        self.set_state(
+            self.init_qpos + self.np_random.uniform(low=-.005, high=.005, size=self.model.nq),
+            self.init_qvel + self.np_random.uniform(low=-.005, high=.005, size=self.model.nv)
+        )
+        self.prev_qpos = np.copy(self.model.data.qpos.flat)
+        return self._get_obs()
+
+    def viewer_setup(self):
+        self.viewer.cam.trackbodyid = 2
+        self.viewer.cam.distance = self.model.stat.extent * 0.5
+        self.viewer.cam.lookat[2] += .8
+        self.viewer.cam.elevation = -20
+
+    def cost_np_vec(self, obs, acts, next_obs):
+        reward_ctrl = -0.1 * np.sum(np.square(acts), axis=1)
+        reward_run = obs[:, 8]
+        reward_height = -3.0 * np.square(obs[:, 0] - 1.3)
+        reward = reward_run + reward_ctrl + reward_height + 1.0
+        return -reward
+
+    def cost_tf_vec(self, obs, acts, next_obs):
+        """
+        reward_ctrl = -0.1 * tf.reduce_sum(tf.square(acts), axis=1)
+        reward_run = next_obs[:, 0]
+        # reward_height = -3.0 * tf.square(next_obs[:, 1] - 1.3)
+        reward = reward_run + reward_ctrl
+        return -reward
+        """
+        raise NotImplementedError
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym_env.py
new file mode 100644
index 0000000..32b9434
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/gym_env.py
@@ -0,0 +1,141 @@
+# import gym
+# import gym.wrappers
+# import gym.envs
+# import gym.spaces
+# import traceback
+# import logging
+#
+# try:
+#     from gym.wrappers.monitoring import logger as monitor_logger
+#
+#     monitor_logger.setLevel(logging.WARNING)
+# except Exception as e:
+#     traceback.print_exc()
+#
+# import os
+# import numpy as np
+# from rllab.misc import logger
+#
+#
+# class CappedCubicVideoSchedule(object):
+#     # Copied from gym, since this method is frequently moved around
+#     def __call__(self, count):
+#         if count < 1000:
+#             return int(round(count ** (1. / 3))) ** 3 == count
+#         else:
+#             return count % 1000 == 0
+#
+#
+# class FixedIntervalVideoSchedule(object):
+#     def __init__(self, interval):
+#         self.interval = interval
+#
+#     def __call__(self, count):
+#         return count % self.interval == 0
+#
+#
+# class NoVideoSchedule(object):
+#     def __call__(self, count):
+#         return False
+#
+#
+# class GymEnv(object):
+#     def __init__(self, env_name, record_video=True, video_schedule=None, log_dir=None, record_log=True,
+#                  force_reset=False):
+#         if log_dir is None:
+#             if logger.get_snapshot_dir() is None:
+#                 logger.log("Warning: skipping Gym environment monitoring since snapshot_dir not configured.")
+#             else:
+#                 log_dir = os.path.join(logger.get_snapshot_dir(), "gym_log")
+#
+#         env = gym.make(env_name)
+#         self.env = env
+#         self.env_id = env.spec.id
+#
+#         assert not (not record_log and record_video)
+#
+#         if log_dir is None or record_log is False:
+#             self.monitoring = False
+#         else:
+#             if not record_video:
+#                 video_schedule = NoVideoSchedule()
+#             else:
+#                 if video_schedule is None:
+#                     video_schedule = CappedCubicVideoSchedule()
+#             self.env = gym.wrappers.Monitor(self.env, log_dir, video_callable=video_schedule, force=True)
+#             self.monitoring = True
+#
+#         self._observation_space = env.observation_space
+#         self._action_space = env.action_space
+#         self._horizon = env.spec.tags['wrapper_config.TimeLimit.max_episode_steps']
+#         self._log_dir = log_dir
+#         self._force_reset = force_reset
+#
+#         self.metadata = {'render.modes': ['human', 'rgb_array']}
+#         self.reward_range = (-np.inf, np.inf)
+#         self.unwrapped = self
+#         self._configured = False
+#         self.spec = None
+#
+#     @property
+#     def inner_env(self):
+#         env = self.env
+#         while hasattr(env, "env"):
+#             env = env.env
+#         return env
+#
+#     @property
+#     def observation_space(self):
+#         return self._observation_space
+#
+#     @property
+#     def action_space(self):
+#         return self._action_space
+#
+#     @property
+#     def horizon(self):
+#         return self._horizon
+#
+#     def reset(self):
+#         if self._force_reset and hasattr(self.env, 'stats_recorder'):
+#             recorder = self.env.stats_recorder
+#             if recorder is not None:
+#                 recorder.done = True
+#
+#         return self.env.reset()
+#
+#     def step(self, action_or_predicted_result):
+#         if isinstance(action_or_predicted_result, dict):
+#             return self._step_with_predicted_dynamics(**action_or_predicted_result)
+#         else:
+#             next_obs, reward, done, info = self.env.step(action_or_predicted_result)
+#             return next_obs, reward, done, info
+#
+#     def _step_with_predicted_dynamics(self, next_obs, reward, done):
+#         qpos = self.inner_env.model.data.qpos.flatten()
+#         qvel = self.inner_env.model.data.qvel.flatten()
+#         self.env.env.set_state(qpos, qvel)
+#         return next_obs, reward, done, {}
+#
+#     def cost_np_vec(self, obs, acts, next_obs):
+#         return self.env.env.cost_np_vec(obs, acts, next_obs)
+#
+#     def cost_tf_vec(self, obs, acts, next_obs):
+#         return self.env.env.cost_tf_vec(obs, acts, next_obs)
+#
+#     def render(self, **kwargs):
+#         return self.env.render(**kwargs)
+#
+#     def terminate(self):
+#         if self.monitoring:
+#             self.env._close()
+#             if self._log_dir is not None:
+#                 print("""
+#     ***************************
+#     Training finished! You can upload results to OpenAI Gym by running the following command:
+#     python scripts/submit_gym.py %s
+#     ***************************
+#                 """ % self._log_dir)
+#
+#     def get_geom_xpos(self):
+#         return self.inner_env.data.geom_xpos
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/neural_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/neural_env.py
new file mode 100644
index 0000000..243aa73
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/neural_env.py
@@ -0,0 +1,112 @@
+import numpy as np
+
+
+class NeuralNetEnv:
+
+    def __init__(self, env, inner_env, dynamics):
+        self.vectorized = True
+        self.env = env
+        self.inner_env = inner_env
+        self.is_done = getattr(inner_env, 'is_done', lambda x, y: np.asarray([False] * len(x)))
+        self.dynamics = dynamics
+
+    @property
+    def observation_space(self):
+        return self.env.observation_space
+
+    @property
+    def action_space(self):
+        return self.env.action_space
+
+    @property
+    def spec(self):
+        return self.env.spec
+
+    def reset(self):
+        self.state = self.env.reset()
+        observation = np.copy(self.state)
+        return observation
+
+    def step(self, action, use_states=None):
+        action = np.clip(action, *self.action_space.bounds)
+        if use_states is not None:
+            next_observation = self.dynamics.predict([use_states], [action])[0]
+            obs_dim = self.env.observation_space.shape[0]
+            next_observation[:obs_dim] = np.clip(next_observation[:obs_dim], *self.observation_space.bounds)
+            next_observation[:obs_dim] = np.clip(next_observation[:obs_dim], -1e5, 1e5)
+        else:
+            next_observation = self.dynamics.predict([self.state], [action])[0]
+            next_observation = np.clip(next_observation, *self.observation_space.bounds)
+            next_observation = np.clip(next_observation, -1e5, 1e5)
+
+        if hasattr(self.inner_env, "env"):
+            reward = - self.inner_env.env.cost_np_vec(self.state[None], action[None], np.array([next_observation]))[0]
+        else:
+            reward = - self.inner_env.cost_np_vec(self.state[None], action[None], np.array([next_observation]))[0]
+
+        done = self.is_done(self.state[None], next_observation)[0]
+        self.state = np.reshape(next_observation, -1)
+        return self.inner_env.step({"next_obs": next_observation, "reward": reward, "done": done})
+
+    def render(self):
+        print('current state:', self.state)
+
+    def vec_env_executor(self, n_envs, max_path_length):
+        return VecSimpleEnv(env=self, inner_env=self.inner_env, n_envs=n_envs, max_path_length=max_path_length)
+
+    def terminate(self):
+        self.env.terminate()
+
+
+class VecSimpleEnv(object):
+
+    def __init__(self, env, inner_env, n_envs, max_path_length):
+        self.env = env
+        self.inner_env = inner_env
+        self.n_envs = n_envs
+        self.num_envs = n_envs
+        self.ts = np.zeros((self.n_envs,))
+        self.max_path_length = max_path_length
+        self.obs_dim = env.observation_space.shape[0]
+        self.states = np.zeros((self.n_envs, self.obs_dim))
+
+    def reset(self, dones=None):
+        if dones is None:
+            dones = np.asarray([True] * self.n_envs)
+        else:
+            dones = np.cast['bool'](dones)
+        for i, done in enumerate(dones):
+            if done:
+                self.states[i] = self.env.reset()
+        self.ts[dones] = 0
+        return self.states[dones]
+
+    def step(self, actions, use_states=None):
+        self.ts += 1
+        actions = np.clip(actions, *self.env.action_space.bounds)
+        next_observations = self.get_next_observation(actions, use_states=use_states)
+        if use_states is not None:
+            obs_dim = self.env.observation_space.shape[0]
+            next_observations[:, :obs_dim] = np.clip(next_observations[:, :obs_dim], *self.env.observation_space.bounds)
+            next_observations[:, :obs_dim] = np.clip(next_observations[:, :obs_dim], -1e5, 1e5)
+        else:
+            next_observations = np.clip(next_observations, *self.env.observation_space.bounds)
+            next_observations = np.clip(next_observations, -1e5, 1e5)
+        if hasattr(self.env.inner_env, "cost_np_vec"):
+            rewards = - self.env.inner_env.cost_np_vec(self.states, actions, next_observations)
+        else:
+            rewards = - self.env.inner_env.env.cost_np_vec(self.states, actions, next_observations)
+        self.states = next_observations
+        dones = self.env.is_done(self.states, next_observations)
+        dones[self.ts >= self.max_path_length] = True
+        if np.any(dones):
+            self.reset(dones)
+        return self.states, rewards, dones, dict()
+
+    def get_next_observation(self, actions, use_states=None):
+        if use_states is not None:
+            return self.env.dynamics.predict(use_states, actions)
+        return self.env.dynamics.predict(self.states, actions)
+
+    def terminate(self):
+        self.env.terminate()
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/proxy_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/proxy_env.py
new file mode 100644
index 0000000..6381ab4
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/proxy_env.py
@@ -0,0 +1,89 @@
+from gym.core import Env
+from gym.spaces import Box as GymBox
+from gym.wrappers.monitoring import Monitor
+import numpy as np
+import tensorflow as tf
+
+
+class Box:
+
+    def __init__(self, gym_box: GymBox):
+        self.gym_box = gym_box
+
+    @property
+    def flat_dim(self):
+        return np.prod(self.gym_box.shape)
+
+    @property
+    def shape(self):
+        return self.gym_box.shape
+
+    @property
+    def dtype(self):
+        return tf.float32
+
+    @property
+    def bounds(self):
+        return self.gym_box.low, self.gym_box.high
+
+    def flatten_n(self, xs):
+        xs = np.asarray(xs)
+        return xs.reshape((xs.shape[0], -1))
+
+    def sample(self):
+        return self.gym_box.sample()
+
+    def flatten(self, x):
+        return np.asarray(x).flatten()
+
+    def __repr__(self):
+        return "Box Wrapper of shape {}".format(self.shape)
+
+    def __eq__(self, other):
+        return self.gym_box.__eq__(other)
+
+
+class ProxyEnv(Env):
+
+    def __init__(self, wrapped_env: Env):
+        self._wrapped_env = wrapped_env
+        self._wrapped_observation_space = Box(wrapped_env.observation_space)
+        self._wrapped_action_space = Box(wrapped_env.action_space)
+
+    @property
+    def wrapped_env(self):
+        return self._wrapped_env
+
+    def reset(self, **kwargs):
+        return self._wrapped_env.reset(**kwargs)
+
+    @property
+    def action_space(self):
+        return self._wrapped_action_space
+
+    @property
+    def observation_space(self):
+        return self._wrapped_observation_space
+
+    def step(self, action, **kwargs):
+        return self._wrapped_env.step(action, **kwargs)
+
+    def render(self, *args, **kwargs):
+        return self._wrapped_env.render(*args, **kwargs)
+
+    def log_diagnostics(self, paths, *args, **kwargs):
+        self._wrapped_env.log_diagnostics(paths, *args, **kwargs)
+
+    @property
+    def horizon(self):
+        return self._wrapped_env.horizon
+
+    def terminate(self):
+        if isinstance(self._wrapped_env, Monitor):
+            self._wrapped_env._close()
+
+    def get_param_values(self):
+        return self._wrapped_env.get_param_values()
+
+    def set_param_values(self, params):
+        self._wrapped_env.set_param_values(params)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/vec_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/vec_env.py
new file mode 100644
index 0000000..d0369e1
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/bm_envs/vec_env.py
@@ -0,0 +1,45 @@
+import numpy as np
+from libs.misc import tensor_utils
+
+
+class VecEnvExecutor(object):
+    def __init__(self, envs, max_path_length, **kwargs):
+        self.envs = envs
+        self._action_space = envs[0].action_space
+        self._observation_space = envs[0].observation_space
+        self.ts = np.zeros(len(self.envs), dtype='int')
+        self.max_path_length = max_path_length
+
+    def step(self, action_n, **kwargs):
+        all_results = [env.step(a) for (a, env) in zip(action_n, self.envs)]
+        obs, rewards, dones, env_infos = list(map(list, list(zip(*all_results))))
+        dones = np.asarray(dones)
+        rewards = np.asarray(rewards)
+        self.ts += 1
+        if self.max_path_length is not None:
+            dones[self.ts >= self.max_path_length] = True
+        for (i, done) in enumerate(dones):
+            if done:
+                obs[i] = self.envs[i].reset()
+                self.ts[i] = 0
+        return obs, rewards, dones, tensor_utils.stack_tensor_dict_list(env_infos)
+
+    def reset(self):
+        results = [env.reset() for env in self.envs]
+        self.ts[:] = 0
+        return results
+
+    @property
+    def num_envs(self):
+        return len(self.envs)
+
+    @property
+    def action_space(self):
+        return self._action_space
+
+    @property
+    def observation_space(self):
+        return self._observation_space
+
+    def terminate(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/__init__.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/__init__.py
new file mode 100644
index 0000000..5c7f19c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/__init__.py
@@ -0,0 +1 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/ant_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/ant_env.py
new file mode 100644
index 0000000..2a300af
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/ant_env.py
@@ -0,0 +1,50 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from rllab.envs.mujoco import ant_env
+from rllab.envs.base import Step
+from slbo.envs import BaseModelBasedEnv
+
+
+class AntEnv(ant_env.AntEnv, BaseModelBasedEnv):
+    def get_current_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat,  # 15
+            self.model.data.qvel.flat,  # 14
+            # np.clip(self.model.data.cfrc_ext, -1, 1).flat,  # 84
+            self.get_body_xmat("torso").flat,  # 9
+            self.get_body_com("torso"),  # 9
+            self.get_body_comvel("torso"),  # 3
+        ]).reshape(-1)
+
+    def step(self, action):
+        self.forward_dynamics(action)
+        comvel = self.get_body_comvel("torso")
+        forward_reward = comvel[0]
+        lb, ub = self.action_bounds
+        scaling = (ub - lb) * 0.5
+        ctrl_cost = 0.5 * 1e-2 * np.sum(np.square(action / scaling))
+        contact_cost = 0.
+        # contact_cost = 0.5 * 1e-3 * np.sum(
+        #     np.square(np.clip(self.model.data.cfrc_ext, -1, 1))),
+        survive_reward = 0.05
+        reward = forward_reward - ctrl_cost - contact_cost + survive_reward
+        state = self._state
+        notdone = np.isfinite(state).all() and state[2] >= 0.2 and state[2] <= 1.0
+        done = not notdone
+        ob = self.get_current_obs()
+        return Step(ob, float(reward), done)
+
+    def mb_step(self, states: np.ndarray, actions: np.ndarray, next_states: np.ndarray):
+        comvel = next_states[..., -3:]
+        forward_reward = comvel[..., 0]
+        lb, ub = self.action_bounds
+        scaling = (ub - lb) * 0.5
+        ctrl_cost = 0.5 * 1e-2 * np.sum(np.square(actions / scaling), axis=-1)
+        contact_cost = 0.
+        # contact_cost = 0.5 * 1e-3 * np.sum(
+        #     np.square(np.clip(self.model.data.cfrc_ext, -1, 1))),
+        survive_reward = 0.05
+        reward = forward_reward - ctrl_cost - contact_cost + survive_reward
+        notdone = np.all([next_states[..., 2] >= 0.2, next_states[..., 2] <= 1.0], axis=0)
+        return reward, 1. - notdone
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/half_cheetah_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/half_cheetah_env.py
new file mode 100644
index 0000000..29b1502
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/half_cheetah_env.py
@@ -0,0 +1,20 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from rllab.envs.mujoco import half_cheetah_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class HalfCheetahEnv(half_cheetah_env.HalfCheetahEnv, BaseModelBasedEnv):
+    def get_current_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat,  # 9
+            self.model.data.qvel.flat,  # 9
+            self.get_body_com("torso").flat,  # 3
+            self.get_body_comvel("torso").flat,  # 3
+        ])
+
+    def mb_step(self, states, actions, next_states):
+        actions = np.clip(actions, *self.action_bounds)
+        reward_ctrl = -0.05 * np.sum(np.square(actions), axis=-1)
+        reward_fwd = next_states[..., 21]
+        return reward_ctrl + reward_fwd, np.zeros_like(reward_fwd, dtype=np.bool)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/hopper_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/hopper_env.py
new file mode 100644
index 0000000..23c9c50
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/hopper_env.py
@@ -0,0 +1,26 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from rllab.envs.mujoco import hopper_env
+from rllab.envs.base import Step
+from slbo.envs import BaseModelBasedEnv
+
+
+class HopperEnv(hopper_env.HopperEnv, BaseModelBasedEnv):
+    def get_current_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat,  # 6
+            self.model.data.qvel.flat,  # 6
+            self.get_body_com("torso").flat,  # 3
+            self.get_body_comvel("torso"),  # 3
+        ])
+
+    def mb_step(self, states, actions, next_states):
+        lb, ub = self.action_bounds
+        scaling = (ub - lb) * 0.5
+        vel = next_states[:, -3]
+        reward = vel + self.alive_coeff - 0.5 * self.ctrl_cost_coeff * np.sum(np.square(actions / scaling), axis=-1)
+
+        done = ~((next_states[:, 3:12] < 100).all(axis=-1) &
+                 (next_states[:, 0] > 0.7) &
+                 (np.abs(next_states[:, 2]) < 0.2))
+        return reward, done
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/humanoid_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/humanoid_env.py
new file mode 100644
index 0000000..a5e55ae
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/humanoid_env.py
@@ -0,0 +1,53 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from rllab.envs.mujoco import simple_humanoid_env
+from rllab.envs.base import Step
+import numpy as np
+from slbo.envs import BaseModelBasedEnv
+
+
+class HumanoidEnv(simple_humanoid_env.SimpleHumanoidEnv, BaseModelBasedEnv):
+    def get_current_obs(self):
+        data = self.model.data
+        return np.concatenate([
+            data.qpos.flat,  # 17
+            data.qvel.flat,  # 16
+            self.get_body_com("torso").flat,  # 3
+            self.get_body_comvel("torso").flat,  # 3
+        ])
+
+    def step(self, action):
+        self.forward_dynamics(action)
+        alive_bonus = self.alive_bonus
+        data = self.model.data
+
+        comvel = self.get_body_comvel("torso")
+        lin_vel_reward = comvel[0]
+        lb, ub = self.action_bounds
+        scaling = (ub - lb) * 0.5
+        ctrl_cost = .5 * self.ctrl_cost_coeff * np.sum(
+            np.square(action / scaling))
+        impact_cost = 0.
+        vel_deviation_cost = 0.5 * self.vel_deviation_cost_coeff * np.sum(
+            np.square(comvel[1:]))
+        reward = lin_vel_reward + alive_bonus - ctrl_cost - \
+            impact_cost - vel_deviation_cost
+        pos = data.qpos.flat[2]
+        done = pos < 0.8 or pos > 2.0
+
+        next_obs = self.get_current_obs()
+        return Step(next_obs, reward, done)
+
+    def mb_step(self, states, actions, next_states):
+        lb, ub = self.action_bounds
+        scaling = (ub - lb) * 0.5
+
+        alive_bonus = 0.2
+        lin_vel_reward = next_states[:, 36]
+        ctrl_cost = 5.e-4 * np.square(actions / scaling).sum(axis=1)
+        impact_cost = 0.
+        vel_deviation_cost = 5.e-3 * np.square(next_states[:, 37:39]).sum(axis=1)
+        reward = lin_vel_reward + alive_bonus - ctrl_cost - impact_cost - vel_deviation_cost
+
+        dones = (next_states[:, 2] < 0.8) | (next_states[:, 2] > 2.0)
+        return reward, dones
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/swimmer_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/swimmer_env.py
new file mode 100644
index 0000000..f39bee4
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/swimmer_env.py
@@ -0,0 +1,22 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from rllab.envs.mujoco import swimmer_env
+from slbo.envs import BaseModelBasedEnv
+
+
+class SwimmerEnv(swimmer_env.SwimmerEnv, BaseModelBasedEnv):
+    def get_current_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat,  # 5
+            self.model.data.qvel.flat,  # 5
+            self.get_body_com("torso").flat,  # 3
+            self.get_body_comvel("torso"),  # 3
+        ]).reshape(-1)
+
+    def mb_step(self, states: np.ndarray, actions: np.ndarray, next_states: np.ndarray):
+        lb, ub = self.action_bounds
+        scaling = (ub - lb) * 0.5
+        ctrl_cost = 0.5 * self.ctrl_cost_coeff * np.sum(np.square(actions / scaling), axis=-1)
+        forward_reward = next_states[:, -3]
+        reward = forward_reward - ctrl_cost
+        return reward, np.zeros_like(reward, dtype=np.bool)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/walker2d_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/walker2d_env.py
new file mode 100644
index 0000000..8eb16bc
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco/walker2d_env.py
@@ -0,0 +1,43 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from rllab.envs.mujoco import walker2d_env
+from rllab.envs.base import Step
+from slbo.envs import BaseModelBasedEnv
+
+
+class Walker2DEnv(walker2d_env.Walker2DEnv, BaseModelBasedEnv):
+    def get_current_obs(self):
+        return np.concatenate([
+            self.model.data.qpos.flat,
+            self.model.data.qvel.flat,
+            self.get_body_com("torso").flat,
+            self.get_body_comvel("torso").flat
+        ])
+
+    def step(self, action):
+        self.forward_dynamics(action)
+        forward_reward = self.get_body_comvel("torso")[0]
+        lb, ub = self.action_bounds
+        scaling = (ub - lb) * 0.5
+        ctrl_cost = 1e-3 * np.sum(np.square(action / scaling))
+        alive_bonus = 1.
+        reward = forward_reward - ctrl_cost + alive_bonus
+        qpos = self.model.data.qpos
+        done = not (qpos[0] > 0.8 and qpos[0] < 2.0 and qpos[2] > -1.0 and qpos[2] < 1.0)
+        next_obs = self.get_current_obs()
+        return Step(next_obs, reward, done)
+
+    def mb_step(self, states, actions, next_states):
+        lb, ub = self.action_bounds
+        scaling = (ub - lb) * 0.5
+
+        reward_ctrl = -0.001 * np.sum(np.square(actions / scaling), axis=-1)
+        reward_fwd = next_states[:, 21]
+        alive_bonus = 1.
+        rewards = reward_ctrl + reward_fwd + alive_bonus
+
+        dones = ~((next_states[:, 0] > 0.8) &
+                  (next_states[:, 0] < 2.0) &
+                  (next_states[:, 2] > -1.0) &
+                  (next_states[:, 2] < 1.0))
+        return rewards, dones
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/__init__.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/__init__.py
new file mode 100644
index 0000000..95924e3
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/__init__.py
@@ -0,0 +1,81 @@
+"""
+Mujoco Maze
+----------
+
+A maze environment using mujoco that supports custom tasks and robots.
+"""
+
+
+import gym
+
+from slbo.envs.mujoco_maze.ant import AntEnv
+from slbo.envs.mujoco_maze.maze_task import TaskRegistry
+from slbo.envs.mujoco_maze.point import PointEnv
+from slbo.envs.mujoco_maze.reacher import ReacherEnv
+from slbo.envs.mujoco_maze.swimmer import SwimmerEnv
+
+for maze_id in TaskRegistry.keys():
+    for i, task_cls in enumerate(TaskRegistry.tasks(maze_id)):
+        point_scale = task_cls.MAZE_SIZE_SCALING.point
+        if point_scale is not None:
+            # Point
+            gym.envs.register(
+                id=f"Point{maze_id}-v{i}",
+                entry_point="slbo.envs.mujoco_maze.maze_env:MazeEnv",
+                kwargs=dict(
+                    model_cls=PointEnv,
+                    maze_task=task_cls,
+                    maze_size_scaling=point_scale,
+                    inner_reward_scaling=task_cls.INNER_REWARD_SCALING,
+                ),
+                max_episode_steps=1000,
+                reward_threshold=task_cls.REWARD_THRESHOLD,
+            )
+
+        ant_scale = task_cls.MAZE_SIZE_SCALING.ant
+        if ant_scale is not None:
+            # Ant
+            gym.envs.register(
+                id=f"Ant{maze_id}-v{i}",
+                entry_point="slbo.envs.mujoco_maze.maze_env:MazeEnv",
+                kwargs=dict(
+                    model_cls=AntEnv,
+                    maze_task=task_cls,
+                    maze_size_scaling=ant_scale,
+                    inner_reward_scaling=task_cls.INNER_REWARD_SCALING,
+                ),
+                max_episode_steps=1000,
+                reward_threshold=task_cls.REWARD_THRESHOLD,
+            )
+
+        swimmer_scale = task_cls.MAZE_SIZE_SCALING.swimmer
+        if swimmer_scale is not None:
+            # Reacher
+            gym.envs.register(
+                id=f"Reacher{maze_id}-v{i}",
+                entry_point="mujoco_maze.maze_env:MazeEnv",
+                kwargs=dict(
+                    model_cls=ReacherEnv,
+                    maze_task=task_cls,
+                    maze_size_scaling=task_cls.MAZE_SIZE_SCALING.swimmer,
+                    inner_reward_scaling=task_cls.INNER_REWARD_SCALING,
+                ),
+                max_episode_steps=1000,
+                reward_threshold=task_cls.REWARD_THRESHOLD,
+            )
+            # Swimmer
+            gym.envs.register(
+                id=f"Swimmer{maze_id}-v{i}",
+                entry_point="mujoco_maze.maze_env:MazeEnv",
+                kwargs=dict(
+                    model_cls=SwimmerEnv,
+                    maze_task=task_cls,
+                    maze_size_scaling=task_cls.MAZE_SIZE_SCALING.swimmer,
+                    inner_reward_scaling=task_cls.INNER_REWARD_SCALING,
+                ),
+                max_episode_steps=1000,
+                reward_threshold=task_cls.REWARD_THRESHOLD,
+            )
+
+
+__version__ = "0.1.0"
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/agent_model.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/agent_model.py
new file mode 100644
index 0000000..d209d78
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/agent_model.py
@@ -0,0 +1,42 @@
+"""Common APIs for defining mujoco robot.
+"""
+from abc import ABC, abstractmethod
+from typing import Optional
+
+import numpy as np
+from gym.envs.mujoco.mujoco_env import MujocoEnv
+from gym.utils import EzPickle
+
+
+class AgentModel(ABC, MujocoEnv, EzPickle):
+    FILE: str
+    MANUAL_COLLISION: bool
+    ORI_IND: int
+    RADIUS: Optional[float] = None
+
+    def __init__(self, file_path: str, frame_skip: int) -> None:
+        MujocoEnv.__init__(self, file_path, frame_skip)
+        EzPickle.__init__(self)
+
+    def close(self):
+        if self.viewer is not None and hasattr(self.viewer, "window"):
+            import glfw
+
+            glfw.destroy_window(self.viewer.window)
+        super().close()
+
+    @abstractmethod
+    def _get_obs(self) -> np.ndarray:
+        """Returns the observation from the model.
+        """
+        pass
+
+    def get_xy(self) -> np.ndarray:
+        """Returns the coordinate of the agent.
+        """
+        pass
+
+    def set_xy(self, xy: np.ndarray) -> None:
+        """Set the coordinate of the agent.
+        """
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/ant.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/ant.py
new file mode 100644
index 0000000..b6a725a
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/ant.py
@@ -0,0 +1,108 @@
+"""
+A four-legged robot as an explorer in the maze.
+Based on `models`_ and `gym`_ (both ant and ant-v3).
+
+.. _models: https://github.com/tensorflow/models/tree/master/research/efficient-hrl
+.. _gym: https://github.com/openai/gym
+"""
+
+from typing import Callable, Tuple
+
+import numpy as np
+
+from slbo.envs.mujoco_maze.agent_model import AgentModel
+
+ForwardRewardFn = Callable[[float, float], float]
+
+
+def forward_reward_vabs(xy_velocity: float) -> float:
+    return np.sum(np.abs(xy_velocity))
+
+
+def forward_reward_vnorm(xy_velocity: float) -> float:
+    return np.linalg.norm(xy_velocity)
+
+
+def q_inv(a):
+    return [a[0], -a[1], -a[2], -a[3]]
+
+
+def q_mult(a, b):  # multiply two quaternion
+    w = a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3]
+    i = a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2]
+    j = a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1]
+    k = a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0]
+    return [w, i, j, k]
+
+
+class AntEnv(AgentModel):
+    FILE: str = "ant.xml"
+    ORI_IND: int = 3
+    MANUAL_COLLISION: bool = False
+
+    def __init__(
+        self,
+        file_path: str,
+        forward_reward_weight: float = 1.0,
+        ctrl_cost_weight: float = 1e-4,
+        forward_reward_fn: ForwardRewardFn = forward_reward_vnorm,
+    ) -> None:
+        self._forward_reward_weight = forward_reward_weight
+        self._ctrl_cost_weight = ctrl_cost_weight
+        self._forward_reward_fn = forward_reward_fn
+        super().__init__(file_path, 5)
+
+    def _forward_reward(self, xy_pos_before: np.ndarray) -> Tuple[float, np.ndarray]:
+        xy_pos_after = self.sim.data.qpos[:2].copy()
+        xy_velocity = (xy_pos_after - xy_pos_before) / self.dt
+        return self._forward_reward_fn(xy_velocity)
+
+    def step(self, action: np.ndarray) -> Tuple[np.ndarray, float, bool, dict]:
+        xy_pos_before = self.sim.data.qpos[:2].copy()
+        self.do_simulation(action, self.frame_skip)
+
+        forward_reward = self._forward_reward(xy_pos_before)
+        ctrl_cost = self._ctrl_cost_weight * np.square(action).sum()
+
+        return (
+            self._get_obs(),
+            self._forward_reward_weight * forward_reward - ctrl_cost,
+            False,
+            dict(reward_forward=forward_reward, reward_ctrl=-ctrl_cost),
+        )
+
+    def _get_obs(self):
+        # No cfrc observation
+        return np.concatenate(
+            [
+                self.sim.data.qpos.flat[:15],  # Ensures only ant obs.
+                self.sim.data.qvel.flat[:14],
+            ]
+        )
+
+    def reset_model(self):
+        qpos = self.init_qpos + self.np_random.uniform(
+            size=self.model.nq, low=-0.1, high=0.1,
+        )
+        qvel = self.init_qvel + self.np_random.randn(self.model.nv) * 0.1
+
+        # Set everything other than ant to original position and 0 velocity.
+        qpos[15:] = self.init_qpos[15:]
+        qvel[14:] = 0.0
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def get_ori(self) -> np.ndarray:
+        ori = [0, 1, 0, 0]
+        rot = self.sim.data.qpos[self.ORI_IND : self.ORI_IND + 4]  # take the quaternion
+        ori = q_mult(q_mult(rot, ori), q_inv(rot))[1:3]  # project onto x-y plane
+        ori = np.arctan2(ori[1], ori[0])
+        return ori
+
+    def set_xy(self, xy: np.ndarray) -> None:
+        qpos = self.sim.data.qpos.copy()
+        qpos[:2] = xy
+        self.set_state(qpos, self.sim.data.qvel)
+
+    def get_xy(self) -> np.ndarray:
+        return np.copy(self.sim.data.qpos[:2])
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/ant.xml b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/ant.xml
new file mode 100755
index 0000000..ffe156b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/ant.xml
@@ -0,0 +1,80 @@
+<mujoco model="ant">
+  <compiler inertiafromgeom="true" angle="degree" coordinate="local" />
+  <option timestep="0.02" integrator="RK4" />
+  <custom>
+    <numeric name="init_qpos" data="0.0 0.0 0.55 1.0 0.0 0.0 0.0 0.0 1.0 0.0 -1.0 0.0 -1.0 0.0 1.0" />
+  </custom>
+  <default>
+    <joint limited="true" armature="1" damping="1" />
+    <geom condim="3" conaffinity="0" margin="0.01" friction="1 0.5 0.5" solref=".02 1" solimp=".8 .8 .01" rgba="0.8 0.6 0.4 1" density="5.0" />
+  </default>
+  <asset>
+    <texture type="skybox" builtin="gradient" width="100" height="100" rgb1="1 1 1" rgb2="0 0 0" />
+    <texture name="texgeom" type="cube" builtin="flat" mark="cross" width="127" height="1278" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" markrgb="1 1 1" random="0.01" />
+    <texture name="texplane" type="2d" builtin="checker" rgb1="0.2 0.3 0.4" rgb2="0.1 0.2 0.3" width="100" height="100" />
+    <material name='MatPlane' texture="texplane" shininess="1" texrepeat="60 60" specular="1"  reflectance="0.5" />
+    <material name='geom' texture="texgeom" texuniform="true" />
+  </asset>
+  <worldbody>
+    <light directional="true" cutoff="100" exponent="1" diffuse="1 1 1" specular=".1 .1 .1" pos="0 0 1.3" dir="-0 0 -1.3" />
+    <geom name="floor" material="MatPlane" pos="0 0 0" size="40 40 40" type="plane" conaffinity="1" rgba="0.8 0.9 0.8 1" condim="3" />
+    <body name="torso" pos="0 0 0.75">
+      <geom name="torso_geom" type="sphere" size="0.25" pos="0 0 0" />
+      <joint name="root" type="free" limited="false" pos="0 0 0" axis="0 0 1" margin="0.01" armature="0" damping="0" />
+      <body name="front_left_leg" pos="0 0 0">
+        <geom name="aux_1_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 0.2 0.2 0.0" />
+        <body name="aux_1" pos="0.2 0.2 0">
+          <joint name="hip_1" type="hinge" pos="0.0 0.0 0.0" axis="0 0 1" range="-30 30" />
+          <geom name="left_leg_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 0.2 0.2 0.0" />
+          <body pos="0.2 0.2 0">
+            <joint name="ankle_1" type="hinge" pos="0.0 0.0 0.0" axis="-1 1 0" range="30 70" />
+            <geom name="left_ankle_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 0.4 0.4 0.0" />
+          </body>
+        </body>
+      </body>
+      <body name="front_right_leg" pos="0 0 0">
+        <geom name="aux_2_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 -0.2 0.2 0.0" />
+        <body name="aux_2" pos="-0.2 0.2 0">
+          <joint name="hip_2" type="hinge" pos="0.0 0.0 0.0" axis="0 0 1" range="-30 30" />
+          <geom name="right_leg_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 -0.2 0.2 0.0" />
+          <body pos="-0.2 0.2 0">
+            <joint name="ankle_2" type="hinge" pos="0.0 0.0 0.0" axis="1 1 0" range="-70 -30" />
+            <geom name="right_ankle_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 -0.4 0.4 0.0" />
+          </body>
+        </body>
+      </body>
+      <body name="back_leg" pos="0 0 0">
+        <geom name="aux_3_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 -0.2 -0.2 0.0" />
+        <body name="aux_3" pos="-0.2 -0.2 0">
+          <joint name="hip_3" type="hinge" pos="0.0 0.0 0.0" axis="0 0 1" range="-30 30" />
+          <geom name="back_leg_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 -0.2 -0.2 0.0" />
+          <body pos="-0.2 -0.2 0">
+            <joint name="ankle_3" type="hinge" pos="0.0 0.0 0.0" axis="-1 1 0" range="-70 -30" />
+            <geom name="third_ankle_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 -0.4 -0.4 0.0" />
+          </body>
+        </body>
+      </body>
+      <body name="right_back_leg" pos="0 0 0">
+        <geom name="aux_4_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 0.2 -0.2 0.0" />
+        <body name="aux_4" pos="0.2 -0.2 0">
+          <joint name="hip_4" type="hinge" pos="0.0 0.0 0.0" axis="0 0 1" range="-30 30" />
+          <geom name="rightback_leg_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 0.2 -0.2 0.0" />
+          <body pos="0.2 -0.2 0">
+            <joint name="ankle_4" type="hinge" pos="0.0 0.0 0.0" axis="1 1 0" range="30 70" />
+            <geom name="fourth_ankle_geom" type="capsule" size="0.08" fromto="0.0 0.0 0.0 0.4 -0.4 0.0" />
+          </body>
+        </body>
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor joint="hip_4" ctrlrange="-30.0 30.0" ctrllimited="true" />
+    <motor joint="ankle_4" ctrlrange="-30.0 30.0" ctrllimited="true" />
+    <motor joint="hip_1" ctrlrange="-30.0 30.0" ctrllimited="true" />
+    <motor joint="ankle_1" ctrlrange="-30.0 30.0" ctrllimited="true" />
+    <motor joint="hip_2" ctrlrange="-30.0 30.0" ctrllimited="true" />
+    <motor joint="ankle_2" ctrlrange="-30.0 30.0" ctrllimited="true" />
+    <motor joint="hip_3" ctrlrange="-30.0 30.0" ctrllimited="true" />
+    <motor joint="ankle_3" ctrlrange="-30.0 30.0" ctrllimited="true" />
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/point.xml b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/point.xml
new file mode 100755
index 0000000..4c06cb1
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/point.xml
@@ -0,0 +1,33 @@
+<mujoco>
+    <compiler inertiafromgeom="true" angle="degree" coordinate="local" />
+    <option timestep="0.02" integrator="RK4" />
+    <default>
+        <joint limited="false" armature="0" damping="0" />
+        <geom condim="3" conaffinity="0" margin="0" friction="1.0 0.5 0.5" rgba="0.8 0.6 0.4 1" density="100" />
+    </default>
+    <asset>
+        <texture type="skybox" builtin="gradient" width="100" height="100" rgb1="1 1 1" rgb2="0 0 0" />
+        <texture name="texgeom" type="cube" builtin="flat" mark="cross" width="127" height="1278" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" markrgb="1 1 1" random="0.01" />
+        <texture name="texplane" type="2d" builtin="checker" rgb1="0.2 0.3 0.4" rgb2="0.1 0.2 0.3" width="100" height="100" />
+        <material name="MatPlane" texture="texplane" shininess="1" texrepeat="30 30" specular="1"  reflectance="0.5" />
+        <material name="geom" texture="texgeom" texuniform="true" />
+    </asset>
+    <worldbody>
+        <light directional="true" cutoff="100" exponent="1" diffuse="1 1 1" specular=".1 .1 .1" pos="0 0 1.3" dir="-0 0 -1.3" />
+        <geom name="floor" material="MatPlane" pos="0 0 0" size="40 40 40" type="plane" conaffinity="1" rgba="0.8 0.9 0.8 1" condim="3" />
+        <!--  ================= Point ================= /-->
+        <!--  Note that the solimp is modified from rllab to prevent the point from going through the wall /-->
+        <body name="torso" pos="0 0 0">
+            <geom name="pointbody" type="sphere" size="0.5" pos="0 0 0.5" rgba="0.8 0.4 0.1 1" solimp="0.9 0.99 0.001" />
+            <geom name="pointarrow" type="box" size="0.5 0.1 0.1" pos="0.6 0 0.5" rgba="0.8 0.4 0.1 1" solimp="0.9 0.99 0.001" />
+            <joint name="ballx" type="slide" axis="1 0 0" pos="0 0 0" />
+            <joint name="bally" type="slide" axis="0 1 0" pos="0 0 0" />
+            <joint name="rot" type="hinge" axis="0 0 1" pos="0 0 0" limited="false" />
+        </body>
+    </worldbody>
+    <actuator>
+        <!-- Those are just dummy actuators for providing ranges -->
+        <motor joint="ballx" ctrlrange="-1 1" ctrllimited="true" />
+        <motor joint="rot" ctrlrange="-0.25 0.25" ctrllimited="true" />
+    </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/reacher.xml b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/reacher.xml
new file mode 100644
index 0000000..0d238c8
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/reacher.xml
@@ -0,0 +1,34 @@
+<mujoco model="swimmer">
+  <compiler angle="degree" coordinate="local" inertiafromgeom="true" />
+  <option collision="predefined" density="4000" integrator="RK4" timestep="0.01" viscosity="0.1" />
+  <default>
+    <geom conaffinity="1" condim="1" contype="1" material="geom" rgba="0.8 0.6 .4 1" />
+    <joint armature="0.1" />
+  </default>
+  <asset>
+    <texture type="skybox" builtin="gradient" width="100" height="100" rgb1="1 1 1" rgb2="0 0 0" />
+    <texture name="texgeom" type="cube" builtin="flat" mark="cross" width="127" height="1278" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" markrgb="1 1 1" random="0.01" />
+    <texture name="texplane" type="2d" builtin="checker" rgb1="0.2 0.3 0.4" rgb2="0.1 0.2 0.3" width="100" height="100" />
+    <material name='MatPlane' texture="texplane" shininess="1" texrepeat="60 60" specular="1"  reflectance="0.5" />
+    <material name='geom' texture="texgeom" texuniform="true" />
+  </asset>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0s 1.3" specular=".1 .1 .1" />
+    <geom conaffinity="1" condim="3" material="MatPlane" name="floor" pos="0 0 -0.1" rgba="0.8 0.9 0.8 1" size="40 40 0.1" type="plane" />
+    <!-- Reacher -->
+    <body name="torso" pos="0 0 0">
+      <camera name="track" mode="trackcom" pos="0 -3 3" xyaxes="1 0 0 0 1 1" />
+      <geom name="frontbody" density="1000" fromto="1.5 0 0 0.5 0 0" size="0.1" type="capsule" />
+      <joint axis="1 0 0" name="slider1" pos="0 0 0" type="slide" />
+      <joint axis="0 1 0" name="slider2" pos="0 0 0" type="slide" />
+      <joint axis="0 0 1" name="rot" pos="0 0 0" type="hinge" />
+      <body name="mid" pos="0.5 0 0">
+        <geom name="midbody" density="1000" fromto="0 0 0 -1 0 0" size="0.1" type="capsule" />
+        <joint axis="0 0 1" limited="true" name="rot2" pos="0 0 0" range="-100 100" type="hinge" />
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor ctrllimited="true" ctrlrange="-1 1" gear="150.0" joint="rot2" />
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/swimmer.xml b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/swimmer.xml
new file mode 100644
index 0000000..3c6c21a
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/assets/swimmer.xml
@@ -0,0 +1,39 @@
+<mujoco model="swimmer">
+  <compiler angle="degree" coordinate="local" inertiafromgeom="true" />
+  <option collision="predefined" density="4000" integrator="RK4" timestep="0.01" viscosity="0.1" />
+  <default>
+    <geom conaffinity="1" condim="1" contype="1" material="geom" rgba="0.8 0.6 .4 1" />
+    <joint armature="0.1" />
+  </default>
+  <asset>
+    <texture type="skybox" builtin="gradient" width="100" height="100" rgb1="1 1 1" rgb2="0 0 0" />
+    <texture name="texgeom" type="cube" builtin="flat" mark="cross" width="127" height="1278" rgb1="0.8 0.6 0.4" rgb2="0.8 0.6 0.4" markrgb="1 1 1" random="0.01" />
+    <texture name="texplane" type="2d" builtin="checker" rgb1="0.2 0.3 0.4" rgb2="0.1 0.2 0.3" width="100" height="100" />
+    <material name='MatPlane' texture="texplane" shininess="1" texrepeat="60 60" specular="1"  reflectance="0.5" />
+    <material name='geom' texture="texgeom" texuniform="true" />
+  </asset>
+  <worldbody>
+    <light cutoff="100" diffuse="1 1 1" dir="-0 0 -1.3" directional="true" exponent="1" pos="0 0s 1.3" specular=".1 .1 .1" />
+    <geom conaffinity="1" condim="3" material="MatPlane" name="floor" pos="0 0 -0.1" rgba="0.8 0.9 0.8 1" size="40 40 0.1" type="plane" />
+    <!--  ================= SWIMMER ================= /-->
+    <body name="torso" pos="0 0 0">
+      <camera name="track" mode="trackcom" pos="0 -3 3" xyaxes="1 0 0 0 1 1" />
+      <geom name="frontbody" density="1000" fromto="1.5 0 0 0.5 0 0" size="0.1" type="capsule" />
+      <joint axis="1 0 0" name="slider1" pos="0 0 0" type="slide" />
+      <joint axis="0 1 0" name="slider2" pos="0 0 0" type="slide" />
+      <joint axis="0 0 1" name="rot" pos="0 0 0" type="hinge" />
+      <body name="mid" pos="0.5 0 0">
+        <geom name="midbody" density="1000" fromto="0 0 0 -1 0 0" size="0.1" type="capsule" />
+        <joint axis="0 0 1" limited="true" name="rot2" pos="0 0 0" range="-100 100" type="hinge" />
+        <body name="back" pos="-1 0 0">
+          <geom name="backbody" density="1000" fromto="0 0 0 -1 0 0" size="0.1" type="capsule" />
+          <joint axis="0 0 1" limited="true" name="rot3" pos="0 0 0" range="-100 100" type="hinge" />
+        </body>
+      </body>
+    </body>
+  </worldbody>
+  <actuator>
+    <motor ctrllimited="true" ctrlrange="-1 1" gear="150.0" joint="rot2" />
+    <motor ctrllimited="true" ctrlrange="-1 1" gear="150.0" joint="rot3" />
+  </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_env.py
new file mode 100644
index 0000000..dd11988
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_env.py
@@ -0,0 +1,595 @@
+"""
+Mujoco Maze environment.
+Based on `models`_ and `rllab`_.
+
+.. _models: https://github.com/tensorflow/models/tree/master/research/efficient-hrl
+.. _rllab: https://github.com/rll/rllab
+"""
+
+import itertools as it
+import os
+import tempfile
+import xml.etree.ElementTree as ET
+from typing import List, Tuple, Type
+
+import gym
+import numpy as np
+
+from slbo.envs.mujoco_maze import maze_env_utils, maze_task
+from slbo.envs.mujoco_maze.agent_model import AgentModel
+from slbo.utils.dataset import Dataset, gen_dtype
+
+
+# Directory that contains mujoco xml files.
+MODEL_DIR = os.path.dirname(os.path.abspath(__file__)) + "/assets"
+
+
+class MazeEnv(gym.Env):
+    def __init__(
+        self,
+        model_cls: Type[AgentModel],
+        maze_task: Type[maze_task.MazeTask] = maze_task.MazeTask,
+        top_down_view: float = False,
+        maze_height: float = 0.5,
+        maze_size_scaling: float = 4.0,
+        inner_reward_scaling: float = 1.0,
+        restitution_coef: float = 0.8,
+        task_kwargs: dict = {},
+        *args,
+        **kwargs,
+    ) -> None:
+        self._task = maze_task(maze_size_scaling, **task_kwargs)
+
+        xml_path = os.path.join(MODEL_DIR, model_cls.FILE)
+        tree = ET.parse(xml_path)
+        worldbody = tree.find(".//worldbody")
+
+        self._maze_height = height = maze_height
+        self._maze_size_scaling = size_scaling = maze_size_scaling
+        self._inner_reward_scaling = inner_reward_scaling
+        self.t = 0  # time steps
+        self._observe_blocks = self._task.OBSERVE_BLOCKS
+        self._put_spin_near_agent = self._task.PUT_SPIN_NEAR_AGENT
+        # Observe other objectives
+        self._observe_balls = self._task.OBSERVE_BALLS
+        self._top_down_view = self._task.TOP_DOWN_VIEW
+        self._restitution_coef = restitution_coef
+
+        self._maze_structure = structure = self._task.create_maze()
+        # Elevate the maze to allow for falling.
+        self.elevated = any(maze_env_utils.MazeCell.CHASM in row for row in structure)
+        # Are there any movable blocks?
+        self.blocks = any(any(r.can_move() for r in row) for row in structure)
+
+        torso_x, torso_y = self._find_robot()
+        self._init_torso_x = torso_x
+        self._init_torso_y = torso_y
+        self._init_positions = [
+            (x - torso_x, y - torso_y) for x, y in self._find_all_robots()
+        ]
+
+        if model_cls.MANUAL_COLLISION:
+            if model_cls.RADIUS is None:
+                raise ValueError("Manual collision needs radius of the model")
+            self._collision = maze_env_utils.CollisionDetector(
+                structure, size_scaling, torso_x, torso_y, model_cls.RADIUS,
+            )
+            # Now all object balls have size=1.0
+            self._objball_collision = maze_env_utils.CollisionDetector(
+                structure, size_scaling, torso_x, torso_y, self._task.OBJECT_BALL_SIZE,
+            )
+        else:
+            self._collision = None
+
+        self._xy_to_rowcol = lambda x, y: (
+            2 + (y + size_scaling / 2) / size_scaling,
+            2 + (x + size_scaling / 2) / size_scaling,
+        )
+        # walls (immovable), chasms (fall), movable blocks
+        self._view = np.zeros([5, 5, 3])
+
+        height_offset = 0.0
+        if self.elevated:
+            # Increase initial z-pos of ant.
+            height_offset = height * size_scaling
+            torso = tree.find(".//body[@name='torso']")
+            torso.set("pos", f"0 0 {0.75 + height_offset:.2f}")
+        if self.blocks:
+            # If there are movable blocks, change simulation settings to perform
+            # better contact detection.
+            default = tree.find(".//default")
+            default.find(".//geom").set("solimp", ".995 .995 .01")
+
+        self.movable_blocks = []
+        self.object_balls = []
+        for i in range(len(structure)):
+            for j in range(len(structure[0])):
+                struct = structure[i][j]
+                if struct.is_robot() and self._put_spin_near_agent:
+                    struct = maze_env_utils.MazeCell.SPIN
+                x, y = j * size_scaling - torso_x, i * size_scaling - torso_y
+                h = height / 2 * size_scaling
+                size = size_scaling * 0.5
+                if self.elevated and not struct.is_chasm():
+                    # Create elevated platform.
+                    ET.SubElement(
+                        worldbody,
+                        "geom",
+                        name=f"elevated_{i}_{j}",
+                        pos=f"{x} {y} {h}",
+                        size=f"{size} {size} {h}",
+                        type="box",
+                        material="",
+                        contype="1",
+                        conaffinity="1",
+                        rgba="0.9 0.9 0.9 1",
+                    )
+                if struct.is_block():
+                    # Unmovable block.
+                    # Offset all coordinates so that robot starts at the origin.
+                    ET.SubElement(
+                        worldbody,
+                        "geom",
+                        name=f"block_{i}_{j}",
+                        pos=f"{x} {y} {h + height_offset}",
+                        size=f"{size} {size} {h}",
+                        type="box",
+                        material="",
+                        contype="1",
+                        conaffinity="1",
+                        rgba="0.4 0.4 0.4 1",
+                    )
+                elif struct.can_move():
+                    # Movable block.
+                    self.movable_blocks.append(f"movable_{i}_{j}")
+                    _add_movable_block(
+                        worldbody, struct, i, j, size_scaling, x, y, h, height_offset,
+                    )
+                elif struct.is_object_ball():
+                    # Movable Ball
+                    self.object_balls.append(f"objball_{i}_{j}")
+                    _add_object_ball(worldbody, i, j, x, y, self._task.OBJECT_BALL_SIZE)
+
+        torso = tree.find(".//body[@name='torso']")
+        geoms = torso.findall(".//geom")
+        for geom in geoms:
+            if "name" not in geom.attrib:
+                raise Exception("Every geom of the torso must have a name")
+
+        # Set goals
+        for i, goal in enumerate(self._task.goals):
+            z = goal.pos[2] if goal.dim >= 3 else 0.0
+            if goal.custom_size is None:
+                size = f"{maze_size_scaling * 0.1}"
+            else:
+                size = f"{goal.custom_size}"
+            ET.SubElement(
+                worldbody,
+                "site",
+                name=f"goal_site{i}",
+                pos=f"{goal.pos[0]} {goal.pos[1]} {z}",
+                size=f"{maze_size_scaling * 0.1}",
+                rgba=goal.rgb.rgba_str(),
+            )
+
+        _, file_path = tempfile.mkstemp(text=True, suffix=".xml")
+        tree.write(file_path)
+        self.world_tree = tree
+        self.wrapped_env = model_cls(*args, file_path=file_path, **kwargs)
+        self.observation_space = self._get_obs_space()
+
+    @property
+    def has_extended_obs(self) -> bool:
+        return self._top_down_view or self._observe_blocks or self._observe_balls
+
+    def get_ori(self) -> float:
+        return self.wrapped_env.get_ori()
+
+    def _get_obs_space(self) -> gym.spaces.Box:
+        shape = self._get_obs().shape
+        high = np.inf * np.ones(shape, dtype=np.float32)
+        low = -high
+        # Set velocity limits
+        wrapped_obs_space = self.wrapped_env.observation_space
+        high[: wrapped_obs_space.shape[0]] = wrapped_obs_space.high
+        low[: wrapped_obs_space.shape[0]] = wrapped_obs_space.low
+        # Set coordinate limits
+        low[0], high[0], low[1], high[1] = self._xy_limits()
+        # Set orientation limits
+        return gym.spaces.Box(low, high)
+
+    def _xy_limits(self) -> Tuple[float, float, float, float]:
+        xmin, ymin, xmax, ymax = 100, 100, -100, -100
+        structure = self._maze_structure
+        for i, j in it.product(range(len(structure)), range(len(structure[0]))):
+            if structure[i][j].is_block():
+                continue
+            xmin, xmax = min(xmin, j), max(xmax, j)
+            ymin, ymax = min(ymin, i), max(ymax, i)
+        x0, y0 = self._init_torso_x, self._init_torso_y
+        scaling = self._maze_size_scaling
+        xmin, xmax = (xmin - 0.5) * scaling - x0, (xmax + 0.5) * scaling - x0
+        ymin, ymax = (ymin - 0.5) * scaling - y0, (ymax + 0.5) * scaling - y0
+        return xmin, xmax, ymin, ymax
+
+    def get_top_down_view(self) -> np.ndarray:
+        self._view = np.zeros_like(self._view)
+
+        def valid(row, col):
+            return self._view.shape[0] > row >= 0 and self._view.shape[1] > col >= 0
+
+        def update_view(x, y, d, row=None, col=None):
+            if row is None or col is None:
+                x = x - self._robot_x
+                y = y - self._robot_y
+
+                row, col = self._xy_to_rowcol(x, y)
+                update_view(x, y, d, row=row, col=col)
+                return
+
+            row, row_frac, col, col_frac = int(row), row % 1, int(col), col % 1
+            if row_frac < 0:
+                row_frac += 1
+            if col_frac < 0:
+                col_frac += 1
+
+            if valid(row, col):
+                self._view[row, col, d] += (
+                    min(1.0, row_frac + 0.5) - max(0.0, row_frac - 0.5)
+                ) * (min(1.0, col_frac + 0.5) - max(0.0, col_frac - 0.5))
+            if valid(row - 1, col):
+                self._view[row - 1, col, d] += (max(0.0, 0.5 - row_frac)) * (
+                    min(1.0, col_frac + 0.5) - max(0.0, col_frac - 0.5)
+                )
+            if valid(row + 1, col):
+                self._view[row + 1, col, d] += (max(0.0, row_frac - 0.5)) * (
+                    min(1.0, col_frac + 0.5) - max(0.0, col_frac - 0.5)
+                )
+            if valid(row, col - 1):
+                self._view[row, col - 1, d] += (
+                    min(1.0, row_frac + 0.5) - max(0.0, row_frac - 0.5)
+                ) * (max(0.0, 0.5 - col_frac))
+            if valid(row, col + 1):
+                self._view[row, col + 1, d] += (
+                    min(1.0, row_frac + 0.5) - max(0.0, row_frac - 0.5)
+                ) * (max(0.0, col_frac - 0.5))
+            if valid(row - 1, col - 1):
+                self._view[row - 1, col - 1, d] += (max(0.0, 0.5 - row_frac)) * max(
+                    0.0, 0.5 - col_frac
+                )
+            if valid(row - 1, col + 1):
+                self._view[row - 1, col + 1, d] += (max(0.0, 0.5 - row_frac)) * max(
+                    0.0, col_frac - 0.5
+                )
+            if valid(row + 1, col + 1):
+                self._view[row + 1, col + 1, d] += (max(0.0, row_frac - 0.5)) * max(
+                    0.0, col_frac - 0.5
+                )
+            if valid(row + 1, col - 1):
+                self._view[row + 1, col - 1, d] += (max(0.0, row_frac - 0.5)) * max(
+                    0.0, 0.5 - col_frac
+                )
+
+        # Draw ant.
+        robot_x, robot_y = self.wrapped_env.get_body_com("torso")[:2]
+        self._robot_x = robot_x
+        self._robot_y = robot_y
+
+        structure = self._maze_structure
+        size_scaling = self._maze_size_scaling
+
+        # Draw immovable blocks and chasms.
+        for i in range(len(structure)):
+            for j in range(len(structure[0])):
+                if structure[i][j].is_block():  # Wall.
+                    update_view(
+                        j * size_scaling - self._init_torso_x,
+                        i * size_scaling - self._init_torso_y,
+                        0,
+                    )
+                if structure[i][j].is_chasm():  # Chasm.
+                    update_view(
+                        j * size_scaling - self._init_torso_x,
+                        i * size_scaling - self._init_torso_y,
+                        1,
+                    )
+
+        # Draw movable blocks.
+        for block_name in self.movable_blocks:
+            block_x, block_y = self.wrapped_env.get_body_com(block_name)[:2]
+            update_view(block_x, block_y, 2)
+
+        return self._view
+
+    def _get_obs(self) -> np.ndarray:
+        wrapped_obs = self.wrapped_env._get_obs()
+        if self._top_down_view:
+            view = [self.get_top_down_view().flat]
+        else:
+            view = []
+
+        additional_obs = []
+
+        if self._observe_balls:
+            for name in self.object_balls:
+                additional_obs.append(self.wrapped_env.get_body_com(name))
+
+        if self._observe_blocks:
+            for name in self.movable_blocks:
+                additional_obs.append(self.wrapped_env.get_body_com(name))
+
+        obs = np.concatenate([wrapped_obs[:3]] + additional_obs + [wrapped_obs[3:]])
+        return np.concatenate([obs, *view, np.array([self.t * 0.001])])
+
+    def reset(self) -> np.ndarray:
+        self.t = 0
+        self.wrapped_env.reset()
+        # Samples a new goal
+        if self._task.sample_goals():
+            self.set_marker()
+        # Samples a new start position
+        if len(self._init_positions) > 1:
+            xy = np.random.choice(self._init_positions)
+            self.wrapped_env.set_xy(xy)
+        return self._get_obs()
+
+    def set_marker(self) -> None:
+        for i, goal in enumerate(self._task.goals):
+            idx = self.model.site_name2id(f"goal{i}")
+            self.data.site_xpos[idx][: len(goal.pos)] = goal.pos
+
+    @property
+    def viewer(self):
+        return self.wrapped_env.viewer
+
+    def render(self, *args, **kwargs):
+        return self.wrapped_env.render(*args, **kwargs)
+
+    @property
+    def action_space(self):
+        return self.wrapped_env.action_space
+
+    def _find_robot(self) -> Tuple[float, float]:
+        structure = self._maze_structure
+        size_scaling = self._maze_size_scaling
+        for i, j in it.product(range(len(structure)), range(len(structure[0]))):
+            if structure[i][j].is_robot():
+                return j * size_scaling, i * size_scaling
+        raise ValueError("No robot in maze specification.")
+
+    def _find_all_robots(self) -> List[Tuple[float, float]]:
+        structure = self._maze_structure
+        size_scaling = self._maze_size_scaling
+        coords = []
+        for i, j in it.product(range(len(structure)), range(len(structure[0]))):
+            if structure[i][j].is_robot():
+                coords.append((j * size_scaling, i * size_scaling))
+        return coords
+
+    def _objball_positions(self) -> None:
+        return [
+            self.wrapped_env.get_body_com(name)[:2].copy() for name in self.object_balls
+        ]
+
+    def step(self, action: np.ndarray) -> Tuple[np.ndarray, float, bool, dict]:
+        action = np.clip(action, self.action_space.low, self.action_space.high)
+        self.t += 1
+        if self.wrapped_env.MANUAL_COLLISION:
+            old_pos = self.wrapped_env.get_xy()
+            old_objballs = self._objball_positions()
+            inner_next_obs, inner_reward, _, info = self.wrapped_env.step(action)
+            new_pos = self.wrapped_env.get_xy()
+            new_objballs = self._objball_positions()
+            # Checks that the new_position is in the wall
+            collision = self._collision.detect(old_pos, new_pos)
+            if collision is not None:
+                pos = collision.point + self._restitution_coef * collision.rest()
+                if self._collision.detect(old_pos, pos) is not None:
+                    # If pos is also not in the wall, we give up computing the position
+                    self.wrapped_env.set_xy(old_pos)
+                else:
+                    self.wrapped_env.set_xy(pos)
+            # Do the same check for object balls
+            for name, old, new in zip(self.object_balls, old_objballs, new_objballs):
+                collision = self._objball_collision.detect(old, new)
+                if collision is not None:
+                    pos = collision.point + self._restitution_coef * collision.rest()
+                    if self._objball_collision.detect(old, pos) is not None:
+                        pos = old
+                    idx = self.wrapped_env.model.body_name2id(name)
+                    self.wrapped_env.data.xipos[idx][:2] = pos
+        else:
+            inner_next_obs, inner_reward, _, info = self.wrapped_env.step(action)
+        next_obs = self._get_obs()
+        inner_reward = self._inner_reward_scaling * inner_reward
+        outer_reward = self._task.reward(next_obs)
+        done = self._task.termination(next_obs)
+        info["position"] = self.wrapped_env.get_xy()
+        return next_obs, inner_reward + outer_reward, done, info
+
+    def mb_step(self, states, actions, next_states):
+        # returns rewards and dones
+        # forward rewards are calculated based on states, instead of next_states as in original SLBO envs
+        rewards = []
+        dones = []
+        for i in range(len(next_states)):
+            rewards.append(self._task.reward(next_states[i]))
+            dones.append(self._task.termination(next_states[i]))
+        inner_rewards = np.linalg.norm((states[:,:2] - next_states[:,:2])/self.wrapped_env.dt,axis=-1)
+        reward_ctrl = self.wrapped_env._ctrl_cost_weight * np.sum(np.square(actions), axis=-1)
+        #print(inner_.rewards)
+        rewards = np.array(rewards)
+        assert rewards.shape == inner_rewards.shape
+        assert inner_rewards.shape == reward_ctrl.shape
+        rewards = rewards + self._inner_reward_scaling * (inner_rewards - reward_ctrl)
+        #print(rewards)
+        return rewards, np.array(dones, dtype=np.bool)
+
+
+    def verify(self, n=2000, eps=1e-4):
+        print(self._inner_reward_scaling)
+        dataset = Dataset(gen_dtype(self, 'state action next_state reward done'), n)
+        state = self.reset()
+        for _ in range(n):
+            action = self.action_space.sample()
+            next_state, reward, done, _ = self.step(action)
+            dataset.append((state, action, next_state, reward, done))
+
+            state = next_state
+            if done:
+                state = self.reset()
+
+        rewards_, dones_ = self.mb_step(dataset.state, dataset.action, dataset.next_state)
+        print(dataset.reward)
+        diff = dataset.reward - rewards_
+        l_inf = np.abs(diff).max()
+        print('rewarder difference: %.6f', l_inf)
+
+        assert np.allclose(dones_, dataset.done)
+        assert l_inf < eps
+
+
+    def close(self) -> None:
+        self.wrapped_env.close()
+
+
+def _add_object_ball(
+    worldbody: ET.Element, i: str, j: str, x: float, y: float, size: float
+) -> None:
+    body = ET.SubElement(worldbody, "body", name=f"objball_{i}_{j}", pos=f"{x} {y} 0")
+    mass = 0.0001 * (size ** 3)
+    ET.SubElement(
+        body,
+        "geom",
+        type="sphere",
+        name=f"objball_{i}_{j}_geom",
+        size=f"{size}",  # Radius
+        pos=f"0.0 0.0 {size}",  # Z = size so that this ball can move!!
+        rgba=maze_task.BLUE.rgba_str(),
+        contype="1",
+        conaffinity="1",
+        solimp="0.9 0.99 0.001",
+        mass=f"{mass}",
+    )
+    ET.SubElement(
+        body,
+        "joint",
+        name=f"objball_{i}_{j}_x",
+        axis="1 0 0",
+        pos="0 0 0.0",
+        type="slide",
+    )
+    ET.SubElement(
+        body,
+        "joint",
+        name=f"objball_{i}_{j}_y",
+        axis="0 1 0",
+        pos="0 0 0",
+        type="slide",
+    )
+    ET.SubElement(
+        body,
+        "joint",
+        name=f"objball_{i}_{j}_rot",
+        axis="0 0 1",
+        pos="0 0 0",
+        type="hinge",
+        limited="false",
+    )
+
+
+def _add_movable_block(
+    worldbody: ET.Element,
+    struct: maze_env_utils.MazeCell,
+    i: str,
+    j: str,
+    size_scaling: float,
+    x: float,
+    y: float,
+    h: float,
+    height_offset: float,
+) -> None:
+    falling = struct.can_move_z()
+    if struct.can_spin():
+        h *= 0.1
+        x += size_scaling * 0.25
+        shrink = 0.1
+    elif falling:
+        # The "falling" blocks are shrunk slightly and increased in mass to
+        # ensure it can fall easily through a gap in the platform blocks.
+        shrink = 0.99
+    elif struct.is_half_block():
+        shrink = 0.5
+    else:
+        shrink = 1.0
+    size = size_scaling * 0.5 * shrink
+    movable_body = ET.SubElement(
+        worldbody, "body", name=f"movable_{i}_{j}", pos=f"{x} {y} {h}",
+    )
+    ET.SubElement(
+        movable_body,
+        "geom",
+        name=f"block_{i}_{j}",
+        pos="0 0 0",
+        size=f"{size} {size} {h}",
+        type="box",
+        material="",
+        mass="0.001" if falling else "0.0002",
+        contype="1",
+        conaffinity="1",
+        rgba="0.9 0.1 0.1 1",
+    )
+    if struct.can_move_x():
+        ET.SubElement(
+            movable_body,
+            "joint",
+            axis="1 0 0",
+            name=f"movable_x_{i}_{j}",
+            armature="0",
+            damping="0.0",
+            limited="true" if falling else "false",
+            range=f"{-size_scaling} {size_scaling}",
+            margin="0.01",
+            pos="0 0 0",
+            type="slide",
+        )
+    if struct.can_move_y():
+        ET.SubElement(
+            movable_body,
+            "joint",
+            armature="0",
+            axis="0 1 0",
+            damping="0.0",
+            limited="true" if falling else "false",
+            range=f"{-size_scaling} {size_scaling}",
+            margin="0.01",
+            name=f"movable_y_{i}_{j}",
+            pos="0 0 0",
+            type="slide",
+        )
+    if struct.can_move_z():
+        ET.SubElement(
+            movable_body,
+            "joint",
+            armature="0",
+            axis="0 0 1",
+            damping="0.0",
+            limited="true",
+            range=f"{-height_offset} 0",
+            margin="0.01",
+            name=f"movable_z_{i}_{j}",
+            pos="0 0 0",
+            type="slide",
+        )
+    if struct.can_spin():
+        ET.SubElement(
+            movable_body,
+            "joint",
+            armature="0",
+            axis="0 0 1",
+            damping="0.0",
+            limited="false",
+            name=f"spinable_{i}_{j}",
+            pos="0 0 0",
+            type="ball",
+        )
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_env_utils.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_env_utils.py
new file mode 100644
index 0000000..348b88c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_env_utils.py
@@ -0,0 +1,205 @@
+"""
+Utilities for creating maze.
+Based on `models`_ and `rllab`_.
+
+.. _models: https://github.com/tensorflow/models/tree/master/research/efficient-hrl
+.. _rllab: https://github.com/rll/rllab
+"""
+
+import itertools as it
+from enum import Enum
+from typing import Any, List, Optional, Sequence, Tuple, Union
+
+import numpy as np
+
+Self = Any
+Point = np.complex
+
+
+class MazeCell(Enum):
+    # Robot: Start position
+    ROBOT = -1
+    # Blocks
+    EMPTY = 0
+    BLOCK = 1
+    CHASM = 2
+    OBJECT_BALL = 3
+    # Moves
+    XY_BLOCK = 14
+    XZ_BLOCK = 15
+    YZ_BLOCK = 16
+    XYZ_BLOCK = 17
+    XY_HALF_BLOCK = 18
+    SPIN = 19
+
+    def is_block(self) -> bool:
+        return self == self.BLOCK
+
+    def is_chasm(self) -> bool:
+        return self == self.CHASM
+
+    def is_object_ball(self) -> bool:
+        return self == self.OBJECT_BALL
+
+    def is_empty(self) -> bool:
+        return self == self.ROBOT or self == self.EMPTY
+
+    def is_robot(self) -> bool:
+        return self == self.ROBOT
+
+    def is_wall_or_chasm(self) -> bool:
+        return self in [self.BLOCK, self.CHASM]
+
+    def can_move_x(self) -> bool:
+        return self in [
+            self.XY_BLOCK,
+            self.XY_HALF_BLOCK,
+            self.XZ_BLOCK,
+            self.XYZ_BLOCK,
+            self.SPIN,
+        ]
+
+    def can_move_y(self) -> bool:
+        return self in [
+            self.XY_BLOCK,
+            self.XY_HALF_BLOCK,
+            self.YZ_BLOCK,
+            self.XYZ_BLOCK,
+            self.SPIN,
+        ]
+
+    def can_move_z(self) -> bool:
+        return self in [self.XZ_BLOCK, self.YZ_BLOCK, self.XYZ_BLOCK]
+
+    def can_spin(self) -> bool:
+        return self == self.SPIN
+
+    def can_move(self) -> bool:
+        return self.can_move_x() or self.can_move_y() or self.can_move_z()
+
+    def is_half_block(self) -> bool:
+        return self in [self.XY_HALF_BLOCK]
+
+
+class Line:
+    def __init__(
+        self, p1: Union[Sequence[float], Point], p2: Union[Sequence[float], Point],
+    ) -> None:
+        self.p1 = p1 if isinstance(p1, Point) else np.complex(*p1)
+        self.p2 = p2 if isinstance(p2, Point) else np.complex(*p2)
+        self.v1 = self.p2 - self.p1
+        self.conj_v1 = np.conjugate(self.v1)
+        self.norm = np.absolute(self.v1)
+
+    def _intersect(self, other: Self) -> bool:
+        v2 = other.p1 - self.p1
+        v3 = other.p2 - self.p1
+        return (self.conj_v1 * v2).imag * (self.conj_v1 * v3).imag <= 0.0
+
+    def _projection(self, p: Point) -> Point:
+        nv1 = -self.v1
+        nv1_norm = np.absolute(nv1) ** 2
+        scale = np.real(np.conjugate(p - self.p1) * nv1) / nv1_norm
+        return self.p1 + nv1 * scale
+
+    def reflection(self, p: Point) -> Point:
+        return p + 2.0 * (self._projection(p) - p)
+
+    def distance(self, p: Point) -> float:
+        return np.absolute(p - self._projection(p))
+
+    def intersect(self, other: Self) -> Point:
+        if self._intersect(other) and other._intersect(self):
+            return self._cross_point(other)
+        else:
+            return None
+
+    def _cross_point(self, other: Self) -> Optional[Point]:
+        v2 = other.p2 - other.p1
+        v3 = self.p2 - other.p1
+        a, b = (self.conj_v1 * v2).imag, (self.conj_v1 * v3).imag
+        return other.p1 + b / a * v2
+
+    def __repr__(self) -> str:
+        x1, y1 = self.p1.real, self.p1.imag
+        x2, y2 = self.p2.real, self.p2.imag
+        return f"Line(({x1}, {y1}) -> ({x2}, {y2}))"
+
+
+class Collision:
+    def __init__(self, point: Point, reflection: Point) -> None:
+        self._point = point
+        self._reflection = reflection
+
+    @property
+    def point(self) -> np.ndarray:
+        return np.array([self._point.real, self._point.imag])
+
+    def rest(self) -> np.ndarray:
+        p = self._reflection - self._point
+        return np.array([p.real, p.imag])
+
+
+class CollisionDetector:
+    """For manual collision detection.
+    """
+
+    EPS: float = 0.05
+    NEIGHBORS: List[Tuple[int, int]] = [[0, -1], [-1, 0], [0, 1], [1, 0]]
+
+    def __init__(
+        self,
+        structure: list,
+        size_scaling: float,
+        torso_x: float,
+        torso_y: float,
+        radius: float,
+    ) -> None:
+        h, w = len(structure), len(structure[0])
+        self.lines = []
+
+        def is_empty(i, j) -> bool:
+            if 0 <= i < h and 0 <= j < w:
+                return structure[i][j].is_empty()
+            else:
+                return False
+
+        for i, j in it.product(range(len(structure)), range(len(structure[0]))):
+            if not structure[i][j].is_block():
+                continue
+            y_base = i * size_scaling - torso_y
+            x_base = j * size_scaling - torso_x
+            offset = size_scaling * 0.5 + radius
+            min_y, max_y = y_base - offset, y_base + offset
+            min_x, max_x = x_base - offset, x_base + offset
+            for dx, dy in self.NEIGHBORS:
+                if not is_empty(i + dy, j + dx):
+                    continue
+                self.lines.append(
+                    Line(
+                        (max_x if dx == 1 else min_x, max_y if dy == 1 else min_y),
+                        (min_x if dx == -1 else max_x, min_y if dy == -1 else max_y),
+                    )
+                )
+
+    def detect(self, old_pos: np.ndarray, new_pos: np.ndarray) -> Optional[Collision]:
+        move = Line(old_pos, new_pos)
+        # First, checks that it actually moved
+        if move.norm <= 1e-8:
+            return None
+        # Next, checks that the trajectory cross the wall or not
+        collisions = []
+        for line in self.lines:
+            intersection = line.intersect(move)
+            if intersection is not None:
+                reflection = line.reflection(move.p2)
+                collisions.append(Collision(intersection, reflection))
+        if len(collisions) == 0:
+            return None
+        col = collisions[0]
+        dist = np.absolute(col._point - move.p1)
+        for collision in collisions[1:]:
+            new_dist = np.absolute(collision._point - move.p1)
+            if new_dist < dist:
+                col, dist = collision, new_dist
+        return col
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_task.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_task.py
new file mode 100644
index 0000000..77fca6b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/maze_task.py
@@ -0,0 +1,477 @@
+"""Maze tasks that are defined by their map, termination condition, and goals.
+"""
+
+from abc import ABC, abstractmethod
+from typing import Dict, List, NamedTuple, Optional, Tuple, Type
+
+import numpy as np
+
+from slbo.envs.mujoco_maze.maze_env_utils import MazeCell
+
+
+class Rgb(NamedTuple):
+    red: float
+    green: float
+    blue: float
+
+    def rgba_str(self) -> str:
+        return f"{self.red} {self.green} {self.blue} 1"
+
+
+RED = Rgb(0.7, 0.1, 0.1)
+GREEN = Rgb(0.1, 0.7, 0.1)
+BLUE = Rgb(0.1, 0.1, 0.7)
+
+
+class MazeGoal:
+    def __init__(
+        self,
+        pos: np.ndarray,
+        reward_scale: float = 1.0,
+        rgb: Rgb = RED,
+        threshold: float = 0.6,
+        custom_size: Optional[float] = None,
+    ) -> None:
+        assert 0.0 <= reward_scale <= 1.0
+        self.pos = pos
+        self.dim = pos.shape[0]
+        self.reward_scale = reward_scale
+        self.rgb = rgb
+        self.threshold = threshold
+        self.custom_size = custom_size
+
+    def neighbor(self, obs: np.ndarray) -> float:
+        return np.linalg.norm(obs[: self.dim] - self.pos) <= self.threshold
+
+    def euc_dist(self, obs: np.ndarray) -> float:
+        return np.sum(np.square(obs[: self.dim] - self.pos)) ** 0.5
+
+
+class Scaling(NamedTuple):
+    ant: Optional[float]
+    point: Optional[float]
+    swimmer: Optional[float]
+
+
+class MazeTask(ABC):
+    REWARD_THRESHOLD: float
+    PENALTY: Optional[float] = None
+    MAZE_SIZE_SCALING: Scaling = Scaling(8.0, 4.0, 4.0)
+    INNER_REWARD_SCALING: float = 0.01
+    # For Fall/Push/BlockMaze
+    OBSERVE_BLOCKS: bool = False
+    # For Billiard
+    OBSERVE_BALLS: bool = False
+    OBJECT_BALL_SIZE: float = 1.0
+    # Unused now
+    PUT_SPIN_NEAR_AGENT: bool = False
+    TOP_DOWN_VIEW: bool = False
+
+    def __init__(self, scale: float) -> None:
+        self.goals = []
+        self.scale = scale
+
+    def sample_goals(self) -> bool:
+        return False
+
+    def termination(self, obs: np.ndarray) -> bool:
+        for goal in self.goals:
+            if goal.neighbor(obs):
+                return True
+        return False
+
+    @abstractmethod
+    def reward(self, obs: np.ndarray) -> float:
+        pass
+
+    @staticmethod
+    @abstractmethod
+    def create_maze() -> List[List[MazeCell]]:
+        pass
+
+
+class DistRewardMixIn:
+    REWARD_THRESHOLD: float = -1000.0
+    goals: List[MazeGoal]
+    scale: float
+
+    def reward(self, obs: np.ndarray) -> float:
+        return -self.goals[0].euc_dist(obs) / self.scale
+
+
+class GoalRewardUMaze(MazeTask):
+    REWARD_THRESHOLD: float = 0.9
+    PENALTY: float = -0.0001
+
+    def __init__(self, scale: float) -> None:
+        super().__init__(scale)
+        self.goals = [MazeGoal(np.array([0.0, 2.0 * scale]))]
+
+    def reward(self, obs: np.ndarray) -> float:
+        return 100.0 if self.termination(obs) else self.PENALTY
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B, R = MazeCell.EMPTY, MazeCell.BLOCK, MazeCell.ROBOT
+        return [
+            [B, B, B, B, B],
+            [B, R, E, E, B],
+            [B, B, B, E, B],
+            [B, E, E, E, B],
+            [B, B, B, B, B],
+        ]
+
+
+class DistRewardUMaze(GoalRewardUMaze, DistRewardMixIn):
+    pass
+
+
+class GoalRewardSimpleRoom(GoalRewardUMaze):
+    def __init__(self, scale: float) -> None:
+        super().__init__(scale)
+        self.goals = [MazeGoal(np.array([2.0 * scale, 0.0]))]
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B, R = MazeCell.EMPTY, MazeCell.BLOCK, MazeCell.ROBOT
+        return [
+            [B, B, B, B, B],
+            [B, R, E, E, B],
+            [B, B, B, B, B],
+        ]
+
+
+class DistRewardSimpleRoom(GoalRewardSimpleRoom, DistRewardMixIn):
+    pass
+
+
+class GoalRewardPush(GoalRewardUMaze):
+    OBSERVE_BLOCKS: bool = True
+
+    def __init__(self, scale: float) -> None:
+        super().__init__(scale)
+        self.goals = [MazeGoal(np.array([0.0, 2.375 * scale]))]
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B, R, M = MazeCell.EMPTY, MazeCell.BLOCK, MazeCell.ROBOT, MazeCell.XY_BLOCK
+        return [
+            [B, B, B, B, B],
+            [B, E, R, B, B],
+            [B, E, M, E, B],
+            [B, B, E, B, B],
+            [B, B, B, B, B],
+        ]
+
+
+class DistRewardPush(GoalRewardPush, DistRewardMixIn):
+    pass
+
+
+class GoalRewardFall(GoalRewardUMaze):
+    OBSERVE_BLOCKS: bool = True
+
+    def __init__(self, scale: float) -> None:
+        super().__init__(scale)
+        self.goals = [MazeGoal(np.array([0.0, 3.375 * scale, 4.5]))]
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B, C, R = MazeCell.EMPTY, MazeCell.BLOCK, MazeCell.CHASM, MazeCell.ROBOT
+        M = MazeCell.YZ_BLOCK
+        return [
+            [B, B, B, B],
+            [B, R, E, B],
+            [B, E, M, B],
+            [B, C, C, B],
+            [B, E, E, B],
+            [B, B, B, B],
+        ]
+
+
+class DistRewardFall(GoalRewardFall, DistRewardMixIn):
+    pass
+
+
+class GoalReward2Rooms(MazeTask):
+    REWARD_THRESHOLD: float = 0.9
+    PENALTY: float = -0.0001
+    MAZE_SIZE_SCALING: Scaling = Scaling(4.0, 4.0, 4.0)
+
+    def __init__(self, scale: float, goal: Tuple[int, int] = (4.0, -2.0)) -> None:
+        super().__init__(scale)
+        self.goals = [MazeGoal(np.array(goal) * scale)]
+
+    def reward(self, obs: np.ndarray) -> float:
+        for goal in self.goals:
+            if goal.neighbor(obs):
+                return goal.reward_scale
+        return self.PENALTY
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B, R = MazeCell.EMPTY, MazeCell.BLOCK, MazeCell.ROBOT
+        return [
+            [B, B, B, B, B, B, B, B],
+            [B, E, E, E, B, E, E, B],
+            [B, E, E, E, B, E, E, B],
+            [B, E, R, E, B, E, E, B],
+            [B, E, E, E, B, E, E, B],
+            [B, E, E, E, E, E, E, B],
+            [B, B, B, B, B, B, B, B],
+        ]
+
+
+class DistReward2Rooms(GoalReward2Rooms, DistRewardMixIn):
+    pass
+
+
+class SubGoal2Rooms(GoalReward2Rooms):
+    def __init__(
+        self,
+        scale: float,
+        primary_goal: Tuple[float, float] = (4.0, -2.0),
+        subgoals: List[Tuple[float, float]] = [(1.0, -2.0), (-1.0, 2.0)],
+    ) -> None:
+        super().__init__(scale, primary_goal)
+        for subgoal in subgoals:
+            self.goals.append(
+                MazeGoal(np.array(subgoal) * scale, reward_scale=0.5, rgb=GREEN)
+            )
+
+
+class GoalReward4Rooms(MazeTask):
+    REWARD_THRESHOLD: float = 0.9
+    PENALTY: float = -0.0001
+    MAZE_SIZE_SCALING: Scaling = Scaling(4.0, 4.0, 4.0)
+
+    def __init__(self, scale: float) -> None:
+        super().__init__(scale)
+        self.goals = [MazeGoal(np.array([6.0 * scale, -6.0 * scale]))]
+
+    def reward(self, obs: np.ndarray) -> float:
+        for goal in self.goals:
+            if goal.neighbor(obs):
+                return goal.reward_scale
+        return self.PENALTY
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B, R = MazeCell.EMPTY, MazeCell.BLOCK, MazeCell.ROBOT
+        return [
+            [B, B, B, B, B, B, B, B, B],
+            [B, E, E, E, B, E, E, E, B],
+            [B, E, E, E, E, E, E, E, B],
+            [B, E, E, E, B, E, E, E, B],
+            [B, B, E, B, B, B, E, B, B],
+            [B, E, E, E, B, E, E, E, B],
+            [B, E, E, E, E, E, E, E, B],
+            [B, R, E, E, B, E, E, E, B],
+            [B, B, B, B, B, B, B, B, B],
+        ]
+
+
+class DistReward4Rooms(GoalReward4Rooms, DistRewardMixIn):
+    pass
+
+
+class SubGoal4Rooms(GoalReward4Rooms):
+    def __init__(self, scale: float) -> None:
+        super().__init__(scale)
+        self.goals += [
+            MazeGoal(np.array([0.0 * scale, -6.0 * scale]), 0.5, GREEN),
+            MazeGoal(np.array([6.0 * scale, 0.0 * scale]), 0.5, GREEN),
+        ]
+
+
+class GoalRewardTRoom(MazeTask):
+    REWARD_THRESHOLD: float = 0.9
+    PENALTY: float = -0.0001
+    MAZE_SIZE_SCALING: Scaling = Scaling(4.0, 4.0, 4.0)
+
+    def __init__(self, scale: float, goal: Tuple[float, float] = (2.0, -3.0)) -> None:
+        super().__init__(scale)
+        self.goals = [MazeGoal(np.array(goal) * scale)]
+
+    def reward(self, obs: np.ndarray) -> float:
+        for goal in self.goals:
+            if goal.neighbor(obs):
+                return goal.reward_scale
+        return self.PENALTY
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B, R = MazeCell.EMPTY, MazeCell.BLOCK, MazeCell.ROBOT
+        return [
+            [B, B, B, B, B, B, B],
+            [B, E, E, B, E, E, B],
+            [B, E, E, B, E, E, B],
+            [B, E, B, B, B, E, B],
+            [B, E, E, R, E, E, B],
+            [B, B, B, B, B, B, B],
+        ]
+
+
+class DistRewardTRoom(GoalRewardTRoom, DistRewardMixIn):
+    pass
+
+
+class SubGoalTRoom(GoalRewardTRoom):
+    def __init__(
+        self,
+        scale: float,
+        primary_goal: Tuple[float, float] = (2.0, -3.0),
+        subgoal: Tuple[float, float] = (-2.0, -3.0),
+    ) -> None:
+        super().__init__(scale, primary_goal)
+        self.goals.append(
+            MazeGoal(np.array(subgoal) * scale, reward_scale=0.5, rgb=GREEN)
+        )
+
+
+class GoalRewardBlockMaze(GoalRewardUMaze):
+    MAZE_SIZE_SCALING: Scaling = Scaling(8.0, 4.0, None)
+    OBSERVE_BLOCKS: bool = True
+
+    def __init__(self, scale: float) -> None:
+        super().__init__(scale)
+        self.goals = [MazeGoal(np.array([0.0, 3.0 * scale]))]
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B, R = MazeCell.EMPTY, MazeCell.BLOCK, MazeCell.ROBOT
+        M = MazeCell.XY_BLOCK
+        return [
+            [B, B, B, B, B],
+            [B, R, E, E, B],
+            [B, B, B, M, B],
+            [B, E, E, E, B],
+            [B, E, E, E, B],
+            [B, B, B, B, B],
+        ]
+
+
+class DistRewardBlockMaze(GoalRewardBlockMaze, DistRewardMixIn):
+    pass
+
+
+class GoalRewardBilliard(MazeTask):
+    REWARD_THRESHOLD: float = 0.9
+    PENALTY: float = -0.0001
+    MAZE_SIZE_SCALING: Scaling = Scaling(None, 3.0, None)
+    OBSERVE_BALLS: bool = True
+    GOAL_SIZE: float = 0.3
+
+    def __init__(self, scale: float, goal: Tuple[float, float] = (2.0, -3.0)) -> None:
+        super().__init__(scale)
+        goal = np.array(goal) * scale
+        self.goals.append(
+            MazeGoal(goal, threshold=self._threshold(), custom_size=self.GOAL_SIZE)
+        )
+
+    def _threshold(self) -> float:
+        return self.OBJECT_BALL_SIZE + self.GOAL_SIZE
+
+    def reward(self, obs: np.ndarray) -> float:
+        object_pos = obs[3:6]
+        for goal in self.goals:
+            if goal.neighbor(object_pos):
+                return goal.reward_scale
+        return self.PENALTY
+
+    def termination(self, obs: np.ndarray) -> bool:
+        object_pos = obs[3:6]
+        for goal in self.goals:
+            if goal.neighbor(object_pos):
+                return True
+        return False
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B = MazeCell.EMPTY, MazeCell.BLOCK
+        R, M = MazeCell.ROBOT, MazeCell.OBJECT_BALL
+        return [
+            [B, B, B, B, B, B, B],
+            [B, E, E, E, E, E, B],
+            [B, E, E, E, E, E, B],
+            [B, E, E, M, E, E, B],
+            [B, E, E, R, E, E, B],
+            [B, E, E, E, E, E, B],
+            [B, B, B, B, B, B, B],
+        ]
+
+
+class DistRewardBilliard(GoalRewardBilliard):
+    def reward(self, obs: np.ndarray) -> float:
+        return -self.goals[0].euc_dist(obs[3:6]) / self.scale
+
+
+class SubGoalBilliard(GoalRewardBilliard):
+    def __init__(
+        self,
+        scale: float,
+        primary_goal: Tuple[float, float] = (2.0, -3.0),
+        subgoals: List[Tuple[float, float]] = [(-2.0, -3.0), (-2.0, 1.0), (2.0, 1.0)],
+    ) -> None:
+        super().__init__(scale, primary_goal)
+        for subgoal in subgoals:
+            self.goals.append(
+                MazeGoal(
+                    np.array(subgoal) * scale,
+                    reward_scale=0.5,
+                    rgb=GREEN,
+                    threshold=self._threshold(),
+                    custom_size=self.GOAL_SIZE,
+                )
+            )
+
+
+class BanditBilliard(SubGoalBilliard):
+    def __init__(
+        self,
+        scale: float,
+        primary_goal: Tuple[float, float] = (4.0, -2.0),
+        subgoals: List[Tuple[float, float]] = [(4.0, 2.0)],
+    ) -> None:
+        super().__init__(scale, primary_goal, subgoals)
+
+    @staticmethod
+    def create_maze() -> List[List[MazeCell]]:
+        E, B = MazeCell.EMPTY, MazeCell.BLOCK
+        R, M = MazeCell.ROBOT, MazeCell.OBJECT_BALL
+        return [
+            [B, B, B, B, B, B, B],
+            [B, E, E, B, B, E, B],
+            [B, E, E, E, E, E, B],
+            [B, R, M, E, B, B, B],
+            [B, E, E, E, E, E, B],
+            [B, E, E, E, E, E, B],
+            [B, B, B, B, B, B, B],
+        ]
+
+
+class TaskRegistry:
+    REGISTRY: Dict[str, List[Type[MazeTask]]] = {
+        "SimpleRoom": [DistRewardSimpleRoom, GoalRewardSimpleRoom],
+        "UMaze": [DistRewardUMaze, GoalRewardUMaze],
+        "Push": [DistRewardPush, GoalRewardPush],
+        "Fall": [DistRewardFall, GoalRewardFall],
+        "2Rooms": [DistReward2Rooms, GoalReward2Rooms, SubGoal2Rooms],
+        "4Rooms": [DistReward4Rooms, GoalReward4Rooms, SubGoal4Rooms],
+        "TRoom": [DistRewardTRoom, GoalRewardTRoom, SubGoalTRoom],
+        "BlockMaze": [DistRewardBlockMaze, GoalRewardBlockMaze],
+        "Billiard": [
+            DistRewardBilliard,
+            GoalRewardBilliard,
+            SubGoalBilliard,
+            BanditBilliard,
+        ],
+    }
+
+    @staticmethod
+    def keys() -> List[str]:
+        return list(TaskRegistry.REGISTRY.keys())
+
+    @staticmethod
+    def tasks(key: str) -> List[Type[MazeTask]]:
+        return TaskRegistry.REGISTRY[key]
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/point.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/point.py
new file mode 100644
index 0000000..4602746
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/point.py
@@ -0,0 +1,81 @@
+"""
+A ball-like robot as an explorer in the maze.
+Based on `models`_ and `rllab`_.
+
+.. _models: https://github.com/tensorflow/models/tree/master/research/efficient-hrl
+.. _rllab: https://github.com/rll/rllab
+"""
+
+from typing import Optional, Tuple
+
+import gym
+import numpy as np
+
+from slbo.envs.mujoco_maze.agent_model import AgentModel
+
+
+class PointEnv(AgentModel):
+    FILE: str = "point.xml"
+    ORI_IND: int = 2
+    MANUAL_COLLISION: bool = True
+    RADIUS: float = 0.4
+
+    VELOCITY_LIMITS: float = 10.0
+
+    def __init__(self, file_path: Optional[str] = None):
+        super().__init__(file_path, 1)
+        high = np.inf * np.ones(6, dtype=np.float32)
+        high[3:] = self.VELOCITY_LIMITS * 1.2
+        high[self.ORI_IND] = np.pi
+        low = -high
+        self.observation_space = gym.spaces.Box(low, high)
+
+    def step(self, action: np.ndarray) -> Tuple[np.ndarray, float, bool, dict]:
+        qpos = self.sim.data.qpos.copy()
+        qpos[2] += action[1]
+        # Clip orientation
+        if qpos[2] < -np.pi:
+            qpos[2] += np.pi * 2
+        elif np.pi < qpos[2]:
+            qpos[2] -= np.pi * 2
+        ori = qpos[2]
+        # Compute increment in each direction
+        qpos[0] += np.cos(ori) * action[0]
+        qpos[1] += np.sin(ori) * action[0]
+        qvel = np.clip(self.sim.data.qvel, -self.VELOCITY_LIMITS, self.VELOCITY_LIMITS)
+        self.set_state(qpos, qvel)
+        for _ in range(0, self.frame_skip):
+            self.sim.step()
+        next_obs = self._get_obs()
+        return next_obs, 0.0, False, {}
+
+    def _get_obs(self):
+        return np.concatenate(
+            [
+                self.sim.data.qpos.flat[:3],  # Only point-relevant coords.
+                self.sim.data.qvel.flat[:3],
+            ]
+        )
+
+    def reset_model(self):
+        qpos = self.init_qpos + self.np_random.uniform(
+            size=self.sim.model.nq, low=-0.1, high=0.1
+        )
+        qvel = self.init_qvel + self.np_random.randn(self.sim.model.nv) * 0.1
+
+        # Set everything other than point to original position and 0 velocity.
+        qpos[3:] = self.init_qpos[3:]
+        qvel[3:] = 0.0
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def get_xy(self):
+        return self.sim.data.qpos[:2].copy()
+
+    def set_xy(self, xy: np.ndarray) -> None:
+        qpos = self.sim.data.qpos.copy()
+        qpos[:2] = xy
+        self.set_state(qpos, self.sim.data.qvel)
+
+    def get_ori(self):
+        return self.sim.data.qpos[self.ORI_IND]
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/reacher.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/reacher.py
new file mode 100644
index 0000000..d2db6aa
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/reacher.py
@@ -0,0 +1,72 @@
+"""
+Based on the reacher in `dm_control`_.
+
+.. _gym: https://github.com/openai/gym
+"""
+
+from typing import Tuple
+
+import numpy as np
+
+from slbo.envs.mujoco_maze.agent_model import AgentModel
+from slbo.envs.mujoco_maze.ant import ForwardRewardFn, forward_reward_vnorm
+
+
+class ReacherEnv(AgentModel):
+    FILE: str = "reacher.xml"
+    MANUAL_COLLISION: bool = False
+
+    def __init__(
+        self,
+        file_path: str = None,
+        forward_reward_weight: float = 1.0,
+        ctrl_cost_weight: float = 1e-4,
+        forward_reward_fn: ForwardRewardFn = forward_reward_vnorm,
+    ) -> None:
+        self._forward_reward_weight = forward_reward_weight
+        self._ctrl_cost_weight = ctrl_cost_weight
+        self._forward_reward_fn = forward_reward_fn
+        super().__init__(file_path, 4)
+
+    def _forward_reward(self, xy_pos_before: np.ndarray) -> Tuple[float, np.ndarray]:
+        xy_pos_after = self.sim.data.qpos[:2].copy()
+        xy_velocity = (xy_pos_after - xy_pos_before) / self.dt
+        return self._forward_reward_fn(xy_velocity)
+
+    def step(self, action: np.ndarray) -> Tuple[np.ndarray, float, bool, dict]:
+        xy_pos_before = self.sim.data.qpos[:2].copy()
+        self.do_simulation(action, self.frame_skip)
+
+        forward_reward = self._forward_reward(xy_pos_before)
+        ctrl_cost = self._ctrl_cost_weight * np.sum(np.square(action))
+        return (
+            self._get_obs(),
+            self._forward_reward_weight * forward_reward - ctrl_cost,
+            False,
+            dict(reward_forward=forward_reward, reward_ctrl=-ctrl_cost),
+        )
+
+    def _get_obs(self) -> np.ndarray:
+        position = self.sim.data.qpos.flat.copy()
+        velocity = self.sim.data.qvel.flat.copy()
+        observation = np.concatenate([position, velocity]).ravel()
+        return observation
+
+    def reset_model(self) -> np.ndarray:
+        qpos = self.init_qpos + self.np_random.uniform(
+            low=-0.1, high=0.1, size=self.model.nq,
+        )
+        qvel = self.init_qvel + self.np_random.uniform(
+            low=-0.1, high=0.1, size=self.model.nv,
+        )
+
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def set_xy(self, xy: np.ndarray) -> None:
+        qpos = self.sim.data.qpos.copy()
+        qpos[:2] = xy
+        self.set_state(qpos, self.sim.data.qvel)
+
+    def get_xy(self) -> np.ndarray:
+        return np.copy(self.sim.data.qpos[:2])
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/swimmer.py b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/swimmer.py
new file mode 100644
index 0000000..cd825df
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/mujoco_maze/swimmer.py
@@ -0,0 +1,73 @@
+"""
+Swimmer robot as an explorer in the maze.
+Based on `gym`_ (swimmer-v3).
+
+.. _gym: https://github.com/openai/gym
+"""
+
+from typing import Tuple
+
+import numpy as np
+
+from slbo.envs.mujoco_maze.agent_model import AgentModel
+from slbo.envs.mujoco_maze.ant import ForwardRewardFn, forward_reward_vnorm
+
+
+class SwimmerEnv(AgentModel):
+    FILE: str = "swimmer.xml"
+    MANUAL_COLLISION: bool = False
+
+    def __init__(
+        self,
+        file_path: str = None,
+        forward_reward_weight: float = 1.0,
+        ctrl_cost_weight: float = 1e-4,
+        forward_reward_fn: ForwardRewardFn = forward_reward_vnorm,
+    ) -> None:
+        self._forward_reward_weight = forward_reward_weight
+        self._ctrl_cost_weight = ctrl_cost_weight
+        self._forward_reward_fn = forward_reward_fn
+        super().__init__(file_path, 4)
+
+    def _forward_reward(self, xy_pos_before: np.ndarray) -> Tuple[float, np.ndarray]:
+        xy_pos_after = self.sim.data.qpos[:2].copy()
+        xy_velocity = (xy_pos_after - xy_pos_before) / self.dt
+        return self._forward_reward_fn(xy_velocity)
+
+    def step(self, action: np.ndarray) -> Tuple[np.ndarray, float, bool, dict]:
+        xy_pos_before = self.sim.data.qpos[:2].copy()
+        self.do_simulation(action, self.frame_skip)
+
+        forward_reward = self._forward_reward(xy_pos_before)
+        ctrl_cost = self._ctrl_cost_weight * np.sum(np.square(action))
+        return (
+            self._get_obs(),
+            self._forward_reward_weight * forward_reward - ctrl_cost,
+            False,
+            dict(reward_forward=forward_reward, reward_ctrl=-ctrl_cost),
+        )
+
+    def _get_obs(self) -> np.ndarray:
+        position = self.sim.data.qpos.flat.copy()
+        velocity = self.sim.data.qvel.flat.copy()
+        observation = np.concatenate([position, velocity]).ravel()
+        return observation
+
+    def reset_model(self) -> np.ndarray:
+        qpos = self.init_qpos + self.np_random.uniform(
+            low=-0.1, high=0.1, size=self.model.nq,
+        )
+        qvel = self.init_qvel + self.np_random.uniform(
+            low=-0.1, high=0.1, size=self.model.nv,
+        )
+
+        self.set_state(qpos, qvel)
+        return self._get_obs()
+
+    def set_xy(self, xy: np.ndarray) -> None:
+        qpos = self.sim.data.qpos.copy()
+        qpos[:2] = xy
+        self.set_state(qpos, self.sim.data.qvel)
+
+    def get_xy(self) -> np.ndarray:
+        return np.copy(self.sim.data.qpos[:2])
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/LICENSE.md b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/LICENSE.md
new file mode 100644
index 0000000..22ce901
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/LICENSE.md
@@ -0,0 +1,222 @@
+# Fetch Robotics
+The model of the [Fetch](http://fetchrobotics.com/platforms-research-development/) is based on [models provided by Fetch](https://github.com/fetchrobotics/fetch_ros/tree/indigo-devel/fetch_description). It was adapted and refined by OpenAI.
+
+# ShadowHand
+The model of the [ShadowHand](https://www.shadowrobot.com/products/dexterous-hand/) is based on [models provided by ShadowRobot](https://github.com/shadow-robot/sr_common/tree/kinetic-devel/sr_description/hand/model), and on code used under the following license:
+
+(C) Vikash Kumar, CSE, UW. Licensed under Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
+
+	                                 Apache License
+	                           Version 2.0, January 2004
+	                        http://www.apache.org/licenses/
+
+	   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+	   1. Definitions.
+
+	      "License" shall mean the terms and conditions for use, reproduction,
+	      and distribution as defined by Sections 1 through 9 of this document.
+
+	      "Licensor" shall mean the copyright owner or entity authorized by
+	      the copyright owner that is granting the License.
+
+	      "Legal Entity" shall mean the union of the acting entity and all
+	      other entities that control, are controlled by, or are under common
+	      control with that entity. For the purposes of this definition,
+	      "control" means (i) the power, direct or indirect, to cause the
+	      direction or management of such entity, whether by contract or
+	      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+	      outstanding shares, or (iii) beneficial ownership of such entity.
+
+	      "You" (or "Your") shall mean an individual or Legal Entity
+	      exercising permissions granted by this License.
+
+	      "Source" form shall mean the preferred form for making modifications,
+	      including but not limited to software source code, documentation
+	      source, and configuration files.
+
+	      "Object" form shall mean any form resulting from mechanical
+	      transformation or translation of a Source form, including but
+	      not limited to compiled object code, generated documentation,
+	      and conversions to other media types.
+
+	      "Work" shall mean the work of authorship, whether in Source or
+	      Object form, made available under the License, as indicated by a
+	      copyright notice that is included in or attached to the work
+	      (an example is provided in the Appendix below).
+
+	      "Derivative Works" shall mean any work, whether in Source or Object
+	      form, that is based on (or derived from) the Work and for which the
+	      editorial revisions, annotations, elaborations, or other modifications
+	      represent, as a whole, an original work of authorship. For the purposes
+	      of this License, Derivative Works shall not include works that remain
+	      separable from, or merely link (or bind by name) to the interfaces of,
+	      the Work and Derivative Works thereof.
+
+	      "Contribution" shall mean any work of authorship, including
+	      the original version of the Work and any modifications or additions
+	      to that Work or Derivative Works thereof, that is intentionally
+	      submitted to Licensor for inclusion in the Work by the copyright owner
+	      or by an individual or Legal Entity authorized to submit on behalf of
+	      the copyright owner. For the purposes of this definition, "submitted"
+	      means any form of electronic, verbal, or written communication sent
+	      to the Licensor or its representatives, including but not limited to
+	      communication on electronic mailing lists, source code control systems,
+	      and issue tracking systems that are managed by, or on behalf of, the
+	      Licensor for the purpose of discussing and improving the Work, but
+	      excluding communication that is conspicuously marked or otherwise
+	      designated in writing by the copyright owner as "Not a Contribution."
+
+	      "Contributor" shall mean Licensor and any individual or Legal Entity
+	      on behalf of whom a Contribution has been received by Licensor and
+	      subsequently incorporated within the Work.
+
+	   2. Grant of Copyright License. Subject to the terms and conditions of
+	      this License, each Contributor hereby grants to You a perpetual,
+	      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+	      copyright license to reproduce, prepare Derivative Works of,
+	      publicly display, publicly perform, sublicense, and distribute the
+	      Work and such Derivative Works in Source or Object form.
+
+	   3. Grant of Patent License. Subject to the terms and conditions of
+	      this License, each Contributor hereby grants to You a perpetual,
+	      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+	      (except as stated in this section) patent license to make, have made,
+	      use, offer to sell, sell, import, and otherwise transfer the Work,
+	      where such license applies only to those patent claims licensable
+	      by such Contributor that are necessarily infringed by their
+	      Contribution(s) alone or by combination of their Contribution(s)
+	      with the Work to which such Contribution(s) was submitted. If You
+	      institute patent litigation against any entity (including a
+	      cross-claim or counterclaim in a lawsuit) alleging that the Work
+	      or a Contribution incorporated within the Work constitutes direct
+	      or contributory patent infringement, then any patent licenses
+	      granted to You under this License for that Work shall terminate
+	      as of the date such litigation is filed.
+
+	   4. Redistribution. You may reproduce and distribute copies of the
+	      Work or Derivative Works thereof in any medium, with or without
+	      modifications, and in Source or Object form, provided that You
+	      meet the following conditions:
+
+	      (a) You must give any other recipients of the Work or
+	          Derivative Works a copy of this License; and
+
+	      (b) You must cause any modified files to carry prominent notices
+	          stating that You changed the files; and
+
+	      (c) You must retain, in the Source form of any Derivative Works
+	          that You distribute, all copyright, patent, trademark, and
+	          attribution notices from the Source form of the Work,
+	          excluding those notices that do not pertain to any part of
+	          the Derivative Works; and
+
+	      (d) If the Work includes a "NOTICE" text file as part of its
+	          distribution, then any Derivative Works that You distribute must
+	          include a readable copy of the attribution notices contained
+	          within such NOTICE file, excluding those notices that do not
+	          pertain to any part of the Derivative Works, in at least one
+	          of the following places: within a NOTICE text file distributed
+	          as part of the Derivative Works; within the Source form or
+	          documentation, if provided along with the Derivative Works; or,
+	          within a display generated by the Derivative Works, if and
+	          wherever such third-party notices normally appear. The contents
+	          of the NOTICE file are for informational purposes only and
+	          do not modify the License. You may add Your own attribution
+	          notices within Derivative Works that You distribute, alongside
+	          or as an addendum to the NOTICE text from the Work, provided
+	          that such additional attribution notices cannot be construed
+	          as modifying the License.
+
+	      You may add Your own copyright statement to Your modifications and
+	      may provide additional or different license terms and conditions
+	      for use, reproduction, or distribution of Your modifications, or
+	      for any such Derivative Works as a whole, provided Your use,
+	      reproduction, and distribution of the Work otherwise complies with
+	      the conditions stated in this License.
+
+	   5. Submission of Contributions. Unless You explicitly state otherwise,
+	      any Contribution intentionally submitted for inclusion in the Work
+	      by You to the Licensor shall be under the terms and conditions of
+	      this License, without any additional terms or conditions.
+	      Notwithstanding the above, nothing herein shall supersede or modify
+	      the terms of any separate license agreement you may have executed
+	      with Licensor regarding such Contributions.
+
+	   6. Trademarks. This License does not grant permission to use the trade
+	      names, trademarks, service marks, or product names of the Licensor,
+	      except as required for reasonable and customary use in describing the
+	      origin of the Work and reproducing the content of the NOTICE file.
+
+	   7. Disclaimer of Warranty. Unless required by applicable law or
+	      agreed to in writing, Licensor provides the Work (and each
+	      Contributor provides its Contributions) on an "AS IS" BASIS,
+	      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+	      implied, including, without limitation, any warranties or conditions
+	      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+	      PARTICULAR PURPOSE. You are solely responsible for determining the
+	      appropriateness of using or redistributing the Work and assume any
+	      risks associated with Your exercise of permissions under this License.
+
+	   8. Limitation of Liability. In no event and under no legal theory,
+	      whether in tort (including negligence), contract, or otherwise,
+	      unless required by applicable law (such as deliberate and grossly
+	      negligent acts) or agreed to in writing, shall any Contributor be
+	      liable to You for damages, including any direct, indirect, special,
+	      incidental, or consequential damages of any character arising as a
+	      result of this License or out of the use or inability to use the
+	      Work (including but not limited to damages for loss of goodwill,
+	      work stoppage, computer failure or malfunction, or any and all
+	      other commercial damages or losses), even if such Contributor
+	      has been advised of the possibility of such damages.
+
+	   9. Accepting Warranty or Additional Liability. While redistributing
+	      the Work or Derivative Works thereof, You may choose to offer,
+	      and charge a fee for, acceptance of support, warranty, indemnity,
+	      or other liability obligations and/or rights consistent with this
+	      License. However, in accepting such obligations, You may act only
+	      on Your own behalf and on Your sole responsibility, not on behalf
+	      of any other Contributor, and only if You agree to indemnify,
+	      defend, and hold each Contributor harmless for any liability
+	      incurred by, or claims asserted against, such Contributor by reason
+	      of your accepting any such warranty or additional liability.
+
+	   END OF TERMS AND CONDITIONS
+
+	   APPENDIX: How to apply the Apache License to your work.
+
+	      To apply the Apache License to your work, attach the following
+	      boilerplate notice, with the fields enclosed by brackets "[]"
+	      replaced with your own identifying information. (Don't include
+	      the brackets!)  The text should be enclosed in the appropriate
+	      comment syntax for the file format. We also recommend that a
+	      file or class name and description of purpose be included on the
+	      same "printed page" as the copyright notice for easier
+	      identification within third-party archives.
+
+	   Copyright [yyyy] [name of copyright owner]
+
+	   Licensed under the Apache License, Version 2.0 (the "License");
+	   you may not use this file except in compliance with the License.
+	   You may obtain a copy of the License at
+
+	       http://www.apache.org/licenses/LICENSE-2.0
+
+	   Unless required by applicable law or agreed to in writing, software
+	   distributed under the License is distributed on an "AS IS" BASIS,
+	   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+	   See the License for the specific language governing permissions and
+	   limitations under the License.
+
+Additional license notices:
+
+	Sources		: 1) Manipulator and Manipulation in High Dimensional Spaces. Vikash Kumar, Ph.D. Thesis, CSE, Univ. of Washington. 2016.
+
+	Mujoco		:: Advanced physics simulation engine
+		Source		: www.roboti.us
+		Version		: 1.40
+		Released 	: 17Jan'17
+
+	Author		:: Vikash Kumar
+		Contacts 	: vikash@openai.com
+		Last edits 	: 3Apr'17
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/pick_and_place.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/pick_and_place.xml
new file mode 100644
index 0000000..337032a
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/pick_and_place.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+	<compiler angle="radian" coordinate="local" meshdir="../stls/fetch" texturedir="../textures"></compiler>
+	<option timestep="0.002">
+		<flag warmstart="enable"></flag>
+	</option>
+
+	<include file="shared.xml"></include>
+	
+	<worldbody>
+		<geom name="floor0" pos="0.8 0.75 0" size="0.85 0.7 1" type="plane" condim="3" material="floor_mat"></geom>
+		<body name="floor0" pos="0.8 0.75 0">
+			<site name="target0" pos="0 0 0.5" size="0.02 0.02 0.02" rgba="1 0 0 1" type="sphere"></site>
+		</body>
+
+		<include file="robot.xml"></include>
+		
+		<body pos="1.3 0.75 0.2" name="table0">
+			<geom size="0.25 0.35 0.2" type="box" mass="2000" material="table_mat"></geom>
+		</body>
+		
+		<body name="object0" pos="0.025 0.025 0.025">
+			<joint name="object0:joint" type="free" damping="0.01"></joint>
+			<geom size="0.025 0.025 0.025" type="box" condim="3" name="object0" material="block_mat" mass="2"></geom>
+			<site name="object0" pos="0 0 0" size="0.02 0.02 0.02" rgba="1 0 0 1" type="sphere"></site>
+		</body>
+
+		<light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 0 4" dir="0 0 -1" name="light0"></light>
+	</worldbody>
+
+	<actuator>
+		<position ctrllimited="true" ctrlrange="0 0.2" joint="robot0:l_gripper_finger_joint" kp="30000" name="robot0:l_gripper_finger_joint" user="1"></position>
+		<position ctrllimited="true" ctrlrange="0 0.2" joint="robot0:r_gripper_finger_joint" kp="30000" name="robot0:r_gripper_finger_joint" user="1"></position>
+	</actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/push.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/push.xml
new file mode 100644
index 0000000..8e12db2
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/push.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+	<compiler angle="radian" coordinate="local" meshdir="../stls/fetch" texturedir="../textures"></compiler>
+	<option timestep="0.002">
+		<flag warmstart="enable"></flag>
+	</option>
+
+	<include file="shared.xml"></include>
+	
+	<worldbody>
+		<geom name="floor0" pos="0.8 0.75 0" size="0.85 0.70 1" type="plane" condim="3" material="floor_mat"></geom>
+		<body name="floor0" pos="0.8 0.75 0">
+			<site name="target0" pos="0 0 0.5" size="0.02 0.02 0.02" rgba="1 0 0 1" type="sphere"></site>
+		</body>
+
+		<include file="robot.xml"></include>
+
+		<body pos="1.3 0.75 0.2" name="table0">
+			<geom size="0.25 0.35 0.2" type="box" mass="2000" material="table_mat"></geom>
+		</body>
+		
+		<body name="object0" pos="0.025 0.025 0.025">
+			<joint name="object0:joint" type="free" damping="0.01"></joint>
+			<geom size="0.025 0.025 0.025" type="box" condim="3" name="object0" material="block_mat" mass="2"></geom>
+			<site name="object0" pos="0 0 0" size="0.02 0.02 0.02" rgba="1 0 0 1" type="sphere"></site>
+		</body>
+
+		<light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 0 4" dir="0 0 -1" name="light0"></light>
+	</worldbody>
+	
+	<actuator></actuator>
+</mujoco>
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/reach.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/reach.xml
new file mode 100644
index 0000000..c73d624
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/reach.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+	<compiler angle="radian" coordinate="local" meshdir="../stls/fetch" texturedir="../textures"></compiler>
+	<option timestep="0.002">
+		<flag warmstart="enable"></flag>
+	</option>
+
+	<include file="shared.xml"></include>
+	
+	<worldbody>
+		<geom name="floor0" pos="0.8 0.75 0" size="0.85 0.7 1" type="plane" condim="3" material="floor_mat"></geom>
+		<body name="floor0" pos="0.8 0.75 0">
+			<site name="target0" pos="0 0 0.5" size="0.02 0.02 0.02" rgba="1 0 0 1" type="sphere"></site>
+		</body>
+
+		<include file="robot.xml"></include>
+		
+		<body pos="1.3 0.75 0.2" name="table0">
+			<geom size="0.25 0.35 0.2" type="box" mass="2000" material="table_mat"></geom>
+		</body>
+
+		<light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 0 4" dir="0 0 -1" name="light0"></light>
+	</worldbody>
+	
+	<actuator></actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/robot.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/robot.xml
new file mode 100644
index 0000000..b627d49
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/robot.xml
@@ -0,0 +1,123 @@
+<mujoco>
+	<body mocap="true" name="robot0:mocap" pos="0 0 0">
+		<geom conaffinity="0" contype="0" pos="0 0 0" rgba="0 0.5 0 0.7" size="0.005 0.005 0.005" type="box"></geom>
+		<geom conaffinity="0" contype="0" pos="0 0 0" rgba="0 0.5 0 0.1" size="1 0.005 0.005" type="box"></geom>
+		<geom conaffinity="0" contype="0" pos="0 0 0" rgba="0 0.5 0 0.1" size="0.005 1 0.001" type="box"></geom>
+		<geom conaffinity="0" contype="0" pos="0 0 0" rgba="0 0.5 0 0.1" size="0.005 0.005 1" type="box"></geom>
+	</body>
+	<body childclass="robot0:fetch" name="robot0:base_link" pos="0.2869 0.2641 0">
+		<joint armature="0.0001" axis="1 0 0" damping="1e+11" name="robot0:slide0" pos="0 0 0" type="slide"></joint>
+		<joint armature="0.0001" axis="0 1 0" damping="1e+11" name="robot0:slide1" pos="0 0 0" type="slide"></joint>
+		<joint armature="0.0001" axis="0 0 1" damping="1e+11" name="robot0:slide2" pos="0 0 0" type="slide"></joint>
+		<inertial diaginertia="1.2869 1.2236 0.9868" mass="70.1294" pos="-0.0036 0 0.0014" quat="0.7605 -0.0133 -0.0061 0.6491"></inertial>
+		<geom mesh="robot0:base_link" name="robot0:base_link" material="robot0:base_mat" class="robot0:grey"></geom>
+		<body name="robot0:torso_lift_link" pos="-0.0869 0 0.3774">
+			<inertial diaginertia="0.3365 0.3354 0.0943" mass="10.7796" pos="-0.0013 -0.0009 0.2935" quat="0.9993 -0.0006 0.0336 0.0185"></inertial>
+			<joint axis="0 0 1" damping="1e+07" name="robot0:torso_lift_joint" range="0.0386 0.3861" type="slide"></joint>
+			<geom mesh="robot0:torso_lift_link" name="robot0:torso_lift_link" material="robot0:torso_mat"></geom>
+			<body name="robot0:head_pan_link" pos="0.0531 0 0.603">
+				<inertial diaginertia="0.0185 0.0128 0.0095" mass="2.2556" pos="0.0321 0.0161 0.039" quat="0.5148 0.5451 -0.453 0.4823"></inertial>
+				<joint axis="0 0 1" name="robot0:head_pan_joint" range="-1.57 1.57"></joint>
+				<geom mesh="robot0:head_pan_link" name="robot0:head_pan_link" material="robot0:head_mat" class="robot0:grey"></geom>
+				<body name="robot0:head_tilt_link" pos="0.1425 0 0.058">
+					<inertial diaginertia="0.0063 0.0059 0.0014" mass="0.9087" pos="0.0081 0.0025 0.0113" quat="0.6458 0.66 -0.274 0.2689"></inertial>
+					<joint axis="0 1 0" damping="1000" name="robot0:head_tilt_joint" range="-0.76 1.45" ref="0.06"></joint>
+					<geom mesh="robot0:head_tilt_link" name="robot0:head_tilt_link" material="robot0:head_mat" class="robot0:blue"></geom>
+					<body name="robot0:head_camera_link" pos="0.055 0 0.0225">
+						<inertial diaginertia="0 0 0" mass="0" pos="0.055 0 0.0225"></inertial>
+						<body name="robot0:head_camera_rgb_frame" pos="0 0.02 0">
+							<inertial diaginertia="0 0 0" mass="0" pos="0 0.02 0"></inertial>
+							<body name="robot0:head_camera_rgb_optical_frame" pos="0 0 0" quat="0.5 -0.5 0.5 -0.5">
+								<inertial diaginertia="0 0 0" mass="0" pos="0 0 0" quat="0.5 -0.5 0.5 -0.5"></inertial>
+								<camera euler="3.1415 0 0" fovy="50" name="head_camera_rgb" pos="0 0 0"></camera>
+							</body>
+						</body>
+						<body name="robot0:head_camera_depth_frame" pos="0 0.045 0">
+							<inertial diaginertia="0 0 0" mass="0" pos="0 0.045 0"></inertial>
+							<body name="robot0:head_camera_depth_optical_frame" pos="0 0 0" quat="0.5 -0.5 0.5 -0.5">
+								<inertial diaginertia="0 0 0" mass="0" pos="0 0 0" quat="0.5 -0.5 0.5 -0.5"></inertial>
+							</body>
+						</body>
+					</body>
+				</body>
+			</body>
+			<body name="robot0:shoulder_pan_link" pos="0.1195 0 0.3486">
+				<inertial diaginertia="0.009 0.0086 0.0041" mass="2.5587" pos="0.0927 -0.0056 0.0564" quat="-0.1364 0.7624 -0.1562 0.613"></inertial>
+				<joint axis="0 0 1" name="robot0:shoulder_pan_joint" range="-1.6056 1.6056"></joint>
+				<geom mesh="robot0:shoulder_pan_link" name="robot0:shoulder_pan_link" material="robot0:arm_mat"></geom>
+				<body name="robot0:shoulder_lift_link" pos="0.117 0 0.06">
+					<inertial diaginertia="0.0116 0.0112 0.0023" mass="2.6615" pos="0.1432 0.0072 -0.0001" quat="0.4382 0.4382 0.555 0.555"></inertial>
+					<joint axis="0 1 0" name="robot0:shoulder_lift_joint" range="-1.221 1.518"></joint>
+					<geom mesh="robot0:shoulder_lift_link" name="robot0:shoulder_lift_link" material="robot0:arm_mat" class="robot0:blue"></geom>
+					<body name="robot0:upperarm_roll_link" pos="0.219 0 0">
+						<inertial diaginertia="0.0047 0.0045 0.0019" mass="2.3311" pos="0.1165 0.0014 0" quat="-0.0136 0.707 0.0136 0.707"></inertial>
+						<joint axis="1 0 0" limited="false" name="robot0:upperarm_roll_joint"></joint>
+						<geom mesh="robot0:upperarm_roll_link" name="robot0:upperarm_roll_link" material="robot0:arm_mat"></geom>
+						<body name="robot0:elbow_flex_link" pos="0.133 0 0">
+							<inertial diaginertia="0.0086 0.0084 0.002" mass="2.1299" pos="0.1279 0.0073 0" quat="0.4332 0.4332 0.5589 0.5589"></inertial>
+							<joint axis="0 1 0" name="robot0:elbow_flex_joint" range="-2.251 2.251"></joint>
+							<geom mesh="robot0:elbow_flex_link" name="robot0:elbow_flex_link" material="robot0:arm_mat" class="robot0:blue"></geom>
+							<body name="robot0:forearm_roll_link" pos="0.197 0 0">
+								<inertial diaginertia="0.0035 0.0031 0.0015" mass="1.6563" pos="0.1097 -0.0266 0" quat="-0.0715 0.7035 0.0715 0.7035"></inertial>
+								<joint armature="2.7538" axis="1 0 0" damping="3.5247" frictionloss="0" limited="false" name="robot0:forearm_roll_joint" stiffness="10"></joint>
+								<geom mesh="robot0:forearm_roll_link" name="robot0:forearm_roll_link" material="robot0:arm_mat"></geom>
+								<body name="robot0:wrist_flex_link" pos="0.1245 0 0">
+									<inertial diaginertia="0.0042 0.0042 0.0018" mass="1.725" pos="0.0882 0.0009 -0.0001" quat="0.4895 0.4895 0.5103 0.5103"></inertial>
+									<joint axis="0 1 0" name="robot0:wrist_flex_joint" range="-2.16 2.16"></joint>
+									<geom mesh="robot0:wrist_flex_link" name="robot0:wrist_flex_link" material="robot0:arm_mat" class="robot0:blue"></geom>
+									<body name="robot0:wrist_roll_link" pos="0.1385 0 0">
+										<inertial diaginertia="0.0001 0.0001 0.0001" mass="0.1354" pos="0.0095 0.0004 -0.0002"></inertial>
+										<joint axis="1 0 0" limited="false" name="robot0:wrist_roll_joint"></joint>
+										<geom mesh="robot0:wrist_roll_link" name="robot0:wrist_roll_link" material="robot0:arm_mat"></geom>
+										<body euler="0 0 0" name="robot0:gripper_link" pos="0.1664 0 0">
+											<inertial diaginertia="0.0024 0.0019 0.0013" mass="1.5175" pos="-0.09 -0.0001 -0.0017" quat="0 0.7071 0 0.7071"></inertial>
+											<geom mesh="robot0:gripper_link" name="robot0:gripper_link" material="robot0:gripper_mat"></geom>
+											<body name="robot0:gripper_camera_link" pos="0.055 0 0.0225">
+												<body name="robot0:gripper_camera_rgb_frame" pos="0 0.02 0">
+													<body name="robot0:gripper_camera_rgb_optical_frame" pos="0 0 0" quat="0.5 -0.5 0.5 -0.5">
+														<camera euler="3.1415 0 0" fovy="50" name="gripper_camera_rgb" pos="0 0 0"></camera>
+													</body>
+												</body>
+												<body name="robot0:gripper_camera_depth_frame" pos="0 0.045 0">
+													<body name="robot0:gripper_camera_depth_optical_frame" pos="0 0 0" quat="0.5 -0.5 0.5 -0.5"></body>
+												</body>
+											</body>
+
+											<body childclass="robot0:fetchGripper" name="robot0:r_gripper_finger_link" pos="0 0.0159 0">
+												<inertial diaginertia="0.1 0.1 0.1" mass="4" pos="-0.01 0 0"></inertial>
+												<joint axis="0 1 0" name="robot0:r_gripper_finger_joint" range="0 0.05"></joint>
+												<geom pos="0 -0.008 0" size="0.0385 0.007 0.0135" type="box" name="robot0:r_gripper_finger_link" material="robot0:gripper_finger_mat" condim="4" friction="1 0.05 0.01"></geom>
+											</body>
+											<body childclass="robot0:fetchGripper" name="robot0:l_gripper_finger_link" pos="0 -0.0159 0">
+												<inertial diaginertia="0.1 0.1 0.1" mass="4" pos="-0.01 0 0"></inertial>
+												<joint axis="0 -1 0" name="robot0:l_gripper_finger_joint" range="0 0.05"></joint>
+												<geom pos="0 0.008 0" size="0.0385 0.007 0.0135" type="box" name="robot0:l_gripper_finger_link" material="robot0:gripper_finger_mat" condim="4" friction="1 0.05 0.01"></geom>
+											</body>
+											<site name="robot0:grip" pos="0.02 0 0" rgba="0 0 0 0" size="0.02 0.02 0.02"></site>
+										</body>
+									</body>
+								</body>
+							</body>
+						</body>
+					</body>
+				</body>
+			</body>
+		</body>
+		<body name="robot0:estop_link" pos="-0.1246 0.2389 0.3113" quat="0.7071 0.7071 0 0">
+			<inertial diaginertia="0 0 0" mass="0.002" pos="0.0024 -0.0033 0.0067" quat="0.3774 -0.1814 0.1375 0.8977"></inertial>
+			<geom mesh="robot0:estop_link" rgba="0.8 0 0 1" name="robot0:estop_link"></geom>
+		</body>
+		<body name="robot0:laser_link" pos="0.235 0 0.2878" quat="0 1 0 0">
+			<inertial diaginertia="0 0 0" mass="0.0083" pos="-0.0306 0.0007 0.0552" quat="0.5878 0.5378 -0.4578 0.3945"></inertial>
+			<geom mesh="robot0:laser_link" rgba="0.7922 0.8196 0.9333 1" name="robot0:laser_link"></geom>
+			<camera euler="1.55 -1.55 3.14" fovy="25" name="lidar" pos="0 0 0.02"></camera>
+		</body>
+		<body name="robot0:torso_fixed_link" pos="-0.0869 0 0.3774">
+			<inertial diaginertia="0.3865 0.3394 0.1009" mass="13.2775" pos="-0.0722 0.0057 0.2656" quat="0.9995 0.0249 0.0177 0.011"></inertial>
+			<geom mesh="robot0:torso_fixed_link" name="robot0:torso_fixed_link" class="robot0:blue"></geom>
+		</body>
+		<body name="robot0:external_camera_body_0" pos="0 0 0">
+			<camera euler="0 0.75 1.57" fovy="43.3" name="external_camera_0" pos="1.3 0 1.2"></camera>
+		</body>
+	</body>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/shared.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/shared.xml
new file mode 100644
index 0000000..5d61fef
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/shared.xml
@@ -0,0 +1,66 @@
+<mujoco>
+    <asset>
+        <texture type="skybox" builtin="gradient" rgb1="0.44 0.85 0.56" rgb2="0.46 0.87 0.58" width="32" height="32"></texture>
+        <texture name="texture_block" file="block.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+
+        <material name="floor_mat" specular="0" shininess="0.5" reflectance="0" rgba="0.2 0.2 0.2 1"></material>
+        <material name="table_mat" specular="0" shininess="0.5" reflectance="0" rgba="0.93 0.93 0.93 1"></material>
+        <material name="block_mat" specular="0" shininess="0.5" reflectance="0" rgba="0.2 0.2 0.2 1"></material>
+        <material name="puck_mat" specular="0" shininess="0.5" reflectance="0" rgba="0.2 0.2 0.2 1"></material>
+        <material name="robot0:geomMat" shininess="0.03" specular="0.4"></material>
+        <material name="robot0:gripper_finger_mat" shininess="0.03" specular="0.4" reflectance="0"></material>
+        <material name="robot0:gripper_mat" shininess="0.03" specular="0.4" reflectance="0"></material>
+        <material name="robot0:arm_mat" shininess="0.03" specular="0.4" reflectance="0"></material>
+        <material name="robot0:head_mat" shininess="0.03" specular="0.4" reflectance="0"></material>
+        <material name="robot0:torso_mat" shininess="0.03" specular="0.4" reflectance="0"></material>
+        <material name="robot0:base_mat" shininess="0.03" specular="0.4" reflectance="0"></material>
+        
+        <mesh file="base_link_collision.stl" name="robot0:base_link"></mesh>
+        <mesh file="bellows_link_collision.stl" name="robot0:bellows_link"></mesh>
+        <mesh file="elbow_flex_link_collision.stl" name="robot0:elbow_flex_link"></mesh>
+        <mesh file="estop_link.stl" name="robot0:estop_link"></mesh>
+        <mesh file="forearm_roll_link_collision.stl" name="robot0:forearm_roll_link"></mesh>
+        <mesh file="gripper_link.stl" name="robot0:gripper_link"></mesh>
+        <mesh file="head_pan_link_collision.stl" name="robot0:head_pan_link"></mesh>
+        <mesh file="head_tilt_link_collision.stl" name="robot0:head_tilt_link"></mesh>
+        <mesh file="l_wheel_link_collision.stl" name="robot0:l_wheel_link"></mesh>
+        <mesh file="laser_link.stl" name="robot0:laser_link"></mesh>
+        <mesh file="r_wheel_link_collision.stl" name="robot0:r_wheel_link"></mesh>
+        <mesh file="torso_lift_link_collision.stl" name="robot0:torso_lift_link"></mesh>
+        <mesh file="shoulder_pan_link_collision.stl" name="robot0:shoulder_pan_link"></mesh>
+        <mesh file="shoulder_lift_link_collision.stl" name="robot0:shoulder_lift_link"></mesh>
+        <mesh file="upperarm_roll_link_collision.stl" name="robot0:upperarm_roll_link"></mesh>
+        <mesh file="wrist_flex_link_collision.stl" name="robot0:wrist_flex_link"></mesh>
+        <mesh file="wrist_roll_link_collision.stl" name="robot0:wrist_roll_link"></mesh>
+        <mesh file="torso_fixed_link.stl" name="robot0:torso_fixed_link"></mesh>
+    </asset>
+
+    <equality>
+        <weld body1="robot0:mocap" body2="robot0:gripper_link" solimp="0.9 0.95 0.001" solref="0.02 1"></weld>
+    </equality>
+    
+    <contact>
+        <exclude body1="robot0:r_gripper_finger_link" body2="robot0:l_gripper_finger_link"></exclude>
+        <exclude body1="robot0:torso_lift_link" body2="robot0:torso_fixed_link"></exclude>
+        <exclude body1="robot0:torso_lift_link" body2="robot0:shoulder_pan_link"></exclude>
+    </contact>
+    
+    <default>
+        <default class="robot0:fetch">
+            <geom margin="0.001" material="robot0:geomMat" rgba="1 1 1 1" solimp="0.99 0.99 0.01" solref="0.01 1" type="mesh" user="0"></geom>
+            <joint armature="1" damping="50" frictionloss="0" stiffness="0"></joint>
+            
+            <default class="robot0:fetchGripper">
+                <geom condim="4" margin="0.001" type="box" user="0" rgba="0.356 0.361 0.376 1.0"></geom>
+                <joint armature="100" damping="1000" limited="true" solimplimit="0.99 0.999 0.01" solreflimit="0.01 1" type="slide"></joint>
+            </default>
+
+            <default class="robot0:grey">
+                <geom rgba="0.356 0.361 0.376 1.0"></geom>
+            </default>
+            <default class="robot0:blue">
+                <geom rgba="0.086 0.506 0.767 1.0"></geom>
+            </default>
+        </default>
+    </default>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/slide.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/slide.xml
new file mode 100644
index 0000000..efbfb51
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/fetch/slide.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+	<compiler angle="radian" coordinate="local" meshdir="../stls/fetch" texturedir="../textures"></compiler>
+	<option timestep="0.002">
+		<flag warmstart="enable"></flag>
+	</option>
+
+	<include file="shared.xml"></include>
+	
+	<worldbody>
+		<geom name="floor0" pos="1 0.75 0" size="1.05 0.7 1" type="plane" condim="3" material="floor_mat"></geom>
+		<body name="floor0" pos="1 0.75 0">
+			<site name="target0" pos="0 0 0.5" size="0.02 0.02 0.02" rgba="1 0 0 1" type="sphere"></site>
+		</body>
+
+		<include file="robot.xml"></include>
+		
+		<body name="table0" pos="1.32441906 0.75018422 0.2">
+			<geom size="0.625 0.45 0.2" type="box" condim="3" name="table0" material="table_mat" mass="2000" friction="0.1 0.005 0.0001"></geom>
+		</body>
+
+		<body name="object0" pos="0.025 0.025 0.02">
+			<joint name="object0:joint" type="free" damping="0.01"></joint>
+			<geom size="0.025 0.02" type="cylinder" condim="3" name="object0" material="puck_mat" friction="0.1 0.005 0.0001" mass="2"></geom>
+			<site name="object0" pos="0 0 0" size="0.02 0.02 0.02" rgba="1 0 0 1" type="sphere"></site>
+		</body>
+
+		<light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 0 4" dir="0 0 -1" name="light0"></light>
+	</worldbody>
+
+	<actuator></actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_block.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_block.xml
new file mode 100644
index 0000000..83a6517
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_block.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+    <compiler angle="radian" coordinate="local" meshdir="../stls/hand" texturedir="../textures"></compiler>
+    <option timestep="0.002" iterations="20" apirate="200">
+        <flag warmstart="enable"></flag>
+    </option>
+
+    <include file="shared.xml"></include>
+
+    <asset>
+        <include file="shared_asset.xml"></include>
+
+        <texture name="texture:object" file="block.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+        <texture name="texture:hidden" file="block_hidden.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+
+        <material name="material:object" texture="texture:object" specular="1" shininess="0.3" reflectance="0"></material>
+        <material name="material:hidden" texture="texture:hidden" specular="1" shininess="0.3" reflectance="0"></material>
+        <material name="material:target" texture="texture:object" specular="1" shininess="0.3" reflectance="0" rgba="1 1 1 0.5"></material>
+    </asset>
+
+    <worldbody>
+        <geom name="floor0" pos="1 1 0" size="1 1 1" type="plane" condim="3" material="floor_mat"></geom>
+        <body name="floor0" pos="1 1 0"></body>
+
+        <include file="robot.xml"></include>
+
+        <body name="object" pos="1 0.87 0.2">
+            <geom name="object" type="box" size="0.025 0.025 0.025" material="material:object" condim="4" density="567"></geom>
+            <geom name="object_hidden" type="box" size="0.024 0.024 0.024" material="material:hidden" condim="4" contype="0" conaffinity="0" mass="0"></geom>
+            <site name="object:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <joint name="object:joint" type="free" damping="0.01"></joint>
+        </body>
+        <body name="target" pos="1 0.87 0.2">
+            <geom name="target" type="box" size="0.025 0.025 0.025" material="material:target" condim="4" group="2" contype="0" conaffinity="0"></geom>
+            <site name="target:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <joint name="target:joint" type="free" damping="0.01"></joint>
+        </body>
+        
+        <light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 1 4" dir="0 0 -1" name="light0"></light>
+    </worldbody>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_block_touch_sensors.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_block_touch_sensors.xml
new file mode 100644
index 0000000..b649f10
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_block_touch_sensors.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+    <compiler angle="radian" coordinate="local" meshdir="../stls/hand" texturedir="../textures"></compiler>
+    <option timestep="0.002" iterations="20" apirate="200">
+        <flag warmstart="enable"></flag>
+    </option>
+
+    <include file="shared.xml"></include>
+    <include file="shared_touch_sensors_92.xml"></include>
+
+    <asset>
+        <include file="shared_asset.xml"></include>
+
+        <texture name="texture:object" file="block.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+        <texture name="texture:hidden" file="block_hidden.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+
+        <material name="material:object" texture="texture:object" specular="1" shininess="0.3" reflectance="0"></material>
+        <material name="material:hidden" texture="texture:hidden" specular="1" shininess="0.3" reflectance="0"></material>
+        <material name="material:target" texture="texture:object" specular="1" shininess="0.3" reflectance="0" rgba="1 1 1 0.5"></material>
+    </asset>
+
+    <worldbody>
+        <geom name="floor0" pos="1 1 0" size="1 1 1" type="plane" condim="3" material="floor_mat"></geom>
+        <body name="floor0" pos="1 1 0"></body>
+
+        <include file="robot_touch_sensors_92.xml"></include>
+
+        <body name="object" pos="1 0.87 0.2">
+            <geom name="object" type="box" size="0.025 0.025 0.025" material="material:object" condim="4" density="567"></geom>
+            <geom name="object_hidden" type="box" size="0.024 0.024 0.024" material="material:hidden" condim="4" contype="0" conaffinity="0" mass="0"></geom>
+            <site name="object:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <joint name="object:joint" type="free" damping="0.01"></joint>
+        </body>
+        <body name="target" pos="1 0.87 0.2">
+            <geom name="target" type="box" size="0.025 0.025 0.025" material="material:target" condim="4" group="2" contype="0" conaffinity="0"></geom>
+            <site name="target:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <joint name="target:joint" type="free" damping="0.01"></joint>
+        </body>
+
+        <light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 1 4" dir="0 0 -1" name="light0"></light>
+    </worldbody>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_egg.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_egg.xml
new file mode 100644
index 0000000..d60217f
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_egg.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+    <compiler angle="radian" coordinate="local" meshdir="../stls/hand" texturedir="../textures"></compiler>
+    <option timestep="0.002" iterations="20" apirate="200">
+        <flag warmstart="enable"></flag>
+    </option>
+
+    <include file="shared.xml"></include>
+
+    <asset>
+        <include file="shared_asset.xml"></include>
+
+        <texture name="texture:object" file="block.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+        <texture name="texture:hidden" file="block_hidden.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+
+        <material name="material:object" texture="texture:object" specular="1" shininess="0.3" reflectance="0"></material>
+        <material name="material:hidden" texture="texture:hidden" specular="1" shininess="0.3" reflectance="0"></material>
+        <material name="material:target" texture="texture:object" specular="1" shininess="0.3" reflectance="0" rgba="1 1 1 0.5"></material>
+    </asset>
+
+    <worldbody>
+        <geom name="floor0" pos="1 1 0" size="1 1 1" type="plane" condim="3" material="floor_mat"></geom>
+        <body name="floor0" pos="1 1 0"></body>
+
+        <include file="robot.xml"></include>
+
+        <body name="object" pos="1 0.87 0.2">
+            <geom name="object" type="ellipsoid" size="0.03 0.03 0.04" material="material:object" condim="4"></geom>
+            <geom name="object_hidden" type="ellipsoid" size="0.029 0.029 0.03" material="material:hidden" condim="4" contype="0" conaffinity="0" mass="0"></geom>
+            <site name="object:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <joint name="object:joint" type="free" damping="0.01"></joint>
+        </body>
+        <body name="target" pos="1 0.87 0.2">
+            <geom name="target" type="ellipsoid" size="0.03 0.03 0.04" material="material:target" condim="4" group="2" contype="0" conaffinity="0"></geom>
+            <site name="target:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <joint name="target:joint" type="free" damping="0.01"></joint>
+        </body>
+        
+        <light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 1 4" dir="0 0 -1" name="light0"></light>
+    </worldbody>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_egg_touch_sensors.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_egg_touch_sensors.xml
new file mode 100644
index 0000000..73af83c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_egg_touch_sensors.xml
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+    <compiler angle="radian" coordinate="local" meshdir="../stls/hand" texturedir="../textures"></compiler>
+    <option timestep="0.002" iterations="20" apirate="200">
+        <flag warmstart="enable"></flag>
+    </option>
+
+    <include file="shared.xml"></include>
+    <include file="shared_touch_sensors_92.xml"></include>
+
+    <asset>
+        <include file="shared_asset.xml"></include>
+
+        <texture name="texture:object" file="block.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+        <texture name="texture:hidden" file="block_hidden.png" gridsize="3 4" gridlayout=".U..LFRB.D.."></texture>
+
+        <material name="material:object" texture="texture:object" specular="1" shininess="0.3" reflectance="0"></material>
+        <material name="material:hidden" texture="texture:hidden" specular="1" shininess="0.3" reflectance="0"></material>
+        <material name="material:target" texture="texture:object" specular="1" shininess="0.3" reflectance="0" rgba="1 1 1 0.5"></material>
+    </asset>
+
+    <worldbody>
+        <geom name="floor0" pos="1 1 0" size="1 1 1" type="plane" condim="3" material="floor_mat"></geom>
+        <body name="floor0" pos="1 1 0"></body>
+
+        <include file="robot_touch_sensors_92.xml"></include>
+
+        <body name="object" pos="1 0.87 0.2">
+            <geom name="object" type="ellipsoid" size="0.03 0.03 0.04" material="material:object" condim="4"></geom>
+            <geom name="object_hidden" type="ellipsoid" size="0.029 0.029 0.03" material="material:hidden" condim="4" contype="0" conaffinity="0" mass="0"></geom>
+            <site name="object:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <joint name="object:joint" type="free" damping="0.01"></joint>
+        </body>
+        <body name="target" pos="1 0.87 0.2">
+            <geom name="target" type="ellipsoid" size="0.03 0.03 0.04" material="material:target" condim="4" group="2" contype="0" conaffinity="0"></geom>
+            <site name="target:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <joint name="target:joint" type="free" damping="0.01"></joint>
+        </body>
+
+        <light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 1 4" dir="0 0 -1" name="light0"></light>
+    </worldbody>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_pen.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_pen.xml
new file mode 100644
index 0000000..20a6fb5
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_pen.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+    <compiler angle="radian" coordinate="local" meshdir="../stls/hand" texturedir="../textures"></compiler>
+    <option timestep="0.002" iterations="20" apirate="200">
+        <flag warmstart="enable"></flag>
+    </option>
+
+    <include file="shared.xml"></include>
+
+    <asset>
+        <include file="shared_asset.xml"></include>
+
+        <material name="material:object" specular="0" shininess="0.5" reflectance="0.0" rgba="0.46 0.81 0.88 1.0"></material>
+        <material name="material:target" specular="0" shininess="0.5" reflectance="0.0" rgba="0.46 0.81 0.88 0.5"></material>
+    </asset>
+
+    <worldbody>
+        <geom name="floor0" pos="1 1 -0.2" size="1 1 1" type="plane" condim="3" material="floor_mat"></geom>
+        <body name="floor0" pos="1 1 0"></body>
+
+        <include file="robot.xml"></include>
+
+        <body name="object" pos="1 0.87 0.2" euler="-1 1 0">
+            <geom name="object" type="capsule" size="0.008 0.1" material="material:object" condim="4"></geom>
+            <site name="object:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <site name="object:top" pos="0 0 0.1" rgba="1 0 0 1" size="0.0081"></site>
+            <site name="object:bottom" pos="0 0 -0.1" rgba="0 1 0 1" size="0.0081"></site>
+            <joint name="object:joint" type="free" damping="0.01"></joint>
+        </body>
+        <body name="target" pos="1 0.87 0.2" euler="-1 1 0">
+            <geom name="target" type="capsule" size="0.008 0.1" material="material:target" condim="4" group="2" contype="0" conaffinity="0"></geom>
+            <site name="target:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <site name="target:top" pos="0 0 0.1" rgba="1 0 0 0.5" size="0.0081"></site>
+            <site name="target:bottom" pos="0 0 -0.1" rgba="0 1 0 0.5" size="0.0081"></site>
+            <joint name="target:joint" type="free" damping="0.01"></joint>
+        </body>
+        
+        <light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 1 4" dir="0 0 -1" name="light0"></light>
+    </worldbody>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_pen_touch_sensors.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_pen_touch_sensors.xml
new file mode 100644
index 0000000..758839b
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/manipulate_pen_touch_sensors.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+    <compiler angle="radian" coordinate="local" meshdir="../stls/hand" texturedir="../textures"></compiler>
+    <option timestep="0.002" iterations="20" apirate="200">
+        <flag warmstart="enable"></flag>
+    </option>
+
+    <include file="shared.xml"></include>
+    <include file="shared_touch_sensors_92.xml"></include>
+
+    <asset>
+        <include file="shared_asset.xml"></include>
+
+        <material name="material:object" specular="0" shininess="0.5" reflectance="0.0" rgba="0.46 0.81 0.88 1.0"></material>
+        <material name="material:target" specular="0" shininess="0.5" reflectance="0.0" rgba="0.46 0.81 0.88 0.5"></material>
+    </asset>
+
+    <worldbody>
+        <geom name="floor0" pos="1 1 -0.2" size="1 1 1" type="plane" condim="3" material="floor_mat"></geom>
+        <body name="floor0" pos="1 1 0"></body>
+
+        <include file="robot_touch_sensors_92.xml"></include>
+
+        <body name="object" pos="1 0.87 0.2" euler="-1 1 0">
+            <geom name="object" type="capsule" size="0.008 0.1" material="material:object" condim="4"></geom>
+            <site name="object:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <site name="object:top" pos="0 0 0.1" rgba="1 0 0 1" size="0.0081"></site>
+            <site name="object:bottom" pos="0 0 -0.1" rgba="0 1 0 1" size="0.0081"></site>
+            <joint name="object:joint" type="free" damping="0.01"></joint>
+        </body>
+        <body name="target" pos="1 0.87 0.2" euler="-1 1 0">
+            <geom name="target" type="capsule" size="0.008 0.1" material="material:target" condim="4" group="2" contype="0" conaffinity="0"></geom>
+            <site name="target:center" pos="0 0 0" rgba="1 0 0 0" size="0.01 0.01 0.01"></site>
+            <site name="target:top" pos="0 0 0.1" rgba="1 0 0 0.5" size="0.0081"></site>
+            <site name="target:bottom" pos="0 0 -0.1" rgba="0 1 0 0.5" size="0.0081"></site>
+            <joint name="target:joint" type="free" damping="0.01"></joint>
+        </body>
+
+        <light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 1 4" dir="0 0 -1" name="light0"></light>
+    </worldbody>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/reach.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/reach.xml
new file mode 100644
index 0000000..71f6dfe
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/reach.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<mujoco>
+    <compiler angle="radian" coordinate="local" meshdir="../stls/hand" texturedir="../textures"></compiler>
+    <option timestep="0.002" iterations="20" apirate="200">
+        <flag warmstart="enable"></flag>
+    </option>
+
+    <include file="shared.xml"></include>
+
+    <asset>
+        <include file="shared_asset.xml"></include>
+    </asset>
+
+    <worldbody>
+        <geom name="floor0" pos="1 1 0" size="1 1 1" type="plane" condim="3" material="floor_mat"></geom>
+        <body name="floor0" pos="1 1 0">
+            <site name="target0" pos="0 0 0" size="0.005" rgba="1 0 0 1" type="sphere"></site>
+            <site name="target1" pos="0 0 0" size="0.005" rgba="0 1 0 1" type="sphere"></site>
+            <site name="target2" pos="0 0 0" size="0.005" rgba="0 0 1 1" type="sphere"></site>
+            <site name="target3" pos="0 0 0" size="0.005" rgba="1 1 0 1" type="sphere"></site>
+            <site name="target4" pos="0 0 0" size="0.005" rgba="1 0 1 1" type="sphere"></site>
+
+            <site name="finger0" pos="0 0 0" size="0.01" rgba="1 0 0 0.2" type="sphere"></site>
+            <site name="finger1" pos="0 0 0" size="0.01" rgba="0 1 0 0.2" type="sphere"></site>
+            <site name="finger2" pos="0 0 0" size="0.01" rgba="0 0 1 0.2" type="sphere"></site>
+            <site name="finger3" pos="0 0 0" size="0.01" rgba="1 1 0 0.2" type="sphere"></site>
+            <site name="finger4" pos="0 0 0" size="0.01" rgba="1 0 1 0.2" type="sphere"></site>
+        </body>
+
+        <include file="robot.xml"></include>
+        
+        <light directional="true" ambient="0.2 0.2 0.2" diffuse="0.8 0.8 0.8" specular="0.3 0.3 0.3" castshadow="false" pos="0 0 4" dir="0 0 -1" name="light0"></light>
+    </worldbody>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/robot.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/robot.xml
new file mode 100644
index 0000000..dbb9e43
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/robot.xml
@@ -0,0 +1,160 @@
+<!-- See LICENSE.md for legal notices. LICENSE.md must be kept together with this file. -->
+<mujoco>
+    <body name="robot0:hand mount" pos="1 1.25 0.15" euler="1.5708 0 3.14159">
+        <inertial mass="0.1" pos="0 0 0" diaginertia="0.001 0.001 0.001"></inertial>
+        <body childclass="robot0:asset_class" name="robot0:forearm" pos="0 0.01 0" euler="0 0 0">
+            <inertial pos="0.001 -0.002 0.29" quat="0.982 -0.016 0 -0.188" mass="4" diaginertia="0.01 0.01 0.0075"></inertial>
+            <geom class="robot0:D_Vizual" pos="0 0.01 0.04" name="robot0:V_forearm" mesh="robot0:forearm" euler="0 0 1.57"></geom>
+            <geom class="robot0:DC_Hand" name="robot0:C_forearm" type="mesh" mesh="robot0:forearm_cvx" pos="0 0.01 0.04" euler="0 0 1.57" rgba="0.4 0.5 0.6 0.7"></geom>
+            <body name="robot0:wrist" pos="0 0 0.256">
+                <inertial pos="0.003 0 0.016" quat="0.504 0.496 0.495 0.504" mass="0.3" diaginertia="0.001 0.001 0.001"></inertial>
+                <joint name="robot0:WRJ1" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.489 0.14" damping="0.5" armature="0.005" user="1123"></joint>
+                <geom class="robot0:D_Vizual" name="robot0:V_wrist" mesh="robot0:wrist"></geom>
+                <geom class="robot0:DC_Hand" name="robot0:C_wrist" type="capsule" pos="0 0 0" quat="0.707 0.707 0 0" size="0.015 0.01" rgba="0.4 0.5 0.6 0.1"></geom>
+                <body name="robot0:palm" pos="0 0 0.034">
+                    <inertial pos="0.006 0 0.036" quat="0.716 0.044 0.075 0.693" mass="0.3" diaginertia="0.001 0.001 0.001"></inertial>
+                    <joint name="robot0:WRJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="-0.698 0.489" damping="0.5" armature="0.005" user="1122"></joint>
+                    <geom class="robot0:D_Vizual" name="robot0:V_palm" mesh="robot0:palm"></geom>
+                    <geom class="robot0:DC_Hand" name="robot0:C_palm0" type="box" pos="0.011 0 0.038" size="0.032 0.0111 0.049" rgba="0.4 0.5 0.6 0.1"></geom>
+                    <geom class="robot0:DC_Hand" name="robot0:C_palm1" type="box" pos="-0.032 0 0.014" size="0.011 0.0111 0.025" rgba="0.4 0.5 0.6 0.1"></geom>
+                    <body name="robot0:ffknuckle" pos="0.033 0 0.095">
+                        <inertial pos="0 0 0" quat="0.52 0.854 0.006 -0.003" mass="0.008" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:FFJ3" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.349 0.349" user="1103"></joint>
+                        <geom class="robot0:D_Vizual" name="robot0:V_ffknuckle" mesh="robot0:knuckle"></geom>
+                        <body name="robot0:ffproximal" pos="0 0 0">
+                            <inertial pos="0 0 0.023" quat="0.707 -0.004 0.004 0.707" mass="0.014" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:FFJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1102"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_ffproximal" mesh="robot0:F3"></geom>
+                            <geom class="robot0:DC_Hand" name="robot0:C_ffproximal" type="capsule" pos="0 0 0.0225" size="0.01 0.0225"></geom>
+                            <body name="robot0:ffmiddle" pos="0 0 0.045">
+                                <inertial pos="0 0 0.011" quat="0.707 0 0 0.707" mass="0.012" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:FFJ1" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1101"></joint>
+                                <geom class="robot0:D_Vizual" name="robot0:V_ffmiddle" mesh="robot0:F2"></geom>
+                                <geom class="robot0:DC_Hand" name="robot0:C_ffmiddle" type="capsule" pos="0 0 0.0125" size="0.00805 0.0125"></geom>
+                                <body name="robot0:ffdistal" pos="0 0 0.025">
+                                    <inertial pos="0 0 0.015" quat="0.707 -0.003 0.003 0.707" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:FFJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1100"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_ffdistal" pos="0 0 0.001" mesh="robot0:F1"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_ffdistal" type="capsule" pos="0 0 0.012" size="0.00705 0.012" condim="4"></geom>
+                                    <site name="robot0:S_fftip" pos="0 0 0.026" group="3"></site>
+                                    <site class="robot0:D_Touch" name="robot0:Tch_fftip"></site>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                    <body name="robot0:mfknuckle" pos="0.011 0 0.099">
+                        <inertial pos="0 0 0" quat="0.52 0.854 0.006 -0.003" mass="0.008" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:MFJ3" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.349 0.349" user="1107"></joint>
+                        <geom class="robot0:D_Vizual" name="robot0:V_mfknuckle" mesh="robot0:knuckle"></geom>
+                        <body name="robot0:mfproximal" pos="0 0 0">
+                            <inertial pos="0 0 0.023" quat="0.707 -0.004 0.004 0.707" mass="0.014" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:MFJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1106"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_mfproximal" mesh="robot0:F3"></geom>
+                            <geom class="robot0:DC_Hand" name="robot0:C_mfproximal" type="capsule" pos="0 0 0.0225" size="0.01 0.0225"></geom>
+                            <body name="robot0:mfmiddle" pos="0 0 0.045">
+                                <inertial pos="0 0 0.012" quat="0.707 0 0 0.707" mass="0.012" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:MFJ1" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1105"></joint>
+                                <geom class="robot0:D_Vizual" name="robot0:V_mfmiddle" mesh="robot0:F2"></geom>
+                                <geom class="robot0:DC_Hand" name="robot0:C_mfmiddle" type="capsule" pos="0 0 0.0125" size="0.00805 0.0125"></geom>
+                                <body name="robot0:mfdistal" pos="0 0 0.025">
+                                    <inertial pos="0 0 0.015" quat="0.707 -0.003 0.003 0.707" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:MFJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1104"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_mfdistal" mesh="robot0:F1"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_mfdistal" type="capsule" pos="0 0 0.012" size="0.00705 0.012" condim="4"></geom>
+                                    <site name="robot0:S_mftip" pos="0 0 0.026" group="3"></site>
+                                    <site class="robot0:D_Touch" name="robot0:Tch_mftip"></site>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                    <body name="robot0:rfknuckle" pos="-0.011 0 0.095">
+                        <inertial pos="0 0 0" quat="0.52 0.854 0.006 -0.003" mass="0.008" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:RFJ3" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.349 0.349" user="1111"></joint>
+                        <geom class="robot0:D_Vizual" name="robot0:V_rfknuckle" mesh="robot0:knuckle"></geom>
+                        <body name="robot0:rfproximal" pos="0 0 0">
+                            <inertial pos="0 0 0.023" quat="0.707 -0.004 0.004 0.707" mass="0.014" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:RFJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1110"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_rfproximal" mesh="robot0:F3"></geom>
+                            <geom class="robot0:DC_Hand" name="robot0:C_rfproximal" type="capsule" pos="0 0 0.0225" size="0.01 0.0225"></geom>
+                            <body name="robot0:rfmiddle" pos="0 0 0.045">
+                                <inertial pos="0 0 0.012" quat="0.707 0 0 0.707" mass="0.012" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:RFJ1" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1109"></joint>
+                                <geom class="robot0:D_Vizual" name="robot0:V_rfmiddle" mesh="robot0:F2"></geom>
+                                <geom class="robot0:DC_Hand" name="robot0:C_rfmiddle" type="capsule" pos="0 0 0.0125" size="0.00805 0.0125"></geom>
+                                <body name="robot0:rfdistal" pos="0 0 0.025">
+                                    <inertial pos="0 0 0.015" quat="0.707 -0.003 0.003 0.707" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:RFJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1108"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_rfdistal" mesh="robot0:F1" pos="0 0 0.001"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_rfdistal" type="capsule" pos="0 0 0.012" size="0.00705 0.012" condim="4"></geom>
+                                    <site name="robot0:S_rftip" pos="0 0 0.026" group="3"></site>
+                                    <site class="robot0:D_Touch" name="robot0:Tch_rftip"></site>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                    <body name="robot0:lfmetacarpal" pos="-0.017 0 0.044">
+                        <inertial pos="-0.014 0.001 0.014" quat="0.709 -0.092 -0.063 0.696" mass="0.075" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:LFJ4" type="hinge" pos="0 0 0" axis="0.571 0 0.821" range="0 0.785" user="1116"></joint>
+                        <geom class="robot0:D_Vizual" name="robot0:V_lfmetacarpal" pos="-0.016 0 -0.023" mesh="robot0:lfmetacarpal"></geom>
+                        <geom class="robot0:DC_Hand" name="robot0:C_lfmetacarpal" type="box" pos="-0.0165 0 0.01" size="0.0095 0.0111 0.025" rgba="0.4 0.5 0.6 0.2"></geom>
+                        <body name="robot0:lfknuckle" pos="-0.017 0 0.044">
+                            <inertial pos="0 0 0" quat="0.52 0.854 0.006 -0.003" mass="0.008" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:LFJ3" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.349 0.349" user="1115"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_lfknuckle" mesh="robot0:knuckle"></geom>
+                            <body name="robot0:lfproximal" pos="0 0 0">
+                                <inertial pos="0 0 0.023" quat="0.707 -0.004 0.004 0.707" mass="0.014" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:LFJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1114"></joint>
+                                <geom class="robot0:D_Vizual" name="robot0:V_lfproximal" mesh="robot0:F3"></geom>
+                                <geom class="robot0:DC_Hand" name="robot0:C_lfproximal" type="capsule" pos="0 0 0.0225" size="0.01 0.0225"></geom>
+                                <body name="robot0:lfmiddle" pos="0 0 0.045">
+                                    <inertial pos="0 0 0.012" quat="0.707 0 0 0.707" mass="0.012" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:LFJ1" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1113"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_lfmiddle" mesh="robot0:F2"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_lfmiddle" type="capsule" pos="0 0 0.0125" size="0.00805 0.0125"></geom>
+                                    <body name="robot0:lfdistal" pos="0 0 0.025">
+                                        <inertial pos="0 0 0.015" quat="0.707 -0.003 0.003 0.707" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                        <joint name="robot0:LFJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1112"></joint>
+                                        <geom class="robot0:D_Vizual" name="robot0:V_lfdistal" mesh="robot0:F1" pos="0 0 0.001"></geom>
+                                        <geom class="robot0:DC_Hand" name="robot0:C_lfdistal" type="capsule" pos="0 0 0.012" size="0.00705 0.012" condim="4"></geom>
+                                        <site name="robot0:S_lftip" pos="0 0 0.026" group="3"></site>
+                                        <site class="robot0:D_Touch" name="robot0:Tch_lftip"></site>
+                                    </body>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                    <body name="robot0:thbase" pos="0.034 -0.009 0.029" axisangle="0 1 0 0.785">
+                        <inertial pos="0 0 0" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:THJ4" type="hinge" pos="0 0 0" axis="0 0 -1" range="-1.047 1.047" user="1121"></joint>
+                        <geom name="robot0:V_thbase" type="box" group="1" pos="0 0 0" size="0.001 0.001 0.001"></geom>
+                        <body name="robot0:thproximal" pos="0 0 0">
+                            <inertial pos="0 0 0.017" quat="0.982 0 0.001 0.191" mass="0.016" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:THJ3" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.222" user="1120"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_thproximal" mesh="robot0:TH3_z"></geom>
+                            <geom class="robot0:DC_Hand" name="robot0:C_thproximal" type="capsule" pos="0 0 0.019" size="0.013 0.019" rgba="0.4 0.5 0.6 0.1"></geom>
+                            <body name="robot0:thhub" pos="0 0 0.038">
+                                <inertial pos="0 0 0" mass="0.002" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:THJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="-0.209 0.209" user="1119"></joint>
+                                <geom name="robot0:V_thhub" type="box" group="1" pos="0 0 0" size="0.001 0.001 0.001"></geom>
+                                <body name="robot0:thmiddle" pos="0 0 0">
+                                    <inertial pos="0 0 0.016" quat="1 -0.001 -0.007 0.003" mass="0.016" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:THJ1" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.524 0.524" user="1118"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_thmiddle" mesh="robot0:TH2_z"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_thmiddle" type="capsule" pos="0 0 0.016" size="0.011 0.016"></geom>
+                                    <body name="robot0:thdistal" pos="0 0 0.032">
+                                        <inertial pos="0 0 0.016" quat="0.999 -0.005 -0.047 0.005" mass="0.016" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                        <joint name="robot0:THJ0" type="hinge" pos="0 0 0" axis="0 1 0" range="-1.571 0" user="1117"></joint>
+                                        <geom class="robot0:D_Vizual" name="robot0:V_thdistal" mesh="robot0:TH1_z"></geom>
+                                        <geom class="robot0:DC_Hand" name="robot0:C_thdistal" type="capsule" pos="0 0 0.013" size="0.00918 0.013" condim="4"></geom>
+                                        <site name="robot0:S_thtip" pos="0 0 0.0275" group="3"></site>
+                                        <site class="robot0:D_Touch" name="robot0:Tch_thtip" size="0.005 0.011 0.016" pos="-0.005 0 0.02"></site>
+                                    </body>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                </body>
+            </body>
+        </body>
+    </body>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/robot_touch_sensors_92.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/robot_touch_sensors_92.xml
new file mode 100644
index 0000000..fa6d41c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/robot_touch_sensors_92.xml
@@ -0,0 +1,252 @@
+<!-- See LICENSE.md for legal notices. LICENSE.md must be kept together with this file. -->
+<mujoco>
+    <body name="robot0:hand mount" pos="1 1.25 0.15" euler="1.5708 0 3.14159">
+        <inertial mass="0.1" pos="0 0 0" diaginertia="0.001 0.001 0.001"></inertial>
+        <body childclass="robot0:asset_class" name="robot0:forearm" pos="0 0.01 0" euler="0 0 0">
+            <inertial pos="0.001 -0.002 0.29" quat="0.982 -0.016 0 -0.188" mass="4" diaginertia="0.01 0.01 0.0075"></inertial>
+            <geom class="robot0:D_Vizual" pos="0 0.01 0.04" name="robot0:V_forearm" mesh="robot0:forearm" euler="0 0 1.57"></geom>
+            <geom class="robot0:DC_Hand" name="robot0:C_forearm" type="mesh" mesh="robot0:forearm_cvx" pos="0 0.01 0.04" euler="0 0 1.57" rgba="0.4 0.5 0.6 0.7"></geom>
+            <body name="robot0:wrist" pos="0 0 0.256">
+                <inertial pos="0.003 0 0.016" quat="0.504 0.496 0.495 0.504" mass="0.3" diaginertia="0.001 0.001 0.001"></inertial>
+                <joint name="robot0:WRJ1" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.489 0.14" damping="0.5" armature="0.005" user="1123"></joint>
+                <geom class="robot0:D_Vizual" name="robot0:V_wrist" mesh="robot0:wrist"></geom>
+                <geom class="robot0:DC_Hand" name="robot0:C_wrist" type="capsule" pos="0 0 0" quat="0.707 0.707 0 0" size="0.015 0.01" rgba="0.4 0.5 0.6 0.1"></geom>
+                <body name="robot0:palm" pos="0 0 0.034">
+                    <inertial pos="0.006 0 0.036" quat="0.716 0.044 0.075 0.693" mass="0.3" diaginertia="0.001 0.001 0.001"></inertial>
+                    <joint name="robot0:WRJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="-0.698 0.489" damping="0.5" armature="0.005" user="1122"></joint>
+                    <geom class="robot0:D_Vizual" name="robot0:V_palm" mesh="robot0:palm"></geom>
+                    <geom class="robot0:DC_Hand" name="robot0:C_palm0" type="box" pos="0.011 0 0.038" size="0.032 0.0111 0.049" rgba="0.4 0.5 0.6 0.1"></geom>
+                    <site name="robot0:T_palm_b0" type="box" pos="0.011 -0.005 0.006"  size="0.033 0.007 0.019" rgba="0 0 0 0.33"/>
+                    <site name="robot0:T_palm_bl" type="box" pos="-0.011 -0.005 0.041" size="0.011 0.007 0.016" rgba="1 0 0 0.33"/>
+                    <site name="robot0:T_palm_bm" type="box" pos="0.011 -0.005 0.041"  size="0.011 0.007 0.016" rgba="0 0 0 0.33"/>
+                    <site name="robot0:T_palm_br" type="box" pos="0.033 -0.005 0.041"  size="0.011 0.007 0.016" rgba="1 0 0 0.33"/>
+                    <site name="robot0:T_palm_fl" type="box" pos="-0.011 -0.005 0.073" size="0.011 0.007 0.016" rgba="0 0 0 0.33"/>
+                    <site name="robot0:T_palm_fm" type="box" pos="0.011 -0.005 0.073"  size="0.011 0.007 0.016" rgba="1 0 0 0.33"/>
+                    <site name="robot0:T_palm_fr" type="box" pos="0.033 -0.005 0.073"  size="0.011 0.007 0.016" rgba="0 0 0 0.33"/>
+                    <geom class="robot0:DC_Hand" name="robot0:C_palm1" type="box" pos="-0.032 0 0.014" size="0.011 0.0111 0.025" rgba="0.4 0.5 0.6 0.1"></geom>
+                    <site name="robot0:T_palm_b1" type="box" pos="-0.0325 -0.005 0.014" size="0.012 0.007 0.027" rgba="0 0 0 0.33"/>
+                    <body name="robot0:ffknuckle" pos="0.033 0 0.095">
+                        <inertial pos="0 0 0" quat="0.52 0.854 0.006 -0.003" mass="0.008" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:FFJ3" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.349 0.349" user="1103"></joint>
+                        <geom class="robot0:D_Vizual" name="robot0:V_ffknuckle" mesh="robot0:knuckle"></geom>
+                        <body name="robot0:ffproximal" pos="0 0 0">
+                            <inertial pos="0 0 0.023" quat="0.707 -0.004 0.004 0.707" mass="0.014" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:FFJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1102"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_ffproximal" mesh="robot0:F3"></geom>
+                            <geom class="robot0:DC_Hand" name="robot0:C_ffproximal" type="capsule" pos="0 0 0.0225" size="0.01 0.0225"></geom>
+                            <site name="robot0:T_ffproximal_front_left_bottom"  type="box"    pos="-0.005 -0.005 0.00625" size="0.005 0.005 0.01625" rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_ffproximal_front_right_bottom" type="box"    pos="0.005 -0.005 0.00625"  size="0.005 0.005 0.01625" rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_ffproximal_front_left_top"     type="box"    pos="-0.005 -0.005 0.03875" size="0.005 0.005 0.01625" rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_ffproximal_front_right_top"    type="box"    pos="0.005 -0.005 0.03875"  size="0.005 0.005 0.01625" rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_ffproximal_back_left"          type="box"    pos="-0.005 0.005 0.0225"   size="0.005 0.005 0.0325"  rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_ffproximal_back_right"         type="box"    pos="0.005 0.005 0.0225"    size="0.005 0.005 0.0325"  rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_ffproximal_tip"                type="sphere" pos="0 0 0.045"             size="0.011"               rgba="1 1 0 0.33"/>
+                            <body name="robot0:ffmiddle" pos="0 0 0.045">
+                                <inertial pos="0 0 0.011" quat="0.707 0 0 0.707" mass="0.012" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:FFJ1" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1101"></joint>
+                                <geom class="robot0:D_Vizual" name="robot0:V_ffmiddle" mesh="robot0:F2"></geom>
+                                <geom class="robot0:DC_Hand" name="robot0:C_ffmiddle" type="capsule" pos="0 0 0.0125" size="0.00805 0.0125"></geom>
+                                <site name="robot0:T_ffmiddle_front_left"  type="box"     pos="-0.00451 -0.00451 0.0125" size="0.00451 0.00451 0.02055" rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_ffmiddle_front_right" type="box"     pos="0.00451 -0.00451 0.0125"  size="0.00451 0.00451 0.02055" rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_ffmiddle_back_left"   type="box"     pos="-0.00451 0.00451 0.0125"  size="0.00451 0.00451 0.02055" rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_ffmiddle_back_right"  type="box"     pos="0.00451 0.00451 0.0125"   size="0.00451 0.00451 0.02055" rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_ffmiddle_tip"         type="sphere"  pos="0 0 0.025"                size="0.009"                   rgba="1 1 0 0.33"/>
+                                <body name="robot0:ffdistal" pos="0 0 0.025">
+                                    <inertial pos="0 0 0.015" quat="0.707 -0.003 0.003 0.707" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:FFJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1100"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_ffdistal" pos="0 0 0.001" mesh="robot0:F1"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_ffdistal" type="capsule" pos="0 0 0.012" size="0.00705 0.012" condim="4"></geom>
+                                    <site name="robot0:S_fftip" pos="0 0 0.026" group="3"></site>
+                                    <site class="robot0:D_Touch" name="robot0:Tch_fftip"></site>
+                                    <site name="robot0:T_fftip_front_left"  type="box"      pos="-0.00451 -0.00451 0.012" size="0.00451 0.00451 0.01905" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_fftip_front_right" type="box"      pos="0.00451 -0.00451 0.012"  size="0.00451 0.00451 0.01905" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_fftip_back_left"   type="box"      pos="-0.00451 0.00451 0.012"  size="0.00451 0.00451 0.01905" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_fftip_back_right"  type="box"      pos="0.00451 0.00451 0.012"   size="0.00451 0.00451 0.01905" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_fftip_tip"         type="sphere"   pos="0 0 0.024"               size="0.008"                   rgba="1 1 0 0.33"/>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                    <body name="robot0:mfknuckle" pos="0.011 0 0.099">
+                        <inertial pos="0 0 0" quat="0.52 0.854 0.006 -0.003" mass="0.008" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:MFJ3" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.349 0.349" user="1107"></joint>
+                        <geom class="robot0:D_Vizual" name="robot0:V_mfknuckle" mesh="robot0:knuckle"></geom>
+                        <body name="robot0:mfproximal" pos="0 0 0">
+                            <inertial pos="0 0 0.023" quat="0.707 -0.004 0.004 0.707" mass="0.014" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:MFJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1106"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_mfproximal" mesh="robot0:F3"></geom>
+                            <geom class="robot0:DC_Hand" name="robot0:C_mfproximal" type="capsule" pos="0 0 0.0225" size="0.01 0.0225"></geom>
+                            <site name="robot0:T_mfproximal_front_left_bottom"  type="box"    pos="-0.005 -0.005 0.00625" size="0.005 0.005 0.01625" rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_mfproximal_front_right_bottom" type="box"    pos="0.005 -0.005 0.00625"  size="0.005 0.005 0.01625" rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_mfproximal_front_left_top"     type="box"    pos="-0.005 -0.005 0.03875" size="0.005 0.005 0.01625" rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_mfproximal_front_right_top"    type="box"    pos="0.005 -0.005 0.03875"  size="0.005 0.005 0.01625" rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_mfproximal_back_left"          type="box"    pos="-0.005 0.005 0.0225"   size="0.005 0.005 0.0325"  rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_mfproximal_back_right"         type="box"    pos="0.005 0.005 0.0225"    size="0.005 0.005 0.0325"  rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_mfproximal_tip"                type="sphere" pos="0 0 0.045"             size="0.011"               rgba="1 1 0 0.33"/>
+                            <body name="robot0:mfmiddle" pos="0 0 0.045">
+                                <inertial pos="0 0 0.012" quat="0.707 0 0 0.707" mass="0.012" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:MFJ1" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1105"></joint>
+                                <geom class="robot0:D_Vizual" name="robot0:V_mfmiddle" mesh="robot0:F2"></geom>
+                                <geom class="robot0:DC_Hand" name="robot0:C_mfmiddle" type="capsule" pos="0 0 0.0125" size="0.00805 0.0125"></geom>
+                                <site name="robot0:T_mfmiddle_front_left"  type="box"    pos="-0.00451 -0.00451 0.0125" size="0.00451 0.00451 0.02055" rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_mfmiddle_front_right" type="box"    pos="0.00451 -0.00451 0.0125"  size="0.00451 0.00451 0.02055" rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_mfmiddle_back_left"   type="box"    pos="-0.00451 0.00451 0.0125"  size="0.00451 0.00451 0.02055" rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_mfmiddle_back_right"  type="box"    pos="0.00451 0.00451 0.0125"   size="0.00451 0.00451 0.02055" rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_mfmiddle_tip"         type="sphere" pos="0 0 0.025"                size="0.009"                   rgba="1 1 0 0.33"/>
+                                <body name="robot0:mfdistal" pos="0 0 0.025">
+                                    <inertial pos="0 0 0.015" quat="0.707 -0.003 0.003 0.707" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:MFJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1104"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_mfdistal" mesh="robot0:F1"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_mfdistal" type="capsule" pos="0 0 0.012" size="0.00705 0.012" condim="4"></geom>
+                                    <site name="robot0:S_mftip" pos="0 0 0.026" group="3"></site>
+                                    <site class="robot0:D_Touch" name="robot0:Tch_mftip"></site>
+                                    <site name="robot0:T_mftip_front_left"  type="box"    pos="-0.00451 -0.00451 0.012" size="0.00451 0.00451 0.01905" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_mftip_front_right" type="box"    pos="0.00451 -0.00451 0.012"  size="0.00451 0.00451 0.01905" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_mftip_back_left"   type="box"    pos="-0.00451 0.00451 0.012"  size="0.00451 0.00451 0.01905" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_mftip_back_right"  type="box"    pos="0.00451 0.00451 0.012"   size="0.00451 0.00451 0.01905" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_mftip_tip"         type="sphere" pos="0 0 0.024"               size="0.008"                   rgba="1 1 0 0.33"/>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                    <body name="robot0:rfknuckle" pos="-0.011 0 0.095">
+                        <inertial pos="0 0 0" quat="0.52 0.854 0.006 -0.003" mass="0.008" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:RFJ3" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.349 0.349" user="1111"></joint>
+                        <geom class="robot0:D_Vizual" name="robot0:V_rfknuckle" mesh="robot0:knuckle"></geom>
+                        <body name="robot0:rfproximal" pos="0 0 0">
+                            <inertial pos="0 0 0.023" quat="0.707 -0.004 0.004 0.707" mass="0.014" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:RFJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1110"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_rfproximal" mesh="robot0:F3"></geom>
+                            <geom class="robot0:DC_Hand" name="robot0:C_rfproximal" type="capsule" pos="0 0 0.0225" size="0.01 0.0225"></geom>
+                            <site name="robot0:T_rfproximal_front_left_bottom"  type="box"    pos="-0.005 -0.005 0.00625" size="0.005 0.005 0.01625" rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_rfproximal_front_right_bottom" type="box"    pos="0.005 -0.005 0.00625"  size="0.005 0.005 0.01625" rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_rfproximal_front_left_top"     type="box"    pos="-0.005 -0.005 0.03875" size="0.005 0.005 0.01625" rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_rfproximal_front_right_top"    type="box"    pos="0.005 -0.005 0.03875"  size="0.005 0.005 0.01625" rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_rfproximal_back_left"          type="box"    pos="-0.005 0.005 0.0225"   size="0.005 0.005 0.0325"  rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_rfproximal_back_right"         type="box"    pos="0.005 0.005 0.0225"    size="0.005 0.005 0.0325"  rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_rfproximal_tip"                type="sphere" pos="0 0 0.045"             size="0.011"               rgba="1 1 0 0.33"/>
+                            <body name="robot0:rfmiddle" pos="0 0 0.045">
+                                <inertial pos="0 0 0.012" quat="0.707 0 0 0.707" mass="0.012" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:RFJ1" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1109"></joint>
+                                <geom class="robot0:D_Vizual" name="robot0:V_rfmiddle" mesh="robot0:F2"></geom>
+                                <geom class="robot0:DC_Hand" name="robot0:C_rfmiddle" type="capsule" pos="0 0 0.0125" size="0.00805 0.0125"></geom>
+                                <site name="robot0:T_rfmiddle_front_left"  type="box"    pos="-0.00451 -0.00451 0.0125" size="0.00451 0.00451 0.02055" rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_rfmiddle_front_right" type="box"    pos="0.00451 -0.00451 0.0125"  size="0.00451 0.00451 0.02055" rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_rfmiddle_back_left"   type="box"    pos="-0.00451 0.00451 0.0125"  size="0.00451 0.00451 0.02055" rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_rfmiddle_back_right"  type="box"    pos="0.00451 0.00451 0.0125"   size="0.00451 0.00451 0.02055" rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_rfmiddle_tip"         type="sphere" pos="0 0 0.025"                size="0.009"                   rgba="1 1 0 0.33"/>
+                                <body name="robot0:rfdistal" pos="0 0 0.025">
+                                    <inertial pos="0 0 0.015" quat="0.707 -0.003 0.003 0.707" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:RFJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1108"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_rfdistal" mesh="robot0:F1" pos="0 0 0.001"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_rfdistal" type="capsule" pos="0 0 0.012" size="0.00705 0.012" condim="4"></geom>
+                                    <site name="robot0:S_rftip" pos="0 0 0.026" group="3"></site>
+                                    <site class="robot0:D_Touch" name="robot0:Tch_rftip"></site>
+                                    <site name="robot0:T_rftip_front_left"  type="box"    pos="-0.00451 -0.00451 0.012" size="0.00451 0.00451 0.01905" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_rftip_front_right" type="box"    pos="0.00451 -0.00451 0.012"  size="0.00451 0.00451 0.01905" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_rftip_back_left"   type="box"    pos="-0.00451 0.00451 0.012"  size="0.00451 0.00451 0.01905" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_rftip_back_right"  type="box"    pos="0.00451 0.00451 0.012"   size="0.00451 0.00451 0.01905" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_rftip_tip"         type="sphere" pos="0 0 0.024"               size="0.008"                   rgba="1 1 0 0.33"/>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                    <body name="robot0:lfmetacarpal" pos="-0.017 0 0.044">
+                        <inertial pos="-0.014 0.001 0.014" quat="0.709 -0.092 -0.063 0.696" mass="0.075" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:LFJ4" type="hinge" pos="0 0 0" axis="0.571 0 0.821" range="0 0.785" user="1116"></joint>
+                        <geom class="robot0:D_Vizual" name="robot0:V_lfmetacarpal" pos="-0.016 0 -0.023" mesh="robot0:lfmetacarpal"></geom>
+                        <geom class="robot0:DC_Hand" name="robot0:C_lfmetacarpal" type="box" pos="-0.0165 0 0.01" size="0.0095 0.0111 0.025" rgba="0.4 0.5 0.6 0.2"></geom>
+                        <site name="robot0:T_lfmetacarpal_front" type="box" pos="-0.0165 -0.005 0.00975" size="0.01 0.007 0.026"  rgba="1 0 0 0.33"/>
+                        <body name="robot0:lfknuckle" pos="-0.017 0 0.044">
+                            <inertial pos="0 0 0" quat="0.52 0.854 0.006 -0.003" mass="0.008" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:LFJ3" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.349 0.349" user="1115"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_lfknuckle" mesh="robot0:knuckle"></geom>
+                            <body name="robot0:lfproximal" pos="0 0 0">
+                                <inertial pos="0 0 0.023" quat="0.707 -0.004 0.004 0.707" mass="0.014" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:LFJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1114"></joint>
+                                <geom class="robot0:D_Vizual" name="robot0:V_lfproximal" mesh="robot0:F3"></geom>
+                                <geom class="robot0:DC_Hand" name="robot0:C_lfproximal" type="capsule" pos="0 0 0.0225" size="0.01 0.0225"></geom>
+                                <site name="robot0:T_lfproximal_front_left_bottom"  type="box"    pos="-0.005 -0.005 0.00625" size="0.005 0.005 0.01625" rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_lfproximal_front_right_bottom" type="box"    pos="0.005 -0.005 0.00625"  size="0.005 0.005 0.01625" rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_lfproximal_front_left_top"     type="box"    pos="-0.005 -0.005 0.03875" size="0.005 0.005 0.01625" rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_lfproximal_front_right_top"    type="box"    pos="0.005 -0.005 0.03875"  size="0.005 0.005 0.01625" rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_lfproximal_back_left"          type="box"    pos="-0.005 0.005 0.0225"   size="0.005 0.005 0.0325"  rgba="0 0 0 0.33"/>
+                                <site name="robot0:T_lfproximal_back_right"         type="box"    pos="0.005 0.005 0.0225"    size="0.005 0.005 0.0325"  rgba="1 0 0 0.33"/>
+                                <site name="robot0:T_lfproximal_tip"                type="sphere" pos="0 0 0.045"             size="0.011"               rgba="1 1 0 0.33"/>
+                                <body name="robot0:lfmiddle" pos="0 0 0.045">
+                                    <inertial pos="0 0 0.012" quat="0.707 0 0 0.707" mass="0.012" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:LFJ1" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1113"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_lfmiddle" mesh="robot0:F2"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_lfmiddle" type="capsule" pos="0 0 0.0125" size="0.00805 0.0125"></geom>
+                                    <site name="robot0:T_lfmiddle_front_left"  type="box"    pos="-0.00451 -0.00451 0.0125" size="0.00451 0.00451 0.02055" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_lfmiddle_front_right" type="box"    pos="0.00451 -0.00451 0.0125"  size="0.00451 0.00451 0.02055" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_lfmiddle_back_left"   type="box"    pos="-0.00451 0.00451 0.0125"  size="0.00451 0.00451 0.02055" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_lfmiddle_back_right"  type="box"    pos="0.00451 0.00451 0.0125"   size="0.00451 0.00451 0.02055" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_lfmiddle_tip"         type="sphere" pos="0 0 0.025"                size="0.009"                   rgba="1 1 0 0.33"/>
+                                    <body name="robot0:lfdistal" pos="0 0 0.025">
+                                        <inertial pos="0 0 0.015" quat="0.707 -0.003 0.003 0.707" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                        <joint name="robot0:LFJ0" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.571" user="1112"></joint>
+                                        <geom class="robot0:D_Vizual" name="robot0:V_lfdistal" mesh="robot0:F1" pos="0 0 0.001"></geom>
+                                        <geom class="robot0:DC_Hand" name="robot0:C_lfdistal" type="capsule" pos="0 0 0.012" size="0.00705 0.012" condim="4"></geom>
+                                        <site name="robot0:S_lftip" pos="0 0 0.026" group="3"></site>
+                                        <site class="robot0:D_Touch" name="robot0:Tch_lftip"></site>
+                                        <site name="robot0:T_lftip_front_left"  type="box"    pos="-0.00451 -0.00451 0.012" size="0.00451 0.00451 0.01905" rgba="1 0 0 0.33"/>
+                                        <site name="robot0:T_lftip_front_right" type="box"    pos="0.00451 -0.00451 0.012"  size="0.00451 0.00451 0.01905" rgba="0 0 0 0.33"/>
+                                        <site name="robot0:T_lftip_back_left"   type="box"    pos="-0.00451 0.00451 0.012"  size="0.00451 0.00451 0.01905" rgba="0 0 0 0.33"/>
+                                        <site name="robot0:T_lftip_back_right"  type="box"    pos="0.00451 0.00451 0.012"   size="0.00451 0.00451 0.01905" rgba="1 0 0 0.33"/>
+                                        <site name="robot0:T_lftip_tip"         type="sphere" pos="0 0 0.024"               size="0.008"                   rgba="1 1 0 0.33"/>
+                                    </body>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                    <body name="robot0:thbase" pos="0.034 -0.009 0.029" axisangle="0 1 0 0.785">
+                        <inertial pos="0 0 0" mass="0.01" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                        <joint name="robot0:THJ4" type="hinge" pos="0 0 0" axis="0 0 -1" range="-1.047 1.047" user="1121"></joint>
+                        <geom name="robot0:V_thbase" type="box" group="1" pos="0 0 0" size="0.001 0.001 0.001"></geom>
+                        <body name="robot0:thproximal" pos="0 0 0">
+                            <inertial pos="0 0 0.017" quat="0.982 0 0.001 0.191" mass="0.016" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                            <joint name="robot0:THJ3" type="hinge" pos="0 0 0" axis="1 0 0" range="0 1.222" user="1120"></joint>
+                            <geom class="robot0:D_Vizual" name="robot0:V_thproximal" mesh="robot0:TH3_z"></geom>
+                            <geom class="robot0:DC_Hand" name="robot0:C_thproximal" type="capsule" pos="0 0 0.019" size="0.013 0.019" rgba="0.4 0.5 0.6 0.1"></geom>
+                            <site name="robot0:T_thproximal_front_left"  type="box"    pos="-0.007 -0.007 0.019" size="0.007 0.007 0.032" rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_thproximal_front_right" type="box"    pos="0.007 -0.007 0.019"  size="0.007 0.007 0.032" rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_thproximal_back_left"   type="box"    pos="-0.007 0.007 0.019"  size="0.007 0.007 0.032" rgba="1 0 0 0.33"/>
+                            <site name="robot0:T_thproximal_back_right"  type="box"    pos="0.007 0.007 0.019"   size="0.007 0.007 0.032" rgba="0 0 0 0.33"/>
+                            <site name="robot0:T_thproximal_tip"         type="sphere" pos="0 0 0.038"           size="0.014"             rgba="1 1 0 0.33"/>
+                            <body name="robot0:thhub" pos="0 0 0.038">
+                                <inertial pos="0 0 0" mass="0.002" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                <joint name="robot0:THJ2" type="hinge" pos="0 0 0" axis="1 0 0" range="-0.209 0.209" user="1119"></joint>
+                                <geom name="robot0:V_thhub" type="box" group="1" pos="0 0 0" size="0.001 0.001 0.001"></geom>
+                                <body name="robot0:thmiddle" pos="0 0 0">
+                                    <inertial pos="0 0 0.016" quat="1 -0.001 -0.007 0.003" mass="0.016" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                    <joint name="robot0:THJ1" type="hinge" pos="0 0 0" axis="0 1 0" range="-0.524 0.524" user="1118"></joint>
+                                    <geom class="robot0:D_Vizual" name="robot0:V_thmiddle" mesh="robot0:TH2_z"></geom>
+                                    <geom class="robot0:DC_Hand" name="robot0:C_thmiddle" type="capsule" pos="0 0 0.016" size="0.011 0.016"></geom>
+                                    <site name="robot0:T_thmiddle_front_left"  type="box"    pos="-0.006 -0.006 0.016" size="0.006 0.006 0.027" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_thmiddle_front_right" type="box"    pos="0.006 -0.006 0.016"  size="0.006 0.006 0.027" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_thmiddle_back_left"   type="box"    pos="-0.006 0.006 0.016"  size="0.006 0.006 0.027" rgba="0 0 0 0.33"/>
+                                    <site name="robot0:T_thmiddle_back_right"  type="box"    pos="0.006 0.006 0.016"   size="0.006 0.006 0.027" rgba="1 0 0 0.33"/>
+                                    <site name="robot0:T_thmiddle_tip"         type="sphere" pos="0 0 0.032"           size="0.012"             rgba="1 1 0 0.33"/>
+                                    <body name="robot0:thdistal" pos="0 0 0.032">
+                                        <inertial pos="0 0 0.016" quat="0.999 -0.005 -0.047 0.005" mass="0.016" diaginertia="1e-05 1e-05 1e-05"></inertial>
+                                        <joint name="robot0:THJ0" type="hinge" pos="0 0 0" axis="0 1 0" range="-1.571 0" user="1117"></joint>
+                                        <geom class="robot0:D_Vizual" name="robot0:V_thdistal" mesh="robot0:TH1_z"></geom>
+                                        <geom class="robot0:DC_Hand" name="robot0:C_thdistal" type="capsule" pos="0 0 0.013" size="0.00918 0.013" condim="4"></geom>
+                                        <site name="robot0:S_thtip" pos="0 0 0.0275" group="3"></site>
+                                        <site class="robot0:D_Touch" name="robot0:Tch_thtip" size="0.005 0.011 0.016" pos="-0.005 0 0.02"></site>
+                                        <site name="robot0:T_thtip_front_left"  type="box"    pos="-0.0056 -0.0056 0.013" size="0.0056 0.0056 0.02218" rgba="0 0 0 0.33"/>
+                                        <site name="robot0:T_thtip_front_right" type="box"    pos="0.0056 -0.0056 0.013"  size="0.0056 0.0056 0.02218" rgba="1 0 0 0.33"/>
+                                        <site name="robot0:T_thtip_back_left"   type="box"    pos="-0.0056 0.0056 0.013"  size="0.0056 0.0056 0.02218" rgba="1 0 0 0.33"/>
+                                        <site name="robot0:T_thtip_back_right"  type="box"    pos="0.0056 0.0056 0.013"   size="0.0056 0.0056 0.02218" rgba="0 0 0 0.33"/>
+                                        <site name="robot0:T_thtip_tip"         type="sphere" pos="0 0 0.026"             size="0.01"                  rgba="1 1 0 0.33"/>
+                                    </body>
+                                </body>
+                            </body>
+                        </body>
+                    </body>
+                </body>
+            </body>
+        </body>
+    </body>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared.xml
new file mode 100644
index 0000000..f27f265
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared.xml
@@ -0,0 +1,254 @@
+<!-- See LICENSE.md for legal notices. LICENSE.md must be kept together with this file. -->
+<mujoco>
+    <size njmax="500" nconmax="100" nuser_jnt="1" nuser_site="1" nuser_tendon="1" nuser_sensor="1" nuser_actuator="16" nstack="600000"></size>
+
+    <visual>
+        <map fogstart="3" fogend="5" force="0.1"></map>
+        <quality shadowsize="4096"></quality>
+    </visual>
+
+    <default>
+        <default class="robot0:asset_class">
+            <geom friction="1 0.005 0.001" condim="3" margin="0.0005" contype="1" conaffinity="1"></geom>
+            <joint limited="true" damping="0.1" armature="0.001" margin="0.01" frictionloss="0.001"></joint>
+            <site size="0.005" rgba="0.4 0.9 0.4 1"></site>
+            <general ctrllimited="true" forcelimited="true"></general>
+        </default>
+        <default class="robot0:D_Touch">
+            <site type="box" size="0.009 0.004 0.013" pos="0 -0.004 0.018" rgba="0.8 0.8 0.8 0.15" group="4"></site>
+        </default>
+        <default class="robot0:DC_Hand">
+            <geom material="robot0:MatColl" contype="1" conaffinity="0" group="4"></geom>
+        </default>
+        <default class="robot0:D_Vizual">
+            <geom material="robot0:MatViz" contype="0" conaffinity="0" group="1" type="mesh"></geom>
+        </default>
+        <default class="robot0:free">
+            <joint type="free" damping="0" armature="0" limited="false"></joint>
+        </default>
+    </default>
+
+    <contact>
+        <pair geom1="robot0:C_ffdistal" geom2="robot0:C_thdistal" condim="1"></pair>
+        <pair geom1="robot0:C_ffmiddle" geom2="robot0:C_thdistal" condim="1"></pair>
+        <pair geom1="robot0:C_ffproximal" geom2="robot0:C_thdistal" condim="1"></pair>
+        <pair geom1="robot0:C_mfproximal" geom2="robot0:C_thdistal" condim="1"></pair>
+        <pair geom1="robot0:C_mfdistal" geom2="robot0:C_thdistal" condim="1"></pair>
+        <pair geom1="robot0:C_rfdistal" geom2="robot0:C_thdistal" condim="1"></pair>
+        <pair geom1="robot0:C_lfdistal" geom2="robot0:C_thdistal" condim="1"></pair>
+        <pair geom1="robot0:C_palm0" geom2="robot0:C_thdistal" condim="1"></pair>
+        <pair geom1="robot0:C_mfdistal" geom2="robot0:C_ffdistal" condim="1"></pair>
+        <pair geom1="robot0:C_rfdistal" geom2="robot0:C_mfdistal" condim="1"></pair>
+        <pair geom1="robot0:C_lfdistal" geom2="robot0:C_rfdistal" condim="1"></pair>
+        <pair geom1="robot0:C_mfproximal" geom2="robot0:C_ffproximal" condim="1"></pair>
+        <pair geom1="robot0:C_rfproximal" geom2="robot0:C_mfproximal" condim="1"></pair>
+        <pair geom1="robot0:C_lfproximal" geom2="robot0:C_rfproximal" condim="1"></pair>
+        <pair geom1="robot0:C_lfdistal" geom2="robot0:C_rfdistal" condim="1"></pair>
+        <pair geom1="robot0:C_lfdistal" geom2="robot0:C_mfdistal" condim="1"></pair>
+        <pair geom1="robot0:C_lfdistal" geom2="robot0:C_rfmiddle" condim="1"></pair>
+        <pair geom1="robot0:C_lfmiddle" geom2="robot0:C_rfdistal" condim="1"></pair>
+        <pair geom1="robot0:C_lfmiddle" geom2="robot0:C_rfmiddle" condim="1"></pair>
+    </contact>
+
+    <tendon>
+        <fixed name="robot0:T_WRJ1r" limited="true" range="-0.032 0.032" user="1236">
+            <joint joint="robot0:WRJ1" coef="0.0325"></joint>
+        </fixed>
+        <fixed name="robot0:T_WRJ1l" limited="true" range="-0.032 0.032" user="1237">
+            <joint joint="robot0:WRJ1" coef="-0.0325"></joint>
+        </fixed>
+        <fixed name="robot0:T_WRJ0u" limited="true" range="-0.032 0.032" user="1236">
+            <joint joint="robot0:WRJ0" coef="0.0175"></joint>
+        </fixed>
+        <fixed name="robot0:T_WRJ0d" limited="true" range="-0.032 0.032" user="1237">
+            <joint joint="robot0:WRJ0" coef="-0.0175"></joint>
+        </fixed>
+        <fixed name="robot0:T_FFJ3r" limited="true" range="-0.018 0.018" user="1204">
+            <joint joint="robot0:FFJ3" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_FFJ3l" limited="true" range="-0.018 0.018" user="1205">
+            <joint joint="robot0:FFJ3" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_FFJ2u" limited="true" range="-0.007 0.03" user="1202">
+            <joint joint="robot0:FFJ2" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_FFJ2d" limited="true" range="-0.03 0.007" user="1203">
+            <joint joint="robot0:FFJ2" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_FFJ1c" limited="true" range="-0.001 0.001">
+            <joint joint="robot0:FFJ0" coef="0.00705"></joint>
+            <joint joint="robot0:FFJ1" coef="-0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_FFJ1u" limited="true" range="-0.007 0.03" user="1200">
+            <joint joint="robot0:FFJ0" coef="0.00705"></joint>
+            <joint joint="robot0:FFJ1" coef="0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_FFJ1d" limited="true" range="-0.03 0.007" user="1201">
+            <joint joint="robot0:FFJ0" coef="-0.00705"></joint>
+            <joint joint="robot0:FFJ1" coef="-0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_MFJ3r" limited="true" range="-0.018 0.018" user="1210">
+            <joint joint="robot0:MFJ3" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_MFJ3l" limited="true" range="-0.018 0.018" user="1211">
+            <joint joint="robot0:MFJ3" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_MFJ2u" limited="true" range="-0.007 0.03" user="1208">
+            <joint joint="robot0:MFJ2" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_MFJ2d" limited="true" range="-0.03 0.007" user="1209">
+            <joint joint="robot0:MFJ2" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_MFJ1c" limited="true" range="-0.001 0.001">
+            <joint joint="robot0:MFJ0" coef="0.00705"></joint>
+            <joint joint="robot0:MFJ1" coef="-0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_MFJ1u" limited="true" range="-0.007 0.03" user="1206">
+            <joint joint="robot0:MFJ0" coef="0.00705"></joint>
+            <joint joint="robot0:MFJ1" coef="0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_MFJ1d" limited="true" range="-0.03 0.007" user="1207">
+            <joint joint="robot0:MFJ0" coef="-0.00705"></joint>
+            <joint joint="robot0:MFJ1" coef="-0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_RFJ3r" limited="true" range="-0.018 0.018" user="1216">
+            <joint joint="robot0:RFJ3" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_RFJ3l" limited="true" range="-0.018 0.018" user="1217">
+            <joint joint="robot0:RFJ3" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_RFJ2u" limited="true" range="-0.007 0.03" user="1214">
+            <joint joint="robot0:RFJ2" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_RFJ2d" limited="true" range="-0.03 0.007" user="1215">
+            <joint joint="robot0:RFJ2" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_RFJ1c" limited="true" range="-0.001 0.001">
+            <joint joint="robot0:RFJ0" coef="0.00705"></joint>
+            <joint joint="robot0:RFJ1" coef="-0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_RFJ1u" limited="true" range="-0.007 0.03" user="1212">
+            <joint joint="robot0:RFJ0" coef="0.00705"></joint>
+            <joint joint="robot0:RFJ1" coef="0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_RFJ1d" limited="true" range="-0.03 0.007" user="1213">
+            <joint joint="robot0:RFJ0" coef="-0.00705"></joint>
+            <joint joint="robot0:RFJ1" coef="-0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ4u" limited="true" range="-0.007 0.03" user="1224">
+            <joint joint="robot0:LFJ4" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ4d" limited="true" range="-0.03 0.007" user="1225">
+            <joint joint="robot0:LFJ4" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ3r" limited="true" range="-0.018 0.018" user="1222">
+            <joint joint="robot0:LFJ3" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ3l" limited="true" range="-0.018 0.018" user="1223">
+            <joint joint="robot0:LFJ3" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ2u" limited="true" range="-0.007 0.03" user="1220">
+            <joint joint="robot0:LFJ2" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ2d" limited="true" range="-0.03 0.007" user="1221">
+            <joint joint="robot0:LFJ2" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ1c" limited="true" range="-0.001 0.001">
+            <joint joint="robot0:LFJ0" coef="0.00705"></joint>
+            <joint joint="robot0:LFJ1" coef="-0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ1u" limited="true" range="-0.007 0.03" user="1218">
+            <joint joint="robot0:LFJ0" coef="0.00705"></joint>
+            <joint joint="robot0:LFJ1" coef="0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_LFJ1d" limited="true" range="-0.03 0.007" user="1219">
+            <joint joint="robot0:LFJ0" coef="-0.00705"></joint>
+            <joint joint="robot0:LFJ1" coef="-0.00805"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ4a" limited="true" range="-0.018 0.018" user="1234">
+            <joint joint="robot0:THJ4" coef="0.01636"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ4c" limited="true" range="-0.018 0.018" user="1235">
+            <joint joint="robot0:THJ4" coef="-0.01636"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ3u" limited="true" range="-0.007 0.03" user="1232">
+            <joint joint="robot0:THJ3" coef="0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ3d" limited="true" range="-0.03 0.007" user="1233">
+            <joint joint="robot0:THJ3" coef="-0.01"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ2u" limited="true" range="-0.018 0.018" user="1230">
+            <joint joint="robot0:THJ2" coef="0.011"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ2d" limited="true" range="-0.018 0.018" user="1231">
+            <joint joint="robot0:THJ2" coef="-0.011"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ1r" limited="true" range="-0.018 0.018" user="1228">
+            <joint joint="robot0:THJ1" coef="0.011"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ1l" limited="true" range="-0.018 0.018" user="1229">
+            <joint joint="robot0:THJ1" coef="-0.011"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ0r" limited="true" range="-0.03 0.007" user="1226">
+            <joint joint="robot0:THJ0" coef="0.009"></joint>
+        </fixed>
+        <fixed name="robot0:T_THJ0l" limited="true" range="-0.007 0.03" user="1227">
+            <joint joint="robot0:THJ0" coef="-0.009"></joint>
+        </fixed>
+    </tendon>
+
+    <sensor>
+        <jointpos name="robot0:Sjp_WRJ1" joint="robot0:WRJ1"></jointpos>
+        <jointpos name="robot0:Sjp_WRJ0" joint="robot0:WRJ0"></jointpos>
+        <jointpos name="robot0:Sjp_FFJ3" joint="robot0:FFJ3"></jointpos>
+        <jointpos name="robot0:Sjp_FFJ2" joint="robot0:FFJ2"></jointpos>
+        <jointpos name="robot0:Sjp_FFJ1" joint="robot0:FFJ1"></jointpos>
+        <jointpos name="robot0:Sjp_FFJ0" joint="robot0:FFJ0"></jointpos>
+        <jointpos name="robot0:Sjp_MFJ3" joint="robot0:MFJ3"></jointpos>
+        <jointpos name="robot0:Sjp_MFJ2" joint="robot0:MFJ2"></jointpos>
+        <jointpos name="robot0:Sjp_MFJ1" joint="robot0:MFJ1"></jointpos>
+        <jointpos name="robot0:Sjp_MFJ0" joint="robot0:MFJ0"></jointpos>
+        <jointpos name="robot0:Sjp_RFJ3" joint="robot0:RFJ3"></jointpos>
+        <jointpos name="robot0:Sjp_RFJ2" joint="robot0:RFJ2"></jointpos>
+        <jointpos name="robot0:Sjp_RFJ1" joint="robot0:RFJ1"></jointpos>
+        <jointpos name="robot0:Sjp_RFJ0" joint="robot0:RFJ0"></jointpos>
+        <jointpos name="robot0:Sjp_LFJ4" joint="robot0:LFJ4"></jointpos>
+        <jointpos name="robot0:Sjp_LFJ3" joint="robot0:LFJ3"></jointpos>
+        <jointpos name="robot0:Sjp_LFJ2" joint="robot0:LFJ2"></jointpos>
+        <jointpos name="robot0:Sjp_LFJ1" joint="robot0:LFJ1"></jointpos>
+        <jointpos name="robot0:Sjp_LFJ0" joint="robot0:LFJ0"></jointpos>
+        <jointpos name="robot0:Sjp_THJ4" joint="robot0:THJ4"></jointpos>
+        <jointpos name="robot0:Sjp_THJ3" joint="robot0:THJ3"></jointpos>
+        <jointpos name="robot0:Sjp_THJ2" joint="robot0:THJ2"></jointpos>
+        <jointpos name="robot0:Sjp_THJ1" joint="robot0:THJ1"></jointpos>
+        <jointpos name="robot0:Sjp_THJ0" joint="robot0:THJ0"></jointpos>
+        <touch name="robot0:ST_Tch_fftip" site="robot0:Tch_fftip"></touch>
+        <touch name="robot0:ST_Tch_mftip" site="robot0:Tch_mftip"></touch>
+        <touch name="robot0:ST_Tch_rftip" site="robot0:Tch_rftip"></touch>
+        <touch name="robot0:ST_Tch_lftip" site="robot0:Tch_lftip"></touch>
+        <touch name="robot0:ST_Tch_thtip" site="robot0:Tch_thtip"></touch>
+    </sensor>
+
+    <actuator>
+        <position name="robot0:A_WRJ1" class="robot0:asset_class" user="2038" joint="robot0:WRJ1" ctrlrange="-0.489 0.14" kp="5" forcerange="-4.785 4.785"></position>
+        <position name="robot0:A_WRJ0" class="robot0:asset_class" user="2036" joint="robot0:WRJ0" ctrlrange="-0.698 0.489" kp="5" forcerange="-2.175 2.175"></position>
+        <position name="robot0:A_FFJ3" class="robot0:asset_class" user="2004" joint="robot0:FFJ3" ctrlrange="-0.349 0.349" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_FFJ2" class="robot0:asset_class" user="2002" joint="robot0:FFJ2" ctrlrange="0 1.571" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_FFJ1" class="robot0:asset_class" user="2000" joint="robot0:FFJ1" ctrlrange="0 1.571" kp="1" forcerange="-0.7245 0.7245"></position>
+        <position name="robot0:A_MFJ3" class="robot0:asset_class" user="2010" joint="robot0:MFJ3" ctrlrange="-0.349 0.349" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_MFJ2" class="robot0:asset_class" user="2008" joint="robot0:MFJ2" ctrlrange="0 1.571" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_MFJ1" class="robot0:asset_class" user="2006" joint="robot0:MFJ1" ctrlrange="0 1.571" kp="1" forcerange="-0.7245 0.7245"></position>
+        <position name="robot0:A_RFJ3" class="robot0:asset_class" user="2016" joint="robot0:RFJ3" ctrlrange="-0.349 0.349" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_RFJ2" class="robot0:asset_class" user="2014" joint="robot0:RFJ2" ctrlrange="0 1.571" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_RFJ1" class="robot0:asset_class" user="2012" joint="robot0:RFJ1" ctrlrange="0 1.571" kp="1" forcerange="-0.7245 0.7245"></position>
+        <position name="robot0:A_LFJ4" class="robot0:asset_class" user="2024" joint="robot0:LFJ4" ctrlrange="0 0.785" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_LFJ3" class="robot0:asset_class" user="2022" joint="robot0:LFJ3" ctrlrange="-0.349 0.349" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_LFJ2" class="robot0:asset_class" user="2020" joint="robot0:LFJ2" ctrlrange="0 1.571" kp="1" forcerange="-0.9 0.9"></position>
+        <position name="robot0:A_LFJ1" class="robot0:asset_class" user="2018" joint="robot0:LFJ1" ctrlrange="0 1.571" kp="1" forcerange="-0.7245 0.7245"></position>
+        <position name="robot0:A_THJ4" class="robot0:asset_class" user="2034" joint="robot0:THJ4" ctrlrange="-1.047 1.047" kp="1" forcerange="-2.3722 2.3722"></position>
+        <position name="robot0:A_THJ3" class="robot0:asset_class" user="2032" joint="robot0:THJ3" ctrlrange="0 1.222" kp="1" forcerange="-1.45 1.45"></position>
+        <position name="robot0:A_THJ2" class="robot0:asset_class" user="2030" joint="robot0:THJ2" ctrlrange="-0.209 0.209" kp="1" forcerange="-0.99 0.99"></position>
+        <position name="robot0:A_THJ1" class="robot0:asset_class" user="2028" joint="robot0:THJ1" ctrlrange="-0.524 0.524" kp="1" forcerange="-0.99 0.99"></position>
+        <position name="robot0:A_THJ0" class="robot0:asset_class" user="2026" joint="robot0:THJ0" ctrlrange="-1.571 0" kp="1" forcerange="-0.81 0.81"></position>
+    </actuator>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared_asset.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared_asset.xml
new file mode 100644
index 0000000..ec9a0b0
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared_asset.xml
@@ -0,0 +1,26 @@
+<!-- See LICENSE.md for legal notices. LICENSE.md must be kept together with this file. -->
+<mujoco>
+    <texture type="skybox" builtin="gradient" rgb1="0.44 0.85 0.56" rgb2="0.46 0.87 0.58" width="32" height="32"></texture>
+
+    <texture name="robot0:texplane" type="2d" builtin="checker" rgb1="0.2 0.3 0.4" rgb2="0.1 0.15 0.2" width="512" height="512"></texture>
+    <texture name="robot0:texgeom" type="cube" builtin="flat" mark="cross" width="127" height="127" rgb1="0.3 0.6 0.5" rgb2="0.3 0.6 0.5" markrgb="0 0 0" random="0.01"></texture>
+
+    <material name="robot0:MatGnd" reflectance="0.5" texture="robot0:texplane" texrepeat="1 1" texuniform="true"></material>
+    <material name="robot0:MatColl" specular="1" shininess="0.3" reflectance="0.5" rgba="0.4 0.5 0.6 1"></material>
+    <material name="robot0:MatViz" specular="0.75" shininess="0.1" reflectance="0.5" rgba="0.93 0.93 0.93 1"></material>
+    <material name="robot0:object" texture="robot0:texgeom" texuniform="false"></material>
+    <material name="floor_mat" specular="0" shininess="0.5" reflectance="0" rgba="0.2 0.2 0.2 0"></material>
+
+    <mesh name="robot0:forearm" file="forearm_electric.stl"></mesh>
+    <mesh name="robot0:forearm_cvx" file="forearm_electric_cvx.stl"></mesh>
+    <mesh name="robot0:wrist" scale="0.001 0.001 0.001" file="wrist.stl"></mesh>
+    <mesh name="robot0:palm" scale="0.001 0.001 0.001" file="palm.stl"></mesh>
+    <mesh name="robot0:knuckle" scale="0.001 0.001 0.001" file="knuckle.stl"></mesh>
+    <mesh name="robot0:F3" scale="0.001 0.001 0.001" file="F3.stl"></mesh>
+    <mesh name="robot0:F2" scale="0.001 0.001 0.001" file="F2.stl"></mesh>
+    <mesh name="robot0:F1" scale="0.001 0.001 0.001" file="F1.stl"></mesh>
+    <mesh name="robot0:lfmetacarpal" scale="0.001 0.001 0.001" file="lfmetacarpal.stl"></mesh>
+    <mesh name="robot0:TH3_z" scale="0.001 0.001 0.001" file="TH3_z.stl"></mesh>
+    <mesh name="robot0:TH2_z" scale="0.001 0.001 0.001" file="TH2_z.stl"></mesh>
+    <mesh name="robot0:TH1_z" scale="0.001 0.001 0.001" file="TH1_z.stl"></mesh>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared_touch_sensors_92.xml b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared_touch_sensors_92.xml
new file mode 100644
index 0000000..472c84c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/hand/shared_touch_sensors_92.xml
@@ -0,0 +1,120 @@
+<mujoco>
+    <sensor>
+
+        <!--PALM-->
+        <touch name="robot0:TS_palm_b0" site="robot0:T_palm_b0"></touch>
+        <touch name="robot0:TS_palm_bl" site="robot0:T_palm_bl"></touch>
+        <touch name="robot0:TS_palm_bm" site="robot0:T_palm_bm"></touch>
+        <touch name="robot0:TS_palm_br" site="robot0:T_palm_br"></touch>
+        <touch name="robot0:TS_palm_fl" site="robot0:T_palm_fl"></touch>
+        <touch name="robot0:TS_palm_fm" site="robot0:T_palm_fm"></touch>
+        <touch name="robot0:TS_palm_fr" site="robot0:T_palm_fr"></touch>
+        <touch name="robot0:TS_palm_b1" site="robot0:T_palm_b1"></touch>
+
+         <!--FOREFINGER-->
+        <touch name="robot0:TS_ffproximal_front_left_bottom"  site="robot0:T_ffproximal_front_left_bottom"></touch>
+        <touch name="robot0:TS_ffproximal_front_right_bottom" site="robot0:T_ffproximal_front_right_bottom"></touch>
+        <touch name="robot0:TS_ffproximal_front_left_top"     site="robot0:T_ffproximal_front_left_top"></touch>
+        <touch name="robot0:TS_ffproximal_front_right_top"    site="robot0:T_ffproximal_front_right_top"></touch>
+        <touch name="robot0:TS_ffproximal_back_left"          site="robot0:T_ffproximal_back_left"></touch>
+        <touch name="robot0:TS_ffproximal_back_right"         site="robot0:T_ffproximal_back_right"></touch>
+        <touch name="robot0:TS_ffproximal_tip"                site="robot0:T_ffproximal_tip"></touch>
+
+        <touch name="robot0:TS_ffmiddle_front_left"  site="robot0:T_ffmiddle_front_left"></touch>
+        <touch name="robot0:TS_ffmiddle_front_right" site="robot0:T_ffmiddle_front_right"></touch>
+        <touch name="robot0:TS_ffmiddle_back_left"   site="robot0:T_ffmiddle_back_left"></touch>
+        <touch name="robot0:TS_ffmiddle_back_right"  site="robot0:T_ffmiddle_back_right"></touch>
+        <touch name="robot0:TS_ffmiddle_tip"         site="robot0:T_ffmiddle_tip"></touch>
+
+        <touch name="robot0:TS_fftip_front_left"  site="robot0:T_fftip_front_left"></touch>
+        <touch name="robot0:TS_fftip_front_right" site="robot0:T_fftip_front_right"></touch>
+        <touch name="robot0:TS_fftip_back_left"   site="robot0:T_fftip_back_left"></touch>
+        <touch name="robot0:TS_fftip_back_right"  site="robot0:T_fftip_back_right"></touch>
+        <touch name="robot0:TS_fftip_tip"         site="robot0:T_fftip_tip"></touch>
+
+        <!-- MIDDLE FINGER -->
+        <touch name="robot0:TS_mfproximal_front_left_bottom"  site="robot0:T_mfproximal_front_left_bottom"></touch>
+        <touch name="robot0:TS_mfproximal_front_right_bottom" site="robot0:T_mfproximal_front_right_bottom"></touch>
+        <touch name="robot0:TS_mfproximal_front_left_top"     site="robot0:T_mfproximal_front_left_top"></touch>
+        <touch name="robot0:TS_mfproximal_front_right_top"    site="robot0:T_mfproximal_front_right_top"></touch>
+        <touch name="robot0:TS_mfproximal_back_left"          site="robot0:T_mfproximal_back_left"></touch>
+        <touch name="robot0:TS_mfproximal_back_right"         site="robot0:T_mfproximal_back_right"></touch>
+        <touch name="robot0:TS_mfproximal_tip"                site="robot0:T_mfproximal_tip"></touch>
+
+        <touch name="robot0:TS_mfmiddle_front_left"  site="robot0:T_mfmiddle_front_left"></touch>
+        <touch name="robot0:TS_mfmiddle_front_right" site="robot0:T_mfmiddle_front_right"></touch>
+        <touch name="robot0:TS_mfmiddle_back_left"   site="robot0:T_mfmiddle_back_left"></touch>
+        <touch name="robot0:TS_mfmiddle_back_right"  site="robot0:T_mfmiddle_back_right"></touch>
+        <touch name="robot0:TS_mfmiddle_tip"         site="robot0:T_mfmiddle_tip"></touch>
+
+        <touch name="robot0:TS_mftip_front_left"  site="robot0:T_mftip_front_left"></touch>
+        <touch name="robot0:TS_mftip_front_right" site="robot0:T_mftip_front_right"></touch>
+        <touch name="robot0:TS_mftip_back_left"   site="robot0:T_mftip_back_left"></touch>
+        <touch name="robot0:TS_mftip_back_right"  site="robot0:T_mftip_back_right"></touch>
+        <touch name="robot0:TS_mftip_tip"         site="robot0:T_mftip_tip"></touch>
+
+        <!-- RING FINGER -->
+        <touch name="robot0:TS_rfproximal_front_left_bottom"  site="robot0:T_rfproximal_front_left_bottom"></touch>
+        <touch name="robot0:TS_rfproximal_front_right_bottom" site="robot0:T_rfproximal_front_right_bottom"></touch>
+        <touch name="robot0:TS_rfproximal_front_left_top"     site="robot0:T_rfproximal_front_left_top"></touch>
+        <touch name="robot0:TS_rfproximal_front_right_top"    site="robot0:T_rfproximal_front_right_top"></touch>
+        <touch name="robot0:TS_rfproximal_back_left"          site="robot0:T_rfproximal_back_left"></touch>
+        <touch name="robot0:TS_rfproximal_back_right"         site="robot0:T_rfproximal_back_right"></touch>
+        <touch name="robot0:TS_rfproximal_tip"                site="robot0:T_rfproximal_tip"></touch>
+
+        <touch name="robot0:TS_rfmiddle_front_left"  site="robot0:T_rfmiddle_front_left"></touch>
+        <touch name="robot0:TS_rfmiddle_front_right" site="robot0:T_rfmiddle_front_right"></touch>
+        <touch name="robot0:TS_rfmiddle_back_left"   site="robot0:T_rfmiddle_back_left"></touch>
+        <touch name="robot0:TS_rfmiddle_back_right"  site="robot0:T_rfmiddle_back_right"></touch>
+        <touch name="robot0:TS_rfmiddle_tip"         site="robot0:T_rfmiddle_tip"></touch>
+
+        <touch name="robot0:TS_rftip_front_left"  site="robot0:T_rftip_front_left"></touch>
+        <touch name="robot0:TS_rftip_front_right" site="robot0:T_rftip_front_right"></touch>
+        <touch name="robot0:TS_rftip_back_left"   site="robot0:T_rftip_back_left"></touch>
+        <touch name="robot0:TS_rftip_back_right"  site="robot0:T_rftip_back_right"></touch>
+        <touch name="robot0:TS_rftip_tip"         site="robot0:T_rftip_tip"></touch>
+
+        <!-- LITTLE FINGER -->
+        <touch name="robot0:TS_lfmetacarpal_front" site="robot0:T_lfmetacarpal_front"></touch>
+
+        <touch name="robot0:TS_lfproximal_front_left_bottom"  site="robot0:T_lfproximal_front_left_bottom"></touch>
+        <touch name="robot0:TS_lfproximal_front_right_bottom" site="robot0:T_lfproximal_front_right_bottom"></touch>
+        <touch name="robot0:TS_lfproximal_front_left_top"     site="robot0:T_lfproximal_front_left_top"></touch>
+        <touch name="robot0:TS_lfproximal_front_right_top"    site="robot0:T_lfproximal_front_right_top"></touch>
+        <touch name="robot0:TS_lfproximal_back_left"          site="robot0:T_lfproximal_back_left"></touch>
+        <touch name="robot0:TS_lfproximal_back_right"         site="robot0:T_lfproximal_back_right"></touch>
+        <touch name="robot0:TS_lfproximal_tip"                site="robot0:T_lfproximal_tip"></touch>
+
+        <touch name="robot0:TS_lfmiddle_front_left"  site="robot0:T_lfmiddle_front_left"></touch>
+        <touch name="robot0:TS_lfmiddle_front_right" site="robot0:T_lfmiddle_front_right"></touch>
+        <touch name="robot0:TS_lfmiddle_back_left"   site="robot0:T_lfmiddle_back_left"></touch>
+        <touch name="robot0:TS_lfmiddle_back_right"  site="robot0:T_lfmiddle_back_right"></touch>
+        <touch name="robot0:TS_lfmiddle_tip"         site="robot0:T_lfmiddle_tip"></touch>
+
+        <touch name="robot0:TS_lftip_front_left"  site="robot0:T_lftip_front_left"></touch>
+        <touch name="robot0:TS_lftip_front_right" site="robot0:T_lftip_front_right"></touch>
+        <touch name="robot0:TS_lftip_back_left"   site="robot0:T_lftip_back_left"></touch>
+        <touch name="robot0:TS_lftip_back_right"  site="robot0:T_lftip_back_right"></touch>
+        <touch name="robot0:TS_lftip_tip"         site="robot0:T_lftip_tip"></touch>
+
+        <!--THUMB-->
+        <touch name="robot0:TS_thproximal_front_left"  site="robot0:T_thproximal_front_left"></touch>
+        <touch name="robot0:TS_thproximal_front_right" site="robot0:T_thproximal_front_right"></touch>
+        <touch name="robot0:TS_thproximal_back_left"   site="robot0:T_thproximal_back_left"></touch>
+        <touch name="robot0:TS_thproximal_back_right"  site="robot0:T_thproximal_back_right"></touch>
+        <touch name="robot0:TS_thproximal_tip"         site="robot0:T_thproximal_tip"></touch>
+
+        <touch name="robot0:TS_thmiddle_front_left"  site="robot0:T_thmiddle_front_left"></touch>
+        <touch name="robot0:TS_thmiddle_front_right" site="robot0:T_thmiddle_front_right"></touch>
+        <touch name="robot0:TS_thmiddle_back_left"   site="robot0:T_thmiddle_back_left"></touch>
+        <touch name="robot0:TS_thmiddle_back_right"  site="robot0:T_thmiddle_back_right"></touch>
+        <touch name="robot0:TS_thmiddle_tip"         site="robot0:T_thmiddle_tip"></touch>
+
+        <touch name="robot0:TS_thtip_front_left"  site="robot0:T_thtip_front_left"></touch>
+        <touch name="robot0:TS_thtip_front_right" site="robot0:T_thtip_front_right"></touch>
+        <touch name="robot0:TS_thtip_back_left"   site="robot0:T_thtip_back_left"></touch>
+        <touch name="robot0:TS_thtip_back_right"  site="robot0:T_thtip_back_right"></touch>
+        <touch name="robot0:TS_thtip_tip"         site="robot0:T_thtip_tip"></touch>
+
+    </sensor>
+</mujoco>
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/base_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/base_link_collision.stl
new file mode 100644
index 0000000..1ef459f
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/base_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/bellows_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/bellows_link_collision.stl
new file mode 100644
index 0000000..a7e5ab7
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/bellows_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/elbow_flex_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/elbow_flex_link_collision.stl
new file mode 100644
index 0000000..b0eea07
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/elbow_flex_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/estop_link.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/estop_link.stl
new file mode 100644
index 0000000..f6d1c72
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/estop_link.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/forearm_roll_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/forearm_roll_link_collision.stl
new file mode 100644
index 0000000..fe468c5
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/forearm_roll_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/gripper_link.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/gripper_link.stl
new file mode 100644
index 0000000..8a14874
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/gripper_link.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/head_pan_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/head_pan_link_collision.stl
new file mode 100644
index 0000000..c77b5b1
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/head_pan_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/head_tilt_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/head_tilt_link_collision.stl
new file mode 100644
index 0000000..53c2ddc
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/head_tilt_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/l_wheel_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/l_wheel_link_collision.stl
new file mode 100644
index 0000000..5c17524
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/l_wheel_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/laser_link.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/laser_link.stl
new file mode 100644
index 0000000..fa4882f
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/laser_link.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/r_wheel_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/r_wheel_link_collision.stl
new file mode 100644
index 0000000..3742b24
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/r_wheel_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/shoulder_lift_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/shoulder_lift_link_collision.stl
new file mode 100644
index 0000000..c9aff0d
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/shoulder_lift_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/shoulder_pan_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/shoulder_pan_link_collision.stl
new file mode 100644
index 0000000..ac17a94
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/shoulder_pan_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/torso_fixed_link.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/torso_fixed_link.stl
new file mode 100644
index 0000000..7cf7fc1
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/torso_fixed_link.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/torso_lift_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/torso_lift_link_collision.stl
new file mode 100644
index 0000000..4ce5fcf
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/torso_lift_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/upperarm_roll_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/upperarm_roll_link_collision.stl
new file mode 100644
index 0000000..1207932
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/upperarm_roll_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/wrist_flex_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/wrist_flex_link_collision.stl
new file mode 100644
index 0000000..3215d2e
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/wrist_flex_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/wrist_roll_link_collision.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/wrist_roll_link_collision.stl
new file mode 100644
index 0000000..742bdd9
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/fetch/wrist_roll_link_collision.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F1.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F1.stl
new file mode 100644
index 0000000..515d3c9
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F1.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F2.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F2.stl
new file mode 100644
index 0000000..7bc5e20
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F2.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F3.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F3.stl
new file mode 100644
index 0000000..223f06f
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/F3.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH1_z.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH1_z.stl
new file mode 100644
index 0000000..400ee2d
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH1_z.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH2_z.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH2_z.stl
new file mode 100644
index 0000000..5ace838
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH2_z.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH3_z.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH3_z.stl
new file mode 100644
index 0000000..23485ab
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/TH3_z.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/forearm_electric.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/forearm_electric.stl
new file mode 100644
index 0000000..80f6f3d
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/forearm_electric.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/forearm_electric_cvx.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/forearm_electric_cvx.stl
new file mode 100644
index 0000000..3c30f57
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/forearm_electric_cvx.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/knuckle.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/knuckle.stl
new file mode 100644
index 0000000..4faedd7
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/knuckle.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/lfmetacarpal.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/lfmetacarpal.stl
new file mode 100644
index 0000000..535cf4d
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/lfmetacarpal.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/palm.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/palm.stl
new file mode 100644
index 0000000..65e47eb
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/palm.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/wrist.stl b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/wrist.stl
new file mode 100644
index 0000000..420d5f9
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/stls/hand/wrist.stl differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/textures/block.png b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/textures/block.png
new file mode 100644
index 0000000..0243b8f
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/textures/block.png differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/textures/block_hidden.png b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/textures/block_hidden.png
new file mode 100644
index 0000000..e08b861
Binary files /dev/null and b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/assets/textures/block_hidden.png differ
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/__init__.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/pick_and_place.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/pick_and_place.py
new file mode 100644
index 0000000..c6c5e7e
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/pick_and_place.py
@@ -0,0 +1,23 @@
+import os
+from gym import utils
+from gym.envs.robotics import fetch_env
+
+
+# Ensure we get the path separator correct on windows
+MODEL_XML_PATH = os.path.join('fetch', 'pick_and_place.xml')
+
+
+class FetchPickAndPlaceEnv(fetch_env.FetchEnv, utils.EzPickle):
+    def __init__(self, reward_type='sparse'):
+        initial_qpos = {
+            'robot0:slide0': 0.405,
+            'robot0:slide1': 0.48,
+            'robot0:slide2': 0.0,
+            'object0:joint': [1.25, 0.53, 0.4, 1., 0., 0., 0.],
+        }
+        fetch_env.FetchEnv.__init__(
+            self, MODEL_XML_PATH, has_object=True, block_gripper=False, n_substeps=20,
+            gripper_extra_height=0.2, target_in_the_air=True, target_offset=0.0,
+            obj_range=0.15, target_range=0.15, distance_threshold=0.05,
+            initial_qpos=initial_qpos, reward_type=reward_type)
+        utils.EzPickle.__init__(self)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/push.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/push.py
new file mode 100644
index 0000000..043d101
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/push.py
@@ -0,0 +1,23 @@
+import os
+from gym import utils
+from slbo.envs.robotics import fetch_env
+
+
+# Ensure we get the path separator correct on windows
+MODEL_XML_PATH = os.path.join('fetch', 'push.xml')
+
+
+class FetchPushEnv(fetch_env.FetchEnv, utils.EzPickle):
+    def __init__(self, reward_type='sparse'):
+        initial_qpos = {
+            'robot0:slide0': 0.405,
+            'robot0:slide1': 0.48,
+            'robot0:slide2': 0.0,
+            'object0:joint': [1.25, 0.53, 0.4, 1., 0., 0., 0.],
+        }
+        fetch_env.FetchEnv.__init__(
+            self, MODEL_XML_PATH, has_object=True, block_gripper=True, n_substeps=20,
+            gripper_extra_height=0.0, target_in_the_air=False, target_offset=0.0,
+            obj_range=0.15, target_range=0.15, distance_threshold=0.05,
+            initial_qpos=initial_qpos, reward_type=reward_type)
+        utils.EzPickle.__init__(self)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/reach.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/reach.py
new file mode 100644
index 0000000..cc3fc46
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/reach.py
@@ -0,0 +1,22 @@
+import os
+from gym import utils
+from gym.envs.robotics import fetch_env
+
+
+# Ensure we get the path separator correct on windows
+MODEL_XML_PATH = os.path.join('fetch', 'reach.xml')
+
+
+class FetchReachEnv(fetch_env.FetchEnv, utils.EzPickle):
+    def __init__(self, reward_type='sparse'):
+        initial_qpos = {
+            'robot0:slide0': 0.4049,
+            'robot0:slide1': 0.48,
+            'robot0:slide2': 0.0,
+        }
+        fetch_env.FetchEnv.__init__(
+            self, MODEL_XML_PATH, has_object=False, block_gripper=True, n_substeps=20,
+            gripper_extra_height=0.2, target_in_the_air=True, target_offset=0.0,
+            obj_range=0.15, target_range=0.15, distance_threshold=0.05,
+            initial_qpos=initial_qpos, reward_type=reward_type)
+        utils.EzPickle.__init__(self)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/slide.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/slide.py
new file mode 100644
index 0000000..63234db
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch/slide.py
@@ -0,0 +1,25 @@
+import os
+import numpy as np
+
+from gym import utils
+from gym.envs.robotics import fetch_env
+
+
+# Ensure we get the path separator correct on windows
+MODEL_XML_PATH = os.path.join('fetch', 'slide.xml')
+
+
+class FetchSlideEnv(fetch_env.FetchEnv, utils.EzPickle):
+    def __init__(self, reward_type='sparse'):
+        initial_qpos = {
+            'robot0:slide0': 0.05,
+            'robot0:slide1': 0.48,
+            'robot0:slide2': 0.0,
+            'object0:joint': [1.7, 1.1, 0.41, 1., 0., 0., 0.],
+        }
+        fetch_env.FetchEnv.__init__(
+            self, MODEL_XML_PATH, has_object=True, block_gripper=True, n_substeps=20,
+            gripper_extra_height=-0.02, target_in_the_air=False, target_offset=np.array([0.4, 0.0, 0.0]),
+            obj_range=0.1, target_range=0.3, distance_threshold=0.05,
+            initial_qpos=initial_qpos, reward_type=reward_type)
+        utils.EzPickle.__init__(self)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch_env.py
new file mode 100644
index 0000000..8e19c42
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/fetch_env.py
@@ -0,0 +1,197 @@
+import numpy as np
+
+from gym.envs.robotics import rotations, robot_env, utils
+
+
+def goal_distance(goal_a, goal_b):
+    assert goal_a.shape == goal_b.shape
+    return np.linalg.norm(goal_a - goal_b, axis=-1)
+
+
+class FetchEnv(robot_env.RobotEnv):
+    """Superclass for all Fetch environments.
+    """
+
+    def __init__(
+        self, model_path, n_substeps, gripper_extra_height, block_gripper,
+        has_object, target_in_the_air, target_offset, obj_range, target_range,
+        distance_threshold, initial_qpos, reward_type,
+    ):
+        """Initializes a new Fetch environment.
+
+        Args:
+            model_path (string): path to the environments XML file
+            n_substeps (int): number of substeps the simulation runs on every call to step
+            gripper_extra_height (float): additional height above the table when positioning the gripper
+            block_gripper (boolean): whether or not the gripper is blocked (i.e. not movable) or not
+            has_object (boolean): whether or not the environment has an object
+            target_in_the_air (boolean): whether or not the target should be in the air above the table or on the table surface
+            target_offset (float or array with 3 elements): offset of the target
+            obj_range (float): range of a uniform distribution for sampling initial object positions
+            target_range (float): range of a uniform distribution for sampling a target
+            distance_threshold (float): the threshold after which a goal is considered achieved
+            initial_qpos (dict): a dictionary of joint names and values that define the initial configuration
+            reward_type ('sparse' or 'dense'): the reward type, i.e. sparse or dense
+        """
+        self.gripper_extra_height = gripper_extra_height
+        self.block_gripper = block_gripper
+        self.has_object = has_object
+        self.target_in_the_air = target_in_the_air
+        self.target_offset = target_offset
+        self.obj_range = obj_range
+        self.target_range = target_range
+        self.distance_threshold = distance_threshold
+        self.reward_type = reward_type
+
+        super(FetchEnv, self).__init__(
+            model_path=model_path, n_substeps=n_substeps, n_actions=4,
+            initial_qpos=initial_qpos)
+
+    # GoalEnv methods
+    # ----------------------------
+
+    def compute_reward(self, achieved_goal, goal, info):
+        # Compute distance between goal and the achieved goal.
+        d = goal_distance(achieved_goal, goal)
+        return -(d > self.distance_threshold).astype(np.float32)
+
+    # RobotEnv methods
+    # ----------------------------
+
+    def _step_callback(self):
+        if self.block_gripper:
+            self.sim.data.set_joint_qpos('robot0:l_gripper_finger_joint', 0.)
+            self.sim.data.set_joint_qpos('robot0:r_gripper_finger_joint', 0.)
+            self.sim.forward()
+
+    def _set_action(self, action):
+        assert action.shape == (4,)
+        action = action.copy()  # ensure that we don't change the action outside of this scope
+        pos_ctrl, gripper_ctrl = action[:3], action[3]
+
+        pos_ctrl *= 0.05  # limit maximum change in position
+        rot_ctrl = [1., 0., 1., 0.]  # fixed rotation of the end effector, expressed as a quaternion
+        gripper_ctrl = np.array([gripper_ctrl, gripper_ctrl])
+        assert gripper_ctrl.shape == (2,)
+        if self.block_gripper:
+            gripper_ctrl = np.zeros_like(gripper_ctrl)
+        action = np.concatenate([pos_ctrl, rot_ctrl, gripper_ctrl])
+
+        # Apply action to simulation.
+        utils.ctrl_set_action(self.sim, action)
+        utils.mocap_set_action(self.sim, action)
+
+    def _get_obs(self):
+        # positions
+        grip_pos = self.sim.data.get_site_xpos('robot0:grip')
+        dt = self.sim.nsubsteps * self.sim.model.opt.timestep
+        grip_velp = self.sim.data.get_site_xvelp('robot0:grip') * dt
+        robot_qpos, robot_qvel = utils.robot_get_obs(self.sim)
+        if self.has_object:
+            object_pos = self.sim.data.get_site_xpos('object0')
+            # rotations
+            object_rot = rotations.mat2euler(self.sim.data.get_site_xmat('object0'))
+            # velocities
+            object_velp = self.sim.data.get_site_xvelp('object0') * dt
+            object_velr = self.sim.data.get_site_xvelr('object0') * dt
+            # gripper state
+            object_rel_pos = object_pos - grip_pos
+            object_velp -= grip_velp
+        else:
+            object_pos = object_rot = object_velp = object_velr = object_rel_pos = np.zeros(0)
+        gripper_state = robot_qpos[-2:]
+        gripper_vel = robot_qvel[-2:] * dt  # change to a scalar if the gripper is made symmetric
+
+        if not self.has_object:
+            achieved_goal = grip_pos.copy()
+        else:
+            achieved_goal = np.squeeze(object_pos.copy())
+        obs = np.concatenate([
+            grip_pos, object_pos.ravel(), object_rel_pos.ravel(), gripper_state, object_rot.ravel(),
+            object_velp.ravel(), object_velr.ravel(), grip_velp, gripper_vel,
+        ])
+
+        return {
+            'observation': obs.copy(),
+            'achieved_goal': achieved_goal.copy(),
+            'desired_goal': self.goal.copy(),
+        }
+
+    def mb_step(self, states, actions, next_states):
+        a = next_states[:,:3]
+        b = next_states[:,3:6]
+        d = np.linalg.norm(a - b, axis=-1)
+        rewards = -(d <= self.distance_threshold).astype(np.float32) 
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def verify(self):
+        pass
+
+    def _viewer_setup(self):
+        body_id = self.sim.model.body_name2id('robot0:gripper_link')
+        lookat = self.sim.data.body_xpos[body_id]
+        for idx, value in enumerate(lookat):
+            self.viewer.cam.lookat[idx] = value
+        self.viewer.cam.distance = 2.5
+        self.viewer.cam.azimuth = 132.
+        self.viewer.cam.elevation = -14.
+
+    def _render_callback(self):
+        # Visualize target.
+        sites_offset = (self.sim.data.site_xpos - self.sim.model.site_pos).copy()
+        site_id = self.sim.model.site_name2id('target0')
+        self.sim.model.site_pos[site_id] = self.goal - sites_offset[0]
+        self.sim.forward()
+
+    def _reset_sim(self):
+        self.sim.set_state(self.initial_state)
+
+        # Randomize start position of object.
+        if self.has_object:
+            object_xpos = self.initial_gripper_xpos[:2]
+            while np.linalg.norm(object_xpos - self.initial_gripper_xpos[:2]) < 0.1:
+                object_xpos = self.initial_gripper_xpos[:2] + self.np_random.uniform(-self.obj_range, self.obj_range, size=2)
+            object_qpos = self.sim.data.get_joint_qpos('object0:joint')
+            assert object_qpos.shape == (7,)
+            object_qpos[:2] = object_xpos
+            self.sim.data.set_joint_qpos('object0:joint', object_qpos)
+
+        self.sim.forward()
+        return True
+
+    def _sample_goal(self):
+        if self.has_object:
+            goal = self.initial_gripper_xpos[:3] + self.np_random.uniform(-self.target_range, self.target_range, size=3)
+            goal += self.target_offset
+            goal[2] = self.height_offset
+            if self.target_in_the_air and self.np_random.uniform() < 0.5:
+                goal[2] += self.np_random.uniform(0, 0.45)
+        else:
+            goal = self.initial_gripper_xpos[:3] + self.np_random.uniform(-self.target_range, self.target_range, size=3)
+        return goal.copy()
+
+    def _is_success(self, achieved_goal, desired_goal):
+        d = goal_distance(achieved_goal, desired_goal)
+        return (d < self.distance_threshold).astype(np.float32)
+
+    def _env_setup(self, initial_qpos):
+        for name, value in initial_qpos.items():
+            self.sim.data.set_joint_qpos(name, value)
+        utils.reset_mocap_welds(self.sim)
+        self.sim.forward()
+
+        # Move end effector into position.
+        gripper_target = np.array([-0.498, 0.005, -0.431 + self.gripper_extra_height]) + self.sim.data.get_site_xpos('robot0:grip')
+        gripper_rotation = np.array([1., 0., 1., 0.])
+        self.sim.data.set_mocap_pos('robot0:mocap', gripper_target)
+        self.sim.data.set_mocap_quat('robot0:mocap', gripper_rotation)
+        for _ in range(10):
+            self.sim.step()
+
+        # Extract information for sampling goals.
+        self.initial_gripper_xpos = self.sim.data.get_site_xpos('robot0:grip').copy()
+        if self.has_object:
+            self.height_offset = self.sim.data.get_site_xpos('object0')[2]
+
+    def render(self, mode='human', width=500, height=500):
+        return super(FetchEnv, self).render(mode, width, height)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/__init__.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/manipulate.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/manipulate.py
new file mode 100644
index 0000000..85a7dd0
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/manipulate.py
@@ -0,0 +1,344 @@
+import os
+import numpy as np
+
+from gym import utils, error
+from gym.envs.robotics import rotations, hand_env
+from gym.envs.robotics.utils import robot_get_obs
+from gym.wrappers import FlattenObservation
+
+
+from slbo.utils.dataset import Dataset, gen_dtype
+
+try:
+    import mujoco_py
+except ImportError as e:
+    raise error.DependencyNotInstalled("{}. (HINT: you need to install mujoco_py, and also perform the setup instructions here: https://github.com/openai/mujoco-py/.)".format(e))
+
+
+def quat_from_angle_and_axis(angle, axis):
+    assert axis.shape == (3,)
+    axis /= np.linalg.norm(axis)
+    quat = np.concatenate([[np.cos(angle / 2.)], np.sin(angle / 2.) * axis])
+    quat /= np.linalg.norm(quat)
+    return quat
+
+
+# Ensure we get the path separator correct on windows
+MANIPULATE_BLOCK_XML = os.path.join('hand', 'manipulate_block.xml')
+MANIPULATE_EGG_XML = os.path.join('hand', 'manipulate_egg.xml')
+MANIPULATE_PEN_XML = os.path.join('hand', 'manipulate_pen.xml')
+
+
+class ManipulateEnv(hand_env.HandEnv):
+    def __init__(
+        self, model_path, target_position, target_rotation,
+        target_position_range, reward_type, initial_qpos=None,
+        randomize_initial_position=True, randomize_initial_rotation=True,
+        distance_threshold=0.01, rotation_threshold=0.1, n_substeps=20, relative_control=False,
+        ignore_z_target_rotation=False,
+    ):
+        """Initializes a new Hand manipulation environment.
+
+        Args:
+            model_path (string): path to the environments XML file
+            target_position (string): the type of target position:
+                - ignore: target position is fully ignored, i.e. the object can be positioned arbitrarily
+                - fixed: target position is set to the initial position of the object
+                - random: target position is fully randomized according to target_position_range
+            target_rotation (string): the type of target rotation:
+                - ignore: target rotation is fully ignored, i.e. the object can be rotated arbitrarily
+                - fixed: target rotation is set to the initial rotation of the object
+                - xyz: fully randomized target rotation around the X, Y and Z axis
+                - z: fully randomized target rotation around the Z axis
+                - parallel: fully randomized target rotation around Z and axis-aligned rotation around X, Y
+            ignore_z_target_rotation (boolean): whether or not the Z axis of the target rotation is ignored
+            target_position_range (np.array of shape (3, 2)): range of the target_position randomization
+            reward_type ('sparse' or 'dense'): the reward type, i.e. sparse or dense
+            initial_qpos (dict): a dictionary of joint names and values that define the initial configuration
+            randomize_initial_position (boolean): whether or not to randomize the initial position of the object
+            randomize_initial_rotation (boolean): whether or not to randomize the initial rotation of the object
+            distance_threshold (float, in meters): the threshold after which the position of a goal is considered achieved
+            rotation_threshold (float, in radians): the threshold after which the rotation of a goal is considered achieved
+            n_substeps (int): number of substeps the simulation runs on every call to step
+            relative_control (boolean): whether or not the hand is actuated in absolute joint positions or relative to the current state
+        """
+        self.target_position = target_position
+        self.target_rotation = target_rotation
+        self.target_position_range = target_position_range
+        self.parallel_quats = [rotations.euler2quat(r) for r in rotations.get_parallel_rotations()]
+        self.randomize_initial_rotation = randomize_initial_rotation
+        self.randomize_initial_position = randomize_initial_position
+        self.distance_threshold = distance_threshold
+        self.rotation_threshold = rotation_threshold
+        self.reward_type = reward_type
+        self.ignore_z_target_rotation = ignore_z_target_rotation
+
+        assert self.target_position in ['ignore', 'fixed', 'random']
+        assert self.target_rotation in ['ignore', 'fixed', 'xyz', 'z', 'parallel']
+        initial_qpos = initial_qpos or {}
+
+        hand_env.HandEnv.__init__(
+            self, model_path, n_substeps=n_substeps, initial_qpos=initial_qpos,
+            relative_control=relative_control)
+
+
+    def _get_achieved_goal(self):
+        # Object position and rotation.
+        object_qpos = self.sim.data.get_joint_qpos('object:joint')
+        assert object_qpos.shape == (7,)
+        return object_qpos
+
+    def _goal_distance(self, goal_a, goal_b):
+        assert goal_a.shape == goal_b.shape
+        assert goal_a.shape[-1] == 7
+
+        d_pos = np.zeros_like(goal_a[..., 0])
+        d_rot = np.zeros_like(goal_b[..., 0])
+        if self.target_position != 'ignore':
+            delta_pos = goal_a[..., :3] - goal_b[..., :3]
+            d_pos = np.linalg.norm(delta_pos, axis=-1)
+
+        if self.target_rotation != 'ignore':
+            quat_a, quat_b = goal_a[..., 3:], goal_b[..., 3:]
+
+            if self.ignore_z_target_rotation:
+                # Special case: We want to ignore the Z component of the rotation.
+                # This code here assumes Euler angles with xyz convention. We first transform
+                # to euler, then set the Z component to be equal between the two, and finally
+                # transform back into quaternions.
+                euler_a = rotations.quat2euler(quat_a)
+                euler_b = rotations.quat2euler(quat_b)
+                euler_a[2] = euler_b[2]
+                quat_a = rotations.euler2quat(euler_a)
+
+            # Subtract quaternions and extract angle between them.
+            quat_diff = rotations.quat_mul(quat_a, rotations.quat_conjugate(quat_b))
+            angle_diff = 2 * np.arccos(np.clip(quat_diff[..., 0], -1., 1.))
+            d_rot = angle_diff
+        assert d_pos.shape == d_rot.shape
+        return d_pos, d_rot
+
+    # GoalEnv methods
+    # ----------------------------
+
+    def compute_reward(self, achieved_goal, goal, info):
+        if self.reward_type == 'sparse':
+            success = self._is_success(achieved_goal, goal).astype(np.float32)
+            return success 
+        else:
+            d_pos, d_rot = self._goal_distance(achieved_goal, goal)
+            # We weigh the difference in position to avoid that `d_pos` (in meters) is completely
+            # dominated by `d_rot` (in radians).
+            return -(10. * d_pos + d_rot)
+
+    # RobotEnv methods
+    # ----------------------------
+
+    def _is_success(self, achieved_goal, desired_goal):
+        d_pos, d_rot = self._goal_distance(achieved_goal, desired_goal)
+        achieved_pos = (d_pos < self.distance_threshold).astype(np.float32)
+        achieved_rot = (d_rot < self.rotation_threshold).astype(np.float32)
+        achieved_both = achieved_pos * achieved_rot
+        return achieved_both
+
+    def _env_setup(self, initial_qpos):
+        for name, value in initial_qpos.items():
+            self.sim.data.set_joint_qpos(name, value)
+        self.sim.forward()
+
+    def _reset_sim(self):
+        self.sim.set_state(self.initial_state)
+        self.sim.forward()
+
+        initial_qpos = self.sim.data.get_joint_qpos('object:joint').copy()
+        initial_pos, initial_quat = initial_qpos[:3], initial_qpos[3:]
+        assert initial_qpos.shape == (7,)
+        assert initial_pos.shape == (3,)
+        assert initial_quat.shape == (4,)
+        initial_qpos = None
+
+        # Randomization initial rotation.
+        if self.randomize_initial_rotation:
+            if self.target_rotation == 'z':
+                angle = self.np_random.uniform(-np.pi, np.pi)
+                axis = np.array([0., 0., 1.])
+                offset_quat = quat_from_angle_and_axis(angle, axis)
+                initial_quat = rotations.quat_mul(initial_quat, offset_quat)
+            elif self.target_rotation == 'parallel':
+                angle = self.np_random.uniform(-np.pi, np.pi)
+                axis = np.array([0., 0., 1.])
+                z_quat = quat_from_angle_and_axis(angle, axis)
+                parallel_quat = self.parallel_quats[self.np_random.randint(len(self.parallel_quats))]
+                offset_quat = rotations.quat_mul(z_quat, parallel_quat)
+                initial_quat = rotations.quat_mul(initial_quat, offset_quat)
+            elif self.target_rotation in ['xyz', 'ignore']:
+                angle = self.np_random.uniform(-np.pi, np.pi)
+                axis = self.np_random.uniform(-1., 1., size=3)
+                offset_quat = quat_from_angle_and_axis(angle, axis)
+                initial_quat = rotations.quat_mul(initial_quat, offset_quat)
+            elif self.target_rotation == 'fixed':
+                pass
+            else:
+                raise error.Error('Unknown target_rotation option "{}".'.format(self.target_rotation))
+
+        # Randomize initial position.
+        if self.randomize_initial_position:
+            if self.target_position != 'fixed':
+                initial_pos += self.np_random.normal(size=3, scale=0.005)
+
+        initial_quat /= np.linalg.norm(initial_quat)
+        initial_qpos = np.concatenate([initial_pos, initial_quat])
+        self.sim.data.set_joint_qpos('object:joint', initial_qpos)
+
+        def is_on_palm():
+            self.sim.forward()
+            cube_middle_idx = self.sim.model.site_name2id('object:center')
+            cube_middle_pos = self.sim.data.site_xpos[cube_middle_idx]
+            is_on_palm = (cube_middle_pos[2] > 0.04)
+            return is_on_palm
+
+        # Run the simulation for a bunch of timesteps to let everything settle in.
+        for _ in range(10):
+            self._set_action(np.zeros(20))
+            try:
+                self.sim.step()
+            except mujoco_py.MujocoException:
+                return False
+        return is_on_palm()
+
+    def _sample_goal(self):
+        # Select a goal for the object position.
+        target_pos = None
+        if self.target_position == 'random':
+            assert self.target_position_range.shape == (3, 2)
+            offset = self.np_random.uniform(self.target_position_range[:, 0], self.target_position_range[:, 1])
+            assert offset.shape == (3,)
+            target_pos = self.sim.data.get_joint_qpos('object:joint')[:3] + offset
+        elif self.target_position in ['ignore', 'fixed']:
+            target_pos = self.sim.data.get_joint_qpos('object:joint')[:3]
+        else:
+            raise error.Error('Unknown target_position option "{}".'.format(self.target_position))
+        assert target_pos is not None
+        assert target_pos.shape == (3,)
+
+        # Select a goal for the object rotation.
+        target_quat = None
+        if self.target_rotation == 'z':
+            angle = self.np_random.uniform(-np.pi, np.pi)
+            axis = np.array([0., 0., 1.])
+            target_quat = quat_from_angle_and_axis(angle, axis)
+        elif self.target_rotation == 'parallel':
+            angle = self.np_random.uniform(-np.pi, np.pi)
+            axis = np.array([0., 0., 1.])
+            target_quat = quat_from_angle_and_axis(angle, axis)
+            parallel_quat = self.parallel_quats[self.np_random.randint(len(self.parallel_quats))]
+            target_quat = rotations.quat_mul(target_quat, parallel_quat)
+        elif self.target_rotation == 'xyz':
+            angle = self.np_random.uniform(-np.pi, np.pi)
+            axis = self.np_random.uniform(-1., 1., size=3)
+            target_quat = quat_from_angle_and_axis(angle, axis)
+        elif self.target_rotation in ['ignore', 'fixed']:
+            target_quat = self.sim.data.get_joint_qpos('object:joint')[3:]
+        else:
+            raise error.Error('Unknown target_rotation option "{}".'.format(self.target_rotation))
+        assert target_quat is not None
+        assert target_quat.shape == (4,)
+
+        target_quat /= np.linalg.norm(target_quat)  # normalized quaternion
+        goal = np.concatenate([target_pos, target_quat])
+        return goal
+
+    def _render_callback(self):
+        # Assign current state to target object but offset a bit so that the actual object
+        # is not obscured.
+        goal = self.goal.copy()
+        assert goal.shape == (7,)
+        if self.target_position == 'ignore':
+            # Move the object to the side since we do not care about it's position.
+            goal[0] += 0.15
+        self.sim.data.set_joint_qpos('target:joint', goal)
+        self.sim.data.set_joint_qvel('target:joint', np.zeros(6))
+
+        if 'object_hidden' in self.sim.model.geom_names:
+            hidden_id = self.sim.model.geom_name2id('object_hidden')
+            self.sim.model.geom_rgba[hidden_id, 3] = 1.
+        self.sim.forward()
+
+    def _get_obs(self):
+        robot_qpos, robot_qvel = robot_get_obs(self.sim)
+        object_qvel = self.sim.data.get_joint_qvel('object:joint')
+        achieved_goal = self._get_achieved_goal().ravel()  # this contains the object position + rotation
+        observation = np.concatenate([robot_qpos, robot_qvel, object_qvel, achieved_goal])
+        return {
+            'observation': observation.copy(),
+            'achieved_goal': achieved_goal.copy(),
+            'desired_goal': self.goal.ravel().copy(),
+        }
+
+
+class HandBlockEnv(ManipulateEnv, utils.EzPickle):
+    def __init__(self, target_position='random', target_rotation='xyz', reward_type='sparse'):
+        utils.EzPickle.__init__(self, target_position, target_rotation, reward_type)
+        ManipulateEnv.__init__(self,
+            model_path=MANIPULATE_BLOCK_XML, target_position=target_position,
+            target_rotation=target_rotation,
+            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),
+            reward_type=reward_type)
+
+
+class HandEggEnv(ManipulateEnv, utils.EzPickle):
+    def __init__(self, target_position='random', target_rotation='fixed', reward_type='sparse'):
+        utils.EzPickle.__init__(self, target_position, target_rotation, reward_type)
+        ManipulateEnv.__init__(self,
+            model_path=MANIPULATE_EGG_XML, target_position=target_position,
+            target_rotation=target_rotation,
+            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),
+            reward_type=reward_type)
+
+
+    def verify(self, n=2000, eps=1e-4):
+        dummy = FlattenObservation(self)
+
+        dataset = Dataset(gen_dtype(dummy, 'state action next_state reward done'), n)
+        state = dummy.reset()
+        #print(state)
+        for _ in range(n):
+            action = dummy.action_space.sample()
+            next_state, reward, done, _ = dummy.step(action)
+            dataset.append((state, action, next_state, reward, done))
+
+            state = next_state
+            if done:
+                state = dummy.reset()
+
+        rewards_, dones_ = self.mb_step(dataset.state, dataset.action, dataset.next_state)
+        diff = dataset.reward - rewards_
+        l_inf = np.abs(diff).max()
+        # logger.info('rewarder difference: %.6f', l_inf)
+
+        assert np.allclose(dones_, dataset.done)
+        assert l_inf < eps
+
+    def mb_step(self, states, actions, next_states):
+        a = next_states[:,:7]
+        b = next_states[:,7:14]
+        if self.reward_type == 'sparse':
+            success = self._is_success(a, b).astype(np.float32)
+            rewards = (success * 10 - 1.)
+        else:
+            d_pos, d_rot = self._goal_distance(a, b)
+            # We weigh the difference in position to avoid that `d_pos` (in meters) is completely
+            # dominated by `d_rot` (in radians).
+            rewards = -(10. * d_pos + d_rot)
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+
+class HandPenEnv(ManipulateEnv, utils.EzPickle):
+    def __init__(self, target_position='random', target_rotation='xyz', reward_type='sparse'):
+        utils.EzPickle.__init__(self, target_position, target_rotation, reward_type)
+        ManipulateEnv.__init__(self,
+            model_path=MANIPULATE_PEN_XML, target_position=target_position,
+            target_rotation=target_rotation,
+            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),
+            randomize_initial_rotation=False, reward_type=reward_type,
+            ignore_z_target_rotation=True, distance_threshold=0.05)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/manipulate_touch_sensors.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/manipulate_touch_sensors.py
new file mode 100644
index 0000000..c364868
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/manipulate_touch_sensors.py
@@ -0,0 +1,131 @@
+import os
+import numpy as np
+
+from gym import utils, error, spaces
+from gym.envs.robotics.hand import manipulate
+
+# Ensure we get the path separator correct on windows
+MANIPULATE_BLOCK_XML = os.path.join('hand', 'manipulate_block_touch_sensors.xml')
+MANIPULATE_EGG_XML = os.path.join('hand', 'manipulate_egg_touch_sensors.xml')
+MANIPULATE_PEN_XML = os.path.join('hand', 'manipulate_pen_touch_sensors.xml')
+
+
+class ManipulateTouchSensorsEnv(manipulate.ManipulateEnv):
+    def __init__(
+        self, model_path, target_position, target_rotation,
+        target_position_range, reward_type, initial_qpos={},
+        randomize_initial_position=True, randomize_initial_rotation=True,
+        distance_threshold=0.01, rotation_threshold=0.1, n_substeps=20, relative_control=False,
+        ignore_z_target_rotation=False, touch_visualisation="on_touch", touch_get_obs="sensordata",
+    ):
+        """Initializes a new Hand manipulation environment with touch sensors.
+
+        Args:
+            touch_visualisation (string): how touch sensor sites are visualised
+                - "on_touch": shows touch sensor sites only when touch values > 0
+                - "always": always shows touch sensor sites
+                - "off" or else: does not show touch sensor sites
+            touch_get_obs (string): touch sensor readings
+                - "boolean": returns 1 if touch sensor reading != 0.0 else 0
+                - "sensordata": returns original touch sensor readings from self.sim.data.sensordata[id]
+                - "log": returns log(x+1) touch sensor readings from self.sim.data.sensordata[id]
+                - "off" or else: does not add touch sensor readings to the observation
+
+        """
+        self.touch_visualisation = touch_visualisation
+        self.touch_get_obs = touch_get_obs
+        self._touch_sensor_id_site_id = []
+        self._touch_sensor_id = []
+        self.touch_color = [1, 0, 0, 0.5]
+        self.notouch_color = [0, 0.5, 0, 0.2]
+
+        manipulate.ManipulateEnv.__init__(
+            self, model_path, target_position, target_rotation,
+            target_position_range, reward_type, initial_qpos=initial_qpos,
+            randomize_initial_position=randomize_initial_position, randomize_initial_rotation=randomize_initial_rotation,
+            distance_threshold=distance_threshold, rotation_threshold=rotation_threshold, n_substeps=n_substeps, relative_control=relative_control,
+            ignore_z_target_rotation=ignore_z_target_rotation,
+        )
+
+        for k, v in self.sim.model._sensor_name2id.items():  # get touch sensor site names and their ids
+            if 'robot0:TS_' in k:
+                self._touch_sensor_id_site_id.append((v, self.sim.model._site_name2id[k.replace('robot0:TS_', 'robot0:T_')]))
+                self._touch_sensor_id.append(v)
+
+        if self.touch_visualisation == 'off':  # set touch sensors rgba values
+            for _, site_id in self._touch_sensor_id_site_id:
+                self.sim.model.site_rgba[site_id][3] = 0.0
+        elif self.touch_visualisation == 'always':
+            pass
+
+        obs = self._get_obs()
+        self.observation_space = spaces.Dict(dict(
+            desired_goal=spaces.Box(-np.inf, np.inf, shape=obs['achieved_goal'].shape, dtype='float32'),
+            achieved_goal=spaces.Box(-np.inf, np.inf, shape=obs['achieved_goal'].shape, dtype='float32'),
+            observation=spaces.Box(-np.inf, np.inf, shape=obs['observation'].shape, dtype='float32'),
+        ))
+
+    def _render_callback(self):
+        super(ManipulateTouchSensorsEnv, self)._render_callback()
+        if self.touch_visualisation == 'on_touch':
+            for touch_sensor_id, site_id in self._touch_sensor_id_site_id:
+                if self.sim.data.sensordata[touch_sensor_id] != 0.0:
+                    self.sim.model.site_rgba[site_id] = self.touch_color
+                else:
+                    self.sim.model.site_rgba[site_id] = self.notouch_color
+
+    def _get_obs(self):
+        robot_qpos, robot_qvel = manipulate.robot_get_obs(self.sim)
+        object_qvel = self.sim.data.get_joint_qvel('object:joint')
+        achieved_goal = self._get_achieved_goal().ravel()  # this contains the object position + rotation
+        touch_values = []  # get touch sensor readings. if there is one, set value to 1
+        if self.touch_get_obs == 'sensordata':
+            touch_values = self.sim.data.sensordata[self._touch_sensor_id]
+        elif self.touch_get_obs == 'boolean':
+            touch_values = self.sim.data.sensordata[self._touch_sensor_id] > 0.0
+        elif self.touch_get_obs == 'log':
+            touch_values = np.log(self.sim.data.sensordata[self._touch_sensor_id] + 1.0)
+        observation = np.concatenate([robot_qpos, robot_qvel, object_qvel, touch_values, achieved_goal])
+
+        return {
+            'observation': observation.copy(),
+            'achieved_goal': achieved_goal.copy(),
+            'desired_goal': self.goal.ravel().copy(),
+        }
+
+
+class HandBlockTouchSensorsEnv(ManipulateTouchSensorsEnv, utils.EzPickle):
+    def __init__(self, target_position='random', target_rotation='xyz', touch_get_obs='sensordata', reward_type='sparse'):
+        utils.EzPickle.__init__(self, target_position, target_rotation, touch_get_obs, reward_type)
+        ManipulateTouchSensorsEnv.__init__(self,
+            model_path=MANIPULATE_BLOCK_XML,
+            touch_get_obs=touch_get_obs,
+            target_rotation=target_rotation,
+            target_position=target_position,
+            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),
+            reward_type=reward_type)
+
+
+class HandEggTouchSensorsEnv(ManipulateTouchSensorsEnv, utils.EzPickle):
+    def __init__(self, target_position='random', target_rotation='xyz', touch_get_obs='sensordata', reward_type='sparse'):
+        utils.EzPickle.__init__(self, target_position, target_rotation, touch_get_obs, reward_type)
+        ManipulateTouchSensorsEnv.__init__(self,
+            model_path=MANIPULATE_EGG_XML,
+            touch_get_obs=touch_get_obs,
+            target_rotation=target_rotation,
+            target_position=target_position,
+            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),
+            reward_type=reward_type)
+
+
+class HandPenTouchSensorsEnv(ManipulateTouchSensorsEnv, utils.EzPickle):
+    def __init__(self, target_position='random', target_rotation='xyz', touch_get_obs='sensordata', reward_type='sparse'):
+        utils.EzPickle.__init__(self, target_position, target_rotation, touch_get_obs, reward_type)
+        ManipulateTouchSensorsEnv.__init__(self,
+            model_path=MANIPULATE_PEN_XML,
+            touch_get_obs=touch_get_obs,
+            target_rotation=target_rotation,
+            target_position=target_position,
+            target_position_range=np.array([(-0.04, 0.04), (-0.06, 0.02), (0.0, 0.06)]),
+            randomize_initial_rotation=False, reward_type=reward_type,
+            ignore_z_target_rotation=True, distance_threshold=0.05)
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/reach.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/reach.py
new file mode 100644
index 0000000..1459e5a
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand/reach.py
@@ -0,0 +1,159 @@
+import os
+import numpy as np
+
+from gym import utils
+from slbo.envs.robotics import hand_env
+from gym.envs.robotics.utils import robot_get_obs
+
+
+FINGERTIP_SITE_NAMES = [
+    'robot0:S_fftip',
+    'robot0:S_mftip',
+    'robot0:S_rftip',
+    'robot0:S_lftip',
+    'robot0:S_thtip',
+]
+
+
+DEFAULT_INITIAL_QPOS = {
+    'robot0:WRJ1': -0.16514339750464327,
+    'robot0:WRJ0': -0.31973286565062153,
+    'robot0:FFJ3': 0.14340512546557435,
+    'robot0:FFJ2': 0.32028208333591573,
+    'robot0:FFJ1': 0.7126053607727917,
+    'robot0:FFJ0': 0.6705281001412586,
+    'robot0:MFJ3': 0.000246444303701037,
+    'robot0:MFJ2': 0.3152655251085491,
+    'robot0:MFJ1': 0.7659800313729842,
+    'robot0:MFJ0': 0.7323156897425923,
+    'robot0:RFJ3': 0.00038520700007378114,
+    'robot0:RFJ2': 0.36743546201985233,
+    'robot0:RFJ1': 0.7119514095008576,
+    'robot0:RFJ0': 0.6699446327514138,
+    'robot0:LFJ4': 0.0525442258033891,
+    'robot0:LFJ3': -0.13615534724474673,
+    'robot0:LFJ2': 0.39872030433433003,
+    'robot0:LFJ1': 0.7415570009679252,
+    'robot0:LFJ0': 0.704096378652974,
+    'robot0:THJ4': 0.003673823825070126,
+    'robot0:THJ3': 0.5506291436028695,
+    'robot0:THJ2': -0.014515151997119306,
+    'robot0:THJ1': -0.0015229223564485414,
+    'robot0:THJ0': -0.7894883021600622,
+}
+
+
+# Ensure we get the path separator correct on windows
+MODEL_XML_PATH = os.path.join('hand', 'reach.xml')
+
+
+def goal_distance(goal_a, goal_b):
+    assert goal_a.shape == goal_b.shape
+    return np.linalg.norm(goal_a - goal_b, axis=-1)
+
+
+class HandReachEnv(hand_env.HandEnv, utils.EzPickle):
+    def __init__(
+        self, distance_threshold=0.01, n_substeps=20, relative_control=False,
+        initial_qpos=DEFAULT_INITIAL_QPOS, reward_type='sparse',
+    ):
+        utils.EzPickle.__init__(**locals())
+        self.distance_threshold = distance_threshold
+        self.reward_type = 'sparse'
+
+        hand_env.HandEnv.__init__(
+            self, MODEL_XML_PATH, n_substeps=n_substeps, initial_qpos=initial_qpos,
+            relative_control=relative_control)
+
+    def _get_achieved_goal(self):
+        goal = [self.sim.data.get_site_xpos(name) for name in FINGERTIP_SITE_NAMES]
+        return np.array(goal).flatten()
+
+    # GoalEnv methods
+    # ----------------------------
+
+    def compute_reward(self, achieved_goal, goal, info):
+        d = goal_distance(achieved_goal, goal)
+        if self.reward_type == 'sparse':
+            return -(d > self.distance_threshold).astype(np.float32)
+        else:
+            return -d
+
+    # RobotEnv methods
+    # ----------------------------
+
+    def mb_step(self, states, actions, next_states):
+        a = next_states[:,:15]
+        b = next_states[:,15:30]
+        d = goal_distance(achieved_goal, goal)
+        if self.reward_type == 'sparse':
+            rewards =  -(d > self.distance_threshold).astype(np.float32)
+        else:
+            rewards =  -d
+        return rewards, np.zeros_like(rewards, dtype=np.bool)
+
+    def _env_setup(self, initial_qpos):
+        for name, value in initial_qpos.items():
+            self.sim.data.set_joint_qpos(name, value)
+        self.sim.forward()
+
+        self.initial_goal = self._get_achieved_goal().copy()
+        self.palm_xpos = self.sim.data.body_xpos[self.sim.model.body_name2id('robot0:palm')].copy()
+
+    def _get_obs(self):
+        robot_qpos, robot_qvel = robot_get_obs(self.sim)
+        achieved_goal = self._get_achieved_goal().ravel()
+        observation = np.concatenate([robot_qpos, robot_qvel, achieved_goal])
+        return {
+            'observation': observation.copy(),
+            'achieved_goal': achieved_goal.copy(),
+            'desired_goal': self.goal.copy(),
+        }
+
+    def _sample_goal(self):
+        thumb_name = 'robot0:S_thtip'
+        finger_names = [name for name in FINGERTIP_SITE_NAMES if name != thumb_name]
+        finger_name = self.np_random.choice(finger_names)
+
+        thumb_idx = FINGERTIP_SITE_NAMES.index(thumb_name)
+        finger_idx = FINGERTIP_SITE_NAMES.index(finger_name)
+        assert thumb_idx != finger_idx
+
+        # Pick a meeting point above the hand.
+        meeting_pos = self.palm_xpos + np.array([0.0, -0.09, 0.05])
+        meeting_pos += self.np_random.normal(scale=0.005, size=meeting_pos.shape)
+
+        # Slightly move meeting goal towards the respective finger to avoid that they
+        # overlap.
+        goal = self.initial_goal.copy().reshape(-1, 3)
+        for idx in [thumb_idx, finger_idx]:
+            offset_direction = (meeting_pos - goal[idx])
+            offset_direction /= np.linalg.norm(offset_direction)
+            goal[idx] = meeting_pos - 0.005 * offset_direction
+
+        if self.np_random.uniform() < 0.1:
+            # With some probability, ask all fingers to move back to the origin.
+            # This avoids that the thumb constantly stays near the goal position already.
+            goal = self.initial_goal.copy()
+        return goal.flatten()
+
+    def _is_success(self, achieved_goal, desired_goal):
+        d = goal_distance(achieved_goal, desired_goal)
+        return (d < self.distance_threshold).astype(np.float32)
+
+    def _render_callback(self):
+        # Visualize targets.
+        sites_offset = (self.sim.data.site_xpos - self.sim.model.site_pos).copy()
+        goal = self.goal.reshape(5, 3)
+        for finger_idx in range(5):
+            site_name = 'target{}'.format(finger_idx)
+            site_id = self.sim.model.site_name2id(site_name)
+            self.sim.model.site_pos[site_id] = goal[finger_idx] - sites_offset[site_id]
+
+        # Visualize finger positions.
+        achieved_goal = self._get_achieved_goal().reshape(5, 3)
+        for finger_idx in range(5):
+            site_name = 'finger{}'.format(finger_idx)
+            site_id = self.sim.model.site_name2id(site_name)
+            self.sim.model.site_pos[site_id] = achieved_goal[finger_idx] - sites_offset[site_id]
+        self.sim.forward()
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand_env.py
new file mode 100644
index 0000000..a66e2cd
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/hand_env.py
@@ -0,0 +1,55 @@
+import os
+import copy
+import numpy as np
+
+import gym
+from gym import error, spaces
+from gym.utils import seeding
+from gym.envs.robotics import robot_env
+
+
+class HandEnv(robot_env.RobotEnv):
+    def __init__(self, model_path, n_substeps, initial_qpos, relative_control):
+        self.relative_control = relative_control
+
+        super(HandEnv, self).__init__(
+            model_path=model_path, n_substeps=n_substeps, n_actions=20,
+            initial_qpos=initial_qpos)
+
+    # RobotEnv methods
+    # ----------------------------
+
+    def _set_action(self, action):
+        assert action.shape == (20,)
+
+        ctrlrange = self.sim.model.actuator_ctrlrange
+        actuation_range = (ctrlrange[:, 1] - ctrlrange[:, 0]) / 2.
+        if self.relative_control:
+            actuation_center = np.zeros_like(action)
+            for i in range(self.sim.data.ctrl.shape[0]):
+                actuation_center[i] = self.sim.data.get_joint_qpos(
+                    self.sim.model.actuator_names[i].replace(':A_', ':'))
+            for joint_name in ['FF', 'MF', 'RF', 'LF']:
+                act_idx = self.sim.model.actuator_name2id(
+                    'robot0:A_{}J1'.format(joint_name))
+                actuation_center[act_idx] += self.sim.data.get_joint_qpos(
+                    'robot0:{}J0'.format(joint_name))
+        else:
+            actuation_center = (ctrlrange[:, 1] + ctrlrange[:, 0]) / 2.
+        self.sim.data.ctrl[:] = actuation_center + action * actuation_range
+        self.sim.data.ctrl[:] = np.clip(self.sim.data.ctrl, ctrlrange[:, 0], ctrlrange[:, 1])
+
+    def _viewer_setup(self):
+        body_id = self.sim.model.body_name2id('robot0:palm')
+        lookat = self.sim.data.body_xpos[body_id]
+        for idx, value in enumerate(lookat):
+            self.viewer.cam.lookat[idx] = value
+        self.viewer.cam.distance = 0.5
+        self.viewer.cam.azimuth = 55.
+        self.viewer.cam.elevation = -25.
+
+    def render(self, mode='human', width=500, height=500):
+        return super(HandEnv, self).render(mode, width, height)
+
+    def verify(self):
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/robot_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/robot_env.py
new file mode 100644
index 0000000..584ab1d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/robot_env.py
@@ -0,0 +1,170 @@
+import os
+import copy
+import numpy as np
+
+import gym
+from gym import error, spaces
+from gym.utils import seeding
+
+try:
+    import mujoco_py
+except ImportError as e:
+    raise error.DependencyNotInstalled("{}. (HINT: you need to install mujoco_py, and also perform the setup instructions here: https://github.com/openai/mujoco-py/.)".format(e))
+
+DEFAULT_SIZE = 500
+
+class RobotEnv(gym.GoalEnv):
+    def __init__(self, model_path, initial_qpos, n_actions, n_substeps):
+        if model_path.startswith('/'):
+            fullpath = model_path
+        else:
+            fullpath = os.path.join(os.path.dirname(__file__), 'assets', model_path)
+        if not os.path.exists(fullpath):
+            raise IOError('File {} does not exist'.format(fullpath))
+
+        model = mujoco_py.load_model_from_path(fullpath)
+        self.sim = mujoco_py.MjSim(model, nsubsteps=n_substeps)
+        self.viewer = None
+        self._viewers = {}
+
+        self.metadata = {
+            'render.modes': ['human', 'rgb_array'],
+            'video.frames_per_second': int(np.round(1.0 / self.dt))
+        }
+
+        self.seed()
+        self._env_setup(initial_qpos=initial_qpos)
+        self.initial_state = copy.deepcopy(self.sim.get_state())
+
+        self.goal = self._sample_goal()
+        obs = self._get_obs()
+        self.action_space = spaces.Box(-1., 1., shape=(n_actions,), dtype='float32')
+        self.observation_space = spaces.Dict(dict(
+            desired_goal=spaces.Box(-np.inf, np.inf, shape=obs['achieved_goal'].shape, dtype='float32'),
+            achieved_goal=spaces.Box(-np.inf, np.inf, shape=obs['achieved_goal'].shape, dtype='float32'),
+            observation=spaces.Box(-np.inf, np.inf, shape=obs['observation'].shape, dtype='float32'),
+        ))
+
+    @property
+    def dt(self):
+        return self.sim.model.opt.timestep * self.sim.nsubsteps
+
+    # Env methods
+    # ----------------------------
+
+    def seed(self, seed=None):
+        self.np_random, seed = seeding.np_random(seed)
+        return [seed]
+
+    def step(self, action):
+        action = np.clip(action, self.action_space.low, self.action_space.high)
+        self._set_action(action)
+        self.sim.step()
+        self._step_callback()
+        obs = self._get_obs()
+
+        done = False
+        info = {
+            'is_success': self._is_success(obs['achieved_goal'], self.goal),
+        }
+        reward = self.compute_reward(obs['achieved_goal'], self.goal, info)
+        return obs, reward, done, info
+
+    def reset(self):
+        # Attempt to reset the simulator. Since we randomize initial conditions, it
+        # is possible to get into a state with numerical issues (e.g. due to penetration or
+        # Gimbel lock) or we may not achieve an initial condition (e.g. an object is within the hand).
+        # In this case, we just keep randomizing until we eventually achieve a valid initial
+        # configuration.
+        super(RobotEnv, self).reset()
+        did_reset_sim = False
+        while not did_reset_sim:
+            did_reset_sim = self._reset_sim()
+        self.goal = self._sample_goal().copy()
+        obs = self._get_obs()
+        return obs
+
+    def close(self):
+        if self.viewer is not None:
+            # self.viewer.finish()
+            self.viewer = None
+            self._viewers = {}
+
+    def render(self, mode='human', width=DEFAULT_SIZE, height=DEFAULT_SIZE):
+        self._render_callback()
+        if mode == 'rgb_array':
+            self._get_viewer(mode).render(width, height)
+            # window size used for old mujoco-py:
+            data = self._get_viewer(mode).read_pixels(width, height, depth=False)
+            # original image is upside-down, so flip it
+            return data[::-1, :, :]
+        elif mode == 'human':
+            self._get_viewer(mode).render()
+
+    def _get_viewer(self, mode):
+        self.viewer = self._viewers.get(mode)
+        if self.viewer is None:
+            if mode == 'human':
+                self.viewer = mujoco_py.MjViewer(self.sim)
+            elif mode == 'rgb_array':
+                self.viewer = mujoco_py.MjRenderContextOffscreen(self.sim, device_id=-1)
+            self._viewer_setup()
+            self._viewers[mode] = self.viewer
+        return self.viewer
+
+    # Extension methods
+    # ----------------------------
+
+    def _reset_sim(self):
+        """Resets a simulation and indicates whether or not it was successful.
+        If a reset was unsuccessful (e.g. if a randomized state caused an error in the
+        simulation), this method should indicate such a failure by returning False.
+        In such a case, this method will be called again to attempt a the reset again.
+        """
+        self.sim.set_state(self.initial_state)
+        self.sim.forward()
+        return True
+
+    def _get_obs(self):
+        """Returns the observation.
+        """
+        raise NotImplementedError()
+
+    def _set_action(self, action):
+        """Applies the given action to the simulation.
+        """
+        raise NotImplementedError()
+
+    def _is_success(self, achieved_goal, desired_goal):
+        """Indicates whether or not the achieved goal successfully achieved the desired goal.
+        """
+        raise NotImplementedError()
+
+    def _sample_goal(self):
+        """Samples a new goal and returns it.
+        """
+        raise NotImplementedError()
+
+    def _env_setup(self, initial_qpos):
+        """Initial configuration of the environment. Can be used to configure initial state
+        and extract information from the simulation.
+        """
+        pass
+
+    def _viewer_setup(self):
+        """Initial configuration of the viewer. Can be used to set the camera position,
+        for example.
+        """
+        pass
+
+    def _render_callback(self):
+        """A custom callback that is called before rendering. Can be used
+        to implement custom visualizations.
+        """
+        pass
+
+    def _step_callback(self):
+        """A custom callback that is called after stepping the simulation. Can be used
+        to enforce additional constraints on the simulation state.
+        """
+        pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/rotations.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/rotations.py
new file mode 100644
index 0000000..4aafb64
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/rotations.py
@@ -0,0 +1,369 @@
+# Copyright (c) 2009-2017, Matthew Brett and Christoph Gohlke
+#    All rights reserved.
+#
+#    Redistribution and use in source and binary forms, with or without
+#    modification, are permitted provided that the following conditions are
+#    met:
+#
+#    1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+#
+#    2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+#    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+#    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+#    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+#    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+#    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+#    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+#    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+#    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+#    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+#    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+# Many methods borrow heavily or entirely from transforms3d:
+# https://github.com/matthew-brett/transforms3d
+# They have mostly been modified to support batched operations.
+
+import numpy as np
+import itertools
+
+'''
+Rotations
+=========
+
+Note: these have caused many subtle bugs in the past.
+Be careful while updating these methods and while using them in clever ways.
+
+See MuJoCo documentation here: http://mujoco.org/book/modeling.html#COrientation
+
+Conventions
+-----------
+    - All functions accept batches as well as individual rotations
+    - All rotation conventions match respective MuJoCo defaults
+    - All angles are in radians
+    - Matricies follow LR convention
+    - Euler Angles are all relative with 'xyz' axes ordering
+    - See specific representation for more information
+
+Representations
+---------------
+
+Euler
+    There are many euler angle frames -- here we will strive to use the default
+        in MuJoCo, which is eulerseq='xyz'.
+    This frame is a relative rotating frame, about x, y, and z axes in order.
+        Relative rotating means that after we rotate about x, then we use the
+        new (rotated) y, and the same for z.
+
+Quaternions
+    These are defined in terms of rotation (angle) about a unit vector (x, y, z)
+    We use the following <q0, q1, q2, q3> convention:
+            q0 = cos(angle / 2)
+            q1 = sin(angle / 2) * x
+            q2 = sin(angle / 2) * y
+            q3 = sin(angle / 2) * z
+        This is also sometimes called qw, qx, qy, qz.
+    Note that quaternions are ambiguous, because we can represent a rotation by
+        angle about vector <x, y, z> and -angle about vector <-x, -y, -z>.
+        To choose between these, we pick "first nonzero positive", where we
+        make the first nonzero element of the quaternion positive.
+    This can result in mismatches if you're converting an quaternion that is not
+        "first nonzero positive" to a different representation and back.
+
+Axis Angle
+    (Not currently implemented)
+    These are very straightforward.  Rotation is angle about a unit vector.
+
+XY Axes
+    (Not currently implemented)
+    We are given x axis and y axis, and z axis is cross product of x and y.
+
+Z Axis
+    This is NOT RECOMMENDED.  Defines a unit vector for the Z axis,
+        but rotation about this axis is not well defined.
+    Instead pick a fixed reference direction for another axis (e.g. X)
+        and calculate the other (e.g. Y = Z cross-product X),
+        then use XY Axes rotation instead.
+
+SO3
+    (Not currently implemented)
+    While not supported by MuJoCo, this representation has a lot of nice features.
+    We expect to add support for these in the future.
+
+TODO / Missing
+--------------
+    - Rotation integration or derivatives (e.g. velocity conversions)
+    - More representations (SO3, etc)
+    - Random sampling (e.g. sample uniform random rotation)
+    - Performance benchmarks/measurements
+    - (Maybe) define everything as to/from matricies, for simplicity
+'''
+
+# For testing whether a number is close to zero
+_FLOAT_EPS = np.finfo(np.float64).eps
+_EPS4 = _FLOAT_EPS * 4.0
+
+
+def euler2mat(euler):
+    """ Convert Euler Angles to Rotation Matrix.  See rotation.py for notes """
+    euler = np.asarray(euler, dtype=np.float64)
+    assert euler.shape[-1] == 3, "Invalid shaped euler {}".format(euler)
+
+    ai, aj, ak = -euler[..., 2], -euler[..., 1], -euler[..., 0]
+    si, sj, sk = np.sin(ai), np.sin(aj), np.sin(ak)
+    ci, cj, ck = np.cos(ai), np.cos(aj), np.cos(ak)
+    cc, cs = ci * ck, ci * sk
+    sc, ss = si * ck, si * sk
+
+    mat = np.empty(euler.shape[:-1] + (3, 3), dtype=np.float64)
+    mat[..., 2, 2] = cj * ck
+    mat[..., 2, 1] = sj * sc - cs
+    mat[..., 2, 0] = sj * cc + ss
+    mat[..., 1, 2] = cj * sk
+    mat[..., 1, 1] = sj * ss + cc
+    mat[..., 1, 0] = sj * cs - sc
+    mat[..., 0, 2] = -sj
+    mat[..., 0, 1] = cj * si
+    mat[..., 0, 0] = cj * ci
+    return mat
+
+
+def euler2quat(euler):
+    """ Convert Euler Angles to Quaternions.  See rotation.py for notes """
+    euler = np.asarray(euler, dtype=np.float64)
+    assert euler.shape[-1] == 3, "Invalid shape euler {}".format(euler)
+
+    ai, aj, ak = euler[..., 2] / 2, -euler[..., 1] / 2, euler[..., 0] / 2
+    si, sj, sk = np.sin(ai), np.sin(aj), np.sin(ak)
+    ci, cj, ck = np.cos(ai), np.cos(aj), np.cos(ak)
+    cc, cs = ci * ck, ci * sk
+    sc, ss = si * ck, si * sk
+
+    quat = np.empty(euler.shape[:-1] + (4,), dtype=np.float64)
+    quat[..., 0] = cj * cc + sj * ss
+    quat[..., 3] = cj * sc - sj * cs
+    quat[..., 2] = -(cj * ss + sj * cc)
+    quat[..., 1] = cj * cs - sj * sc
+    return quat
+
+
+def mat2euler(mat):
+    """ Convert Rotation Matrix to Euler Angles.  See rotation.py for notes """
+    mat = np.asarray(mat, dtype=np.float64)
+    assert mat.shape[-2:] == (3, 3), "Invalid shape matrix {}".format(mat)
+
+    cy = np.sqrt(mat[..., 2, 2] * mat[..., 2, 2] + mat[..., 1, 2] * mat[..., 1, 2])
+    condition = cy > _EPS4
+    euler = np.empty(mat.shape[:-1], dtype=np.float64)
+    euler[..., 2] = np.where(condition,
+                             -np.arctan2(mat[..., 0, 1], mat[..., 0, 0]),
+                             -np.arctan2(-mat[..., 1, 0], mat[..., 1, 1]))
+    euler[..., 1] = np.where(condition,
+                             -np.arctan2(-mat[..., 0, 2], cy),
+                             -np.arctan2(-mat[..., 0, 2], cy))
+    euler[..., 0] = np.where(condition,
+                             -np.arctan2(mat[..., 1, 2], mat[..., 2, 2]),
+                             0.0)
+    return euler
+
+
+def mat2quat(mat):
+    """ Convert Rotation Matrix to Quaternion.  See rotation.py for notes """
+    mat = np.asarray(mat, dtype=np.float64)
+    assert mat.shape[-2:] == (3, 3), "Invalid shape matrix {}".format(mat)
+
+    Qxx, Qyx, Qzx = mat[..., 0, 0], mat[..., 0, 1], mat[..., 0, 2]
+    Qxy, Qyy, Qzy = mat[..., 1, 0], mat[..., 1, 1], mat[..., 1, 2]
+    Qxz, Qyz, Qzz = mat[..., 2, 0], mat[..., 2, 1], mat[..., 2, 2]
+    # Fill only lower half of symmetric matrix
+    K = np.zeros(mat.shape[:-2] + (4, 4), dtype=np.float64)
+    K[..., 0, 0] = Qxx - Qyy - Qzz
+    K[..., 1, 0] = Qyx + Qxy
+    K[..., 1, 1] = Qyy - Qxx - Qzz
+    K[..., 2, 0] = Qzx + Qxz
+    K[..., 2, 1] = Qzy + Qyz
+    K[..., 2, 2] = Qzz - Qxx - Qyy
+    K[..., 3, 0] = Qyz - Qzy
+    K[..., 3, 1] = Qzx - Qxz
+    K[..., 3, 2] = Qxy - Qyx
+    K[..., 3, 3] = Qxx + Qyy + Qzz
+    K /= 3.0
+    # TODO: vectorize this -- probably could be made faster
+    q = np.empty(K.shape[:-2] + (4,))
+    it = np.nditer(q[..., 0], flags=['multi_index'])
+    while not it.finished:
+        # Use Hermitian eigenvectors, values for speed
+        vals, vecs = np.linalg.eigh(K[it.multi_index])
+        # Select largest eigenvector, reorder to w,x,y,z quaternion
+        q[it.multi_index] = vecs[[3, 0, 1, 2], np.argmax(vals)]
+        # Prefer quaternion with positive w
+        # (q * -1 corresponds to same rotation as q)
+        if q[it.multi_index][0] < 0:
+            q[it.multi_index] *= -1
+        it.iternext()
+    return q
+
+
+def quat2euler(quat):
+    """ Convert Quaternion to Euler Angles.  See rotation.py for notes """
+    return mat2euler(quat2mat(quat))
+
+
+def subtract_euler(e1, e2):
+    assert e1.shape == e2.shape
+    assert e1.shape[-1] == 3
+    q1 = euler2quat(e1)
+    q2 = euler2quat(e2)
+    q_diff = quat_mul(q1, quat_conjugate(q2))
+    return quat2euler(q_diff)
+
+
+def quat2mat(quat):
+    """ Convert Quaternion to Euler Angles.  See rotation.py for notes """
+    quat = np.asarray(quat, dtype=np.float64)
+    assert quat.shape[-1] == 4, "Invalid shape quat {}".format(quat)
+
+    w, x, y, z = quat[..., 0], quat[..., 1], quat[..., 2], quat[..., 3]
+    Nq = np.sum(quat * quat, axis=-1)
+    s = 2.0 / Nq
+    X, Y, Z = x * s, y * s, z * s
+    wX, wY, wZ = w * X, w * Y, w * Z
+    xX, xY, xZ = x * X, x * Y, x * Z
+    yY, yZ, zZ = y * Y, y * Z, z * Z
+
+    mat = np.empty(quat.shape[:-1] + (3, 3), dtype=np.float64)
+    mat[..., 0, 0] = 1.0 - (yY + zZ)
+    mat[..., 0, 1] = xY - wZ
+    mat[..., 0, 2] = xZ + wY
+    mat[..., 1, 0] = xY + wZ
+    mat[..., 1, 1] = 1.0 - (xX + zZ)
+    mat[..., 1, 2] = yZ - wX
+    mat[..., 2, 0] = xZ - wY
+    mat[..., 2, 1] = yZ + wX
+    mat[..., 2, 2] = 1.0 - (xX + yY)
+    return np.where((Nq > _FLOAT_EPS)[..., np.newaxis, np.newaxis], mat, np.eye(3))
+
+def quat_conjugate(q):
+    inv_q = -q
+    inv_q[..., 0] *= -1
+    return inv_q
+
+def quat_mul(q0, q1):
+    assert q0.shape == q1.shape
+    assert q0.shape[-1] == 4
+    assert q1.shape[-1] == 4
+
+    w0 = q0[..., 0]
+    x0 = q0[..., 1]
+    y0 = q0[..., 2]
+    z0 = q0[..., 3]
+
+    w1 = q1[..., 0]
+    x1 = q1[..., 1]
+    y1 = q1[..., 2]
+    z1 = q1[..., 3]
+
+    w = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1
+    x = w0 * x1 + x0 * w1 + y0 * z1 - z0 * y1
+    y = w0 * y1 + y0 * w1 + z0 * x1 - x0 * z1
+    z = w0 * z1 + z0 * w1 + x0 * y1 - y0 * x1
+    q = np.array([w, x, y, z])
+    if q.ndim == 2:
+        q = q.swapaxes(0, 1)
+    assert q.shape == q0.shape
+    return q
+
+def quat_rot_vec(q, v0):
+    q_v0 = np.array([0, v0[0], v0[1], v0[2]])
+    q_v = quat_mul(q, quat_mul(q_v0, quat_conjugate(q)))
+    v = q_v[1:]
+    return v
+
+def quat_identity():
+    return np.array([1, 0, 0, 0])
+
+def quat2axisangle(quat):
+    theta = 0;
+    axis = np.array([0, 0, 1]);
+    sin_theta = np.linalg.norm(quat[1:])
+
+    if (sin_theta > 0.0001):
+        theta = 2 * np.arcsin(sin_theta)
+        theta *= 1 if quat[0] >= 0 else -1
+        axis = quat[1:] / sin_theta
+
+    return axis, theta
+
+def euler2point_euler(euler):
+    _euler = euler.copy()
+    if len(_euler.shape) < 2:
+        _euler = np.expand_dims(_euler,0)
+    assert(_euler.shape[1] == 3)
+    _euler_sin = np.sin(_euler)
+    _euler_cos = np.cos(_euler)
+    return np.concatenate([_euler_sin, _euler_cos], axis=-1)
+
+def point_euler2euler(euler):
+    _euler = euler.copy()
+    if len(_euler.shape) < 2:
+        _euler = np.expand_dims(_euler,0)
+    assert(_euler.shape[1] == 6)
+    angle = np.arctan(_euler[..., :3] / _euler[..., 3:])
+    angle[_euler[..., 3:] < 0] += np.pi
+    return angle
+
+def quat2point_quat(quat):
+    # Should be in qw, qx, qy, qz
+    _quat = quat.copy()
+    if len(_quat.shape) < 2:
+        _quat = np.expand_dims(_quat, 0)
+    assert(_quat.shape[1] == 4)
+    angle = np.arccos(_quat[:,[0]]) * 2
+    xyz = _quat[:, 1:]
+    xyz[np.squeeze(np.abs(np.sin(angle/2))) >= 1e-5] = (xyz / np.sin(angle / 2))[np.squeeze(np.abs(np.sin(angle/2))) >= 1e-5]
+    return np.concatenate([np.sin(angle),np.cos(angle), xyz], axis=-1)
+
+def point_quat2quat(quat):
+    _quat = quat.copy()
+    if len(_quat.shape) < 2:
+        _quat = np.expand_dims(_quat, 0)
+    assert(_quat.shape[1] == 5)
+    angle = np.arctan(_quat[:,[0]] / _quat[:,[1]])
+    qw = np.cos(angle / 2)
+
+    qxyz = _quat[:, 2:]
+    qxyz[np.squeeze(np.abs(np.sin(angle/2))) >= 1e-5] = (qxyz * np.sin(angle/2))[np.squeeze(np.abs(np.sin(angle/2))) >= 1e-5]
+    return np.concatenate([qw, qxyz], axis=-1)
+
+def normalize_angles(angles):
+    '''Puts angles in [-pi, pi] range.'''
+    angles = angles.copy()
+    if angles.size > 0:
+        angles = (angles + np.pi) % (2 * np.pi) - np.pi
+        assert -np.pi-1e-6 <= angles.min() and angles.max() <= np.pi+1e-6
+    return angles
+
+def round_to_straight_angles(angles):
+    '''Returns closest angle modulo 90 degrees '''
+    angles = np.round(angles / (np.pi / 2)) * (np.pi / 2)
+    return normalize_angles(angles)
+
+def get_parallel_rotations():
+    mult90 = [0, np.pi/2, -np.pi/2, np.pi]
+    parallel_rotations = []
+    for euler in itertools.product(mult90, repeat=3):
+        canonical = mat2euler(euler2mat(euler))
+        canonical = np.round(canonical / (np.pi / 2))
+        if canonical[0] == -2:
+            canonical[0] = 2
+        if canonical[2] == -2:
+            canonical[2] = 2
+        canonical *= np.pi / 2
+        if all([(canonical != rot).any() for rot in parallel_rotations]):
+            parallel_rotations += [canonical]
+    assert len(parallel_rotations) == 24
+    return parallel_rotations
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/robotics/utils.py b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/utils.py
new file mode 100644
index 0000000..a73e5f6
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/robotics/utils.py
@@ -0,0 +1,96 @@
+import numpy as np
+
+from gym import error
+try:
+    import mujoco_py
+except ImportError as e:
+    raise error.DependencyNotInstalled("{}. (HINT: you need to install mujoco_py, and also perform the setup instructions here: https://github.com/openai/mujoco-py/.)".format(e))
+
+
+def robot_get_obs(sim):
+    """Returns all joint positions and velocities associated with
+    a robot.
+    """
+    if sim.data.qpos is not None and sim.model.joint_names:
+        names = [n for n in sim.model.joint_names if n.startswith('robot')]
+        return (
+            np.array([sim.data.get_joint_qpos(name) for name in names]),
+            np.array([sim.data.get_joint_qvel(name) for name in names]),
+        )
+    return np.zeros(0), np.zeros(0)
+
+
+def ctrl_set_action(sim, action):
+    """For torque actuators it copies the action into mujoco ctrl field.
+    For position actuators it sets the target relative to the current qpos.
+    """
+    if sim.model.nmocap > 0:
+        _, action = np.split(action, (sim.model.nmocap * 7, ))
+    if sim.data.ctrl is not None:
+        for i in range(action.shape[0]):
+            if sim.model.actuator_biastype[i] == 0:
+                sim.data.ctrl[i] = action[i]
+            else:
+                idx = sim.model.jnt_qposadr[sim.model.actuator_trnid[i, 0]]
+                sim.data.ctrl[i] = sim.data.qpos[idx] + action[i]
+
+
+def mocap_set_action(sim, action):
+    """The action controls the robot using mocaps. Specifically, bodies
+    on the robot (for example the gripper wrist) is controlled with
+    mocap bodies. In this case the action is the desired difference
+    in position and orientation (quaternion), in world coordinates,
+    of the of the target body. The mocap is positioned relative to
+    the target body according to the delta, and the MuJoCo equality
+    constraint optimizer tries to center the welded body on the mocap.
+    """
+    if sim.model.nmocap > 0:
+        action, _ = np.split(action, (sim.model.nmocap * 7, ))
+        action = action.reshape(sim.model.nmocap, 7)
+
+        pos_delta = action[:, :3]
+        quat_delta = action[:, 3:]
+
+        reset_mocap2body_xpos(sim)
+        sim.data.mocap_pos[:] = sim.data.mocap_pos + pos_delta
+        sim.data.mocap_quat[:] = sim.data.mocap_quat + quat_delta
+
+
+def reset_mocap_welds(sim):
+    """Resets the mocap welds that we use for actuation.
+    """
+    if sim.model.nmocap > 0 and sim.model.eq_data is not None:
+        for i in range(sim.model.eq_data.shape[0]):
+            if sim.model.eq_type[i] == mujoco_py.const.EQ_WELD:
+                sim.model.eq_data[i, :] = np.array(
+                    [0., 0., 0., 1., 0., 0., 0.])
+    sim.forward()
+
+
+def reset_mocap2body_xpos(sim):
+    """Resets the position and orientation of the mocap bodies to the same
+    values as the bodies they're welded to.
+    """
+
+    if (sim.model.eq_type is None or
+        sim.model.eq_obj1id is None or
+        sim.model.eq_obj2id is None):
+        return
+    for eq_type, obj1_id, obj2_id in zip(sim.model.eq_type,
+                                         sim.model.eq_obj1id,
+                                         sim.model.eq_obj2id):
+        if eq_type != mujoco_py.const.EQ_WELD:
+            continue
+
+        mocap_id = sim.model.body_mocapid[obj1_id]
+        if mocap_id != -1:
+            # obj1 is the mocap, obj2 is the welded body
+            body_idx = obj2_id
+        else:
+            # obj2 is the mocap, obj1 is the welded body
+            mocap_id = sim.model.body_mocapid[obj2_id]
+            body_idx = obj1_id
+
+        assert (mocap_id != -1)
+        sim.data.mocap_pos[mocap_id][:] = sim.data.body_xpos[body_idx]
+        sim.data.mocap_quat[mocap_id][:] = sim.data.body_xquat[body_idx]
diff --git a/experiments05/ant_umaze_1234/src/slbo/envs/virtual_env.py b/experiments05/ant_umaze_1234/src/slbo/envs/virtual_env.py
new file mode 100644
index 0000000..2d0cc76
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/envs/virtual_env.py
@@ -0,0 +1,94 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from gym.spaces import Box
+from slbo.dynamics_model import DynamicsModel
+from slbo.random_net import RandomNet
+from slbo.envs import BaseBatchedEnv, BaseModelBasedEnv
+from slbo.utils.pc_utils import compute_cov_pi
+
+
+class VirtualEnv(BaseBatchedEnv):
+    _states: np.ndarray
+
+    def __init__(self, model: DynamicsModel, env: BaseModelBasedEnv, random_net:RandomNet,  n_envs: int, 
+                    feature_size: int, bonus_scale: float, lamb: float, opt_model=False):
+        super().__init__()
+        self.n_envs = n_envs
+        self.observation_space = env.observation_space  # ???
+
+        dim_state = env.observation_space.shape[0]
+        dim_action = env.action_space.shape[0]
+        if opt_model:
+            self.action_space = Box(low=np.r_[env.action_space.low, np.zeros(dim_state) - 1.],
+                                    high=np.r_[env.action_space.high, np.zeros(dim_state) + 1.],
+                                    dtype=np.float32)
+        else:
+            self.action_space = env.action_space
+
+        self._opt_model = opt_model
+        self._model = model
+        self._env = env
+        self._random_net = random_net
+
+        self._states = np.zeros((self.n_envs, dim_state), dtype=np.float32)
+
+        self.feature_size = feature_size
+        self.cov_pis = None
+        self.inv_cov = None
+        self.bonus_scale = bonus_scale
+        self.lamb = lamb
+        self.pre = True
+
+    def _scale_action(self, actions):
+        lo, hi = self.action_space.low, self.action_space.high
+        return lo + (actions + 1.) * 0.5 * (hi - lo)
+
+    def step(self, actions):
+        if self._opt_model:
+            actions = actions[..., :self._env.action_space.shape[0]]
+
+        next_states = self._model.eval('next_states', states=self._states, actions=actions)
+        features = self._random_net.eval('features', states=self._states, actions=actions)
+        #print(features.shape)
+        rewards, dones = self._env.mb_step(self._states, self._scale_action(actions), next_states)
+
+        if not self.pre:
+            bonus = self.compute_bonus(features)
+            rewards = rewards + self.bonus_scale * bonus
+
+        self._states = next_states
+        return self._states.copy(), rewards, dones, [{} for _ in range(self.n_envs)]
+
+    def reset(self):
+        return self.partial_reset(range(self.n_envs))
+
+    def partial_reset(self, indices):
+        initial_states = np.array([self._env.reset() for _ in indices])
+
+        self._states = self._states.copy()
+        self._states[indices] = initial_states
+
+        return initial_states.copy()
+
+    def set_state(self, states):
+        self._states = states.copy()
+
+    def render(self, mode='human'):
+        pass
+
+    def update_cov(self, states, actions):
+        features = self._random_net.eval('features', states=states, actions=actions)
+
+        if self.pre:
+            self.cov_pis = compute_cov_pi(features)
+            self.pre = False
+        else:
+            self.cov_pis = self.cov_pis + compute_cov_pi(features)
+        
+        cur_cov = self.lamb * np.identity(self.feature_size) + self.cov_pis
+        self.inv_cov = np.linalg.inv(cur_cov)
+
+
+    def compute_bonus(self,features):
+        bonus = np.sqrt(np.sum(np.dot(features, self.inv_cov)*features,1))
+        return bonus
diff --git a/experiments05/ant_umaze_1234/src/slbo/loss/__init__.py b/experiments05/ant_umaze_1234/src/slbo/loss/__init__.py
new file mode 100644
index 0000000..5c7f19c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/loss/__init__.py
@@ -0,0 +1 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
diff --git a/experiments05/ant_umaze_1234/src/slbo/loss/multi_step_loss.py b/experiments05/ant_umaze_1234/src/slbo/loss/multi_step_loss.py
new file mode 100644
index 0000000..a2aadb7
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/loss/multi_step_loss.py
@@ -0,0 +1,65 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+import numpy as np
+import lunzi.nn as nn
+from lunzi import Tensor
+from slbo.utils.normalizer import Normalizers
+
+
+class MultiStepLoss(nn.Module):
+    op_train: Tensor
+    op_grad_norm: Tensor
+    _step: int
+    _criterion: nn.Module
+    _normalizers: Normalizers
+    _model: nn.Module
+
+    def __init__(self, model: nn.Module, normalizers: Normalizers, dim_state: int, dim_action: int,
+                 criterion: nn.Module, step=4):
+        super().__init__()
+        self._step = step
+        self._criterion = criterion
+        self._model = model
+        self._normalizers = normalizers
+        with self.scope:
+            self.op_states = tf.placeholder(tf.float32, shape=[step, None, dim_state])
+            self.op_actions = tf.placeholder(tf.float32, shape=[step, None, dim_action])
+            self.op_masks = tf.placeholder(tf.float32, shape=[step, None])
+            self.op_next_states_ = tf.placeholder(tf.float32, shape=[step, None, dim_state])
+
+        self.op_loss = self(self.op_states, self.op_actions, self.op_next_states_, self.op_masks)
+
+    def forward(self, states: Tensor, actions: Tensor, next_states_: Tensor, masks: Tensor):
+        """
+            All inputs have shape [num_steps, batch_size, xxx]
+        """
+
+        cur_states = states[0]
+        loss = []
+        for i in range(self._step):
+            next_states = self._model(cur_states, actions[i])
+            diffs = next_states - cur_states - next_states_[i] + states[i]
+            weighted_diffs = diffs / self._normalizers.diff.op_std.maximum(1e-6)
+            loss.append(self._criterion(weighted_diffs, 0, cur_states))
+
+            if i < self._step - 1:
+                cur_states = states[i + 1] + masks[i].expand_dims(-1) * (next_states - states[i + 1])
+
+        return tf.add_n(loss) / self._step
+
+    @nn.make_method(fetch='loss')
+    def get_loss(self, states, next_states_, actions, masks): pass
+
+    def build_backward(self, lr: float, weight_decay: float, max_grad_norm=2.):
+        loss = self.op_loss.reduce_mean(name='Loss')
+
+        optimizer = tf.train.AdamOptimizer(lr)
+        params = self._model.parameters()
+        regularization = weight_decay * tf.add_n([tf.nn.l2_loss(t) for t in params], name='regularization')
+
+        grads_and_vars = optimizer.compute_gradients(loss + regularization, var_list=params)
+        print([var.name for grad, var in grads_and_vars])
+        clip_grads, op_grad_norm = tf.clip_by_global_norm([grad for grad, _ in grads_and_vars], max_grad_norm)
+        clip_grads_and_vars = [(grad, var) for grad, (_, var) in zip(clip_grads, grads_and_vars)]
+        self.op_train = optimizer.apply_gradients(clip_grads_and_vars)
+        self.op_grad_norm = op_grad_norm
diff --git a/experiments05/ant_umaze_1234/src/slbo/partial_envs.py b/experiments05/ant_umaze_1234/src/slbo/partial_envs.py
new file mode 100644
index 0000000..b9aee20
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/partial_envs.py
@@ -0,0 +1,95 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+
+import gym
+import slbo.envs.mujoco_maze
+
+from gym.wrappers import FlattenObservation
+
+
+from slbo.envs.bm_envs.gym.half_cheetah import HalfCheetahEnv
+from slbo.envs.bm_envs.gym.walker2d import Walker2dEnv
+# from slbo.envs.mujoco.humanoid_env import HumanoidEnv
+from slbo.envs.bm_envs.gym.ant import AntEnv
+from slbo.envs.bm_envs.gym.hopper import HopperEnv
+from slbo.envs.bm_envs.gym.swimmer import SwimmerEnv
+from slbo.envs.bm_envs.gym.reacher import ReacherEnv
+from slbo.envs.bm_envs.gym.pendulum import PendulumEnv
+from slbo.envs.bm_envs.gym.inverted_pendulum import InvertedPendulumEnv
+from slbo.envs.bm_envs.gym.acrobot import AcrobotEnv
+from slbo.envs.bm_envs.gym.cartpole import CartPoleEnv
+from slbo.envs.bm_envs.gym.mountain_car import Continuous_MountainCarEnv
+
+from slbo.envs.bm_envs.gym import gym_fswimmer
+from slbo.envs.bm_envs.gym import gym_fwalker2d
+from slbo.envs.bm_envs.gym import gym_fhopper
+from slbo.envs.bm_envs.gym import gym_fant
+
+from slbo.envs.bm_envs.gym import gym_cheetahA01
+from slbo.envs.bm_envs.gym import gym_cheetahA003
+from slbo.envs.bm_envs.gym import gym_cheetahO01
+from slbo.envs.bm_envs.gym import gym_cheetahO001
+from slbo.envs.bm_envs.gym import gym_pendulumO01
+from slbo.envs.bm_envs.gym import gym_pendulumO001
+from slbo.envs.bm_envs.gym import gym_cartpoleO01
+from slbo.envs.bm_envs.gym import gym_cartpoleO001
+
+from slbo.envs.bm_envs.gym import gym_humanoid
+from slbo.envs.bm_envs.gym import gym_nostopslimhumanoid
+from slbo.envs.bm_envs.gym import gym_slimhumanoid
+from slbo.envs.robotics.fetch.push import FetchPushEnv
+from slbo.envs.robotics.hand.reach import HandReachEnv
+from slbo.envs.robotics.hand.manipulate import HandEggEnv
+
+
+def make_env(id: str):
+    if "Point" in id or "Ant" in id:
+        env = gym.make(id)
+        env.seed(np.random.randint(2**60))
+    else:
+        envs = {
+            'HandEgg': HandEggEnv,
+            'FetchPush': FetchPushEnv,
+            'HandReach': HandReachEnv,
+            'HalfCheetah': HalfCheetahEnv,
+            'Walker2D': Walker2dEnv,
+            'Ant': AntEnv,
+            'Hopper': HopperEnv,
+            'Swimmer': SwimmerEnv,
+            'FixedSwimmer': gym_fswimmer.fixedSwimmerEnv,
+            'FixedWalker': gym_fwalker2d.Walker2dEnv,
+            'FixedHopper': gym_fhopper.HopperEnv,
+            'FixedAnt': gym_fant.AntEnv,
+            'Reacher': ReacherEnv,
+            'Pendulum': PendulumEnv,
+            'InvertedPendulum': InvertedPendulumEnv,
+            'Acrobot': AcrobotEnv,
+            'CartPole': CartPoleEnv,
+            'MountainCar': Continuous_MountainCarEnv,
+
+            'HalfCheetahO01': gym_cheetahO01.HalfCheetahEnv,
+            'HalfCheetahO001': gym_cheetahO001.HalfCheetahEnv,
+            'HalfCheetahA01': gym_cheetahA01.HalfCheetahEnv,
+            'HalfCheetahA003': gym_cheetahA003.HalfCheetahEnv,
+
+            'PendulumO01': gym_pendulumO01.PendulumEnv,
+            'PendulumO001': gym_pendulumO001.PendulumEnv,
+
+            'CartPoleO01': gym_cartpoleO01.CartPoleEnv,
+            'CartPoleO001': gym_cartpoleO001.CartPoleEnv,
+
+            'gym_humanoid': gym_humanoid.HumanoidEnv,
+            'gym_slimhumanoid': gym_slimhumanoid.HumanoidEnv,
+            'gym_nostopslimhumanoid': gym_nostopslimhumanoid.HumanoidEnv,
+        }
+        
+        env = envs[id]()
+        if not hasattr(env, 'reward_range'):
+            env.reward_range = (-np.inf, np.inf)
+        if not hasattr(env, 'metadata'):
+            env.metadata = {}
+        env.seed(np.random.randint(2**60))
+        if 'Fetch' in id or 'Hand' in id: 
+            env = FlattenObservation(env)
+
+    return env
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/slbo/policies/__init__.py b/experiments05/ant_umaze_1234/src/slbo/policies/__init__.py
new file mode 100644
index 0000000..3ffa40d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/policies/__init__.py
@@ -0,0 +1,13 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import abc
+from typing import Union
+import lunzi.nn as nn
+
+
+class BasePolicy(abc.ABC):
+    @abc.abstractmethod
+    def get_actions(self, states):
+        pass
+
+
+BaseNNPolicy = Union[BasePolicy, nn.Module]  # should be Intersection, see PEP544
diff --git a/experiments05/ant_umaze_1234/src/slbo/policies/gaussian_mlp_policy.py b/experiments05/ant_umaze_1234/src/slbo/policies/gaussian_mlp_policy.py
new file mode 100644
index 0000000..c6bcb27
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/policies/gaussian_mlp_policy.py
@@ -0,0 +1,69 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import List
+import tensorflow as tf
+import numpy as np
+from lunzi import Tensor
+from lunzi import nn
+from baselines.common.tf_util import normc_initializer
+from slbo.utils.truncated_normal import LimitedEntNormal
+from . import BasePolicy
+from slbo.utils.normalizer import GaussianNormalizer
+
+
+class GaussianMLPPolicy(nn.Module, BasePolicy):
+    op_states: Tensor
+
+    def __init__(self, dim_state: int, dim_action: int, hidden_sizes: List[int], normalizer: GaussianNormalizer,
+                 init_std=1.):
+        super().__init__()
+        self.dim_state = dim_state
+        self.dim_action = dim_action
+        self.hidden_sizes = hidden_sizes
+        self.init_std = init_std
+        self.normalizer = normalizer
+        with self.scope:
+            self.op_states = tf.placeholder(tf.float32, shape=[None, dim_state], name='states')
+            self.op_actions_ = tf.placeholder(tf.float32, shape=[None, dim_action], name='actions')
+
+            layers = []
+            # note that the placeholder has size 105.
+            all_sizes = [dim_state, *self.hidden_sizes]
+            for i, (in_features, out_features) in enumerate(zip(all_sizes[:-1], all_sizes[1:])):
+                layers.append(nn.Linear(in_features, out_features, weight_initializer=normc_initializer(1)))
+                layers.append(nn.Tanh())
+            layers.append(nn.Linear(all_sizes[-1], dim_action, weight_initializer=normc_initializer(0.01)))
+            self.net = nn.Sequential(*layers)
+
+            self.op_log_std = nn.Parameter(
+                tf.constant(np.log(self.init_std), shape=[self.dim_action], dtype=tf.float32), name='log_std')
+
+        self.distribution = self(self.op_states)
+        self.op_actions = self.distribution.sample()
+        self.op_actions_mean = self.distribution.mean()
+        self.op_actions_std = self.distribution.stddev()
+        self.op_nlls_ = -self.distribution.log_prob(self.op_actions_).reduce_sum(axis=1)
+
+        self.register_callable('[states] => [actions]', self.fast)
+
+    def forward(self, states):
+        states = self.normalizer(states)
+        actions_mean = self.net(states)
+        distribution = LimitedEntNormal(actions_mean, self.op_log_std.exp())
+
+        return distribution
+
+    @nn.make_method(fetch='actions')
+    def get_actions(self, states): pass
+
+    def fast(self, states, use_log_prob=False):
+        states = self.normalizer.fast(states)
+        actions_mean = self.net.fast(states)
+        noise = np.random.randn(*actions_mean.shape)
+        actions = actions_mean + noise * np.exp(self.op_log_std.numpy())
+        if use_log_prob:
+            log_prob = -noise**2 / 2 - np.log(2 * np.pi) / 2 - self.op_log_std.numpy()
+            return actions, log_prob.sum(axis=1)
+        return actions
+
+    def clone(self):
+        return GaussianMLPPolicy(self.dim_state, self.dim_action, self.hidden_sizes, self.normalizer, self.init_std)
diff --git a/experiments05/ant_umaze_1234/src/slbo/policies/uniform_policy.py b/experiments05/ant_umaze_1234/src/slbo/policies/uniform_policy.py
new file mode 100644
index 0000000..ca9f821
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/policies/uniform_policy.py
@@ -0,0 +1,11 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from . import BasePolicy
+
+
+class UniformPolicy(BasePolicy):
+    def __init__(self, dim_action):
+        self.dim_action = dim_action
+
+    def get_actions(self, states):
+        return np.random.uniform(-1., 1., states.shape[:-1] + (self.dim_action,))
diff --git a/experiments05/ant_umaze_1234/src/slbo/q_function/__init__.py b/experiments05/ant_umaze_1234/src/slbo/q_function/__init__.py
new file mode 100644
index 0000000..e8dfcba
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/q_function/__init__.py
@@ -0,0 +1,13 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import abc
+from typing import Union
+import lunzi.nn as nn
+
+
+class BaseQFunction(abc.ABC):
+    @abc.abstractmethod
+    def get_q(self, states, values):
+        pass
+
+
+BaseNNQFunction = Union[BaseQFunction, nn.Module]
diff --git a/experiments05/ant_umaze_1234/src/slbo/q_function/mlp_q_function.py b/experiments05/ant_umaze_1234/src/slbo/q_function/mlp_q_function.py
new file mode 100644
index 0000000..c8eed83
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/q_function/mlp_q_function.py
@@ -0,0 +1,22 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import List
+import tensorflow as tf
+from . import BaseQFunction
+import lunzi.nn as nn
+from slbo.utils.multi_layer_perceptron import MultiLayerPerceptron
+
+
+class MLPQFunction(MultiLayerPerceptron, BaseQFunction):
+    def __init__(self, dim_state: int, dim_action: int, hidden_states: List[int]):
+        super().__init__((dim_state + dim_action, *hidden_states, 1), squeeze=True)
+        self._dim_state = dim_state
+        self._dim_action = dim_action
+
+        with self.scope:
+            self.op_states = tf.placeholder(tf.float32, [None, dim_state])
+            self.op_actions = tf.placeholder(tf.float32, [None, dim_action])
+
+        self.op_Q = self.forward(self.op_states, self.op_actions)
+
+    @nn.make_method(fetch='Q')
+    def get_q(self, states, actions): pass
diff --git a/experiments05/ant_umaze_1234/src/slbo/random_net.py b/experiments05/ant_umaze_1234/src/slbo/random_net.py
new file mode 100644
index 0000000..c9a94e9
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/random_net.py
@@ -0,0 +1,41 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import List
+import tensorflow as tf
+from lunzi import Tensor
+import lunzi.nn as nn
+from slbo.utils.normalizer import Normalizers
+from slbo.utils.multi_layer_perceptron import MultiLayerPerceptron
+
+
+class RandomNet(MultiLayerPerceptron):
+    op_loss: Tensor
+    op_train: Tensor
+    op_grad_norm: Tensor
+
+    def __init__(self, dim_state: int, dim_action: int, normalizers: Normalizers, hidden_sizes: List[int]):
+        initializer = tf.truncated_normal_initializer(mean=0.0, stddev=1e-5)
+
+        self.dim_state = dim_state
+        self.dim_action = dim_action
+        self.hidden_sizes = hidden_sizes
+        self.op_states = tf.placeholder(tf.float32, shape=[None, self.dim_state], name='states')
+        self.op_actions = tf.placeholder(tf.float32, shape=[None, self.dim_action], name='actions')
+        super().__init__([dim_state + dim_action, *hidden_sizes[:-1]],
+                         activation=nn.ReLU,
+                         weight_initializer=initializer, build=False)
+
+        self.normalizers = normalizers
+        self.build()
+
+    def build(self):
+        self.op_features = self.forward(self.op_states, self.op_actions)
+
+    def forward(self, states, actions):
+        assert actions.shape[-1] == self.dim_action
+        inputs = tf.concat([self.normalizers.state(states), actions.clip_by_value(-1., 1.)], axis=1)
+
+        features = super().forward(inputs)
+        return features
+
+    def clone(self):
+        return RandomNet(self.dim_state, self.dim_action, self.normalizers, self.hidden_sizes)
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/OU_noise.py b/experiments05/ant_umaze_1234/src/slbo/utils/OU_noise.py
new file mode 100644
index 0000000..eae7158
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/OU_noise.py
@@ -0,0 +1,36 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from slbo.policies import BasePolicy
+
+
+class OUNoise(object):
+    _policy: BasePolicy
+
+    def __init__(self, action_space, mu=0.0, theta=0.15, sigma=0.3, shape=None):
+        self.mu = mu
+        self.theta = theta
+        self.sigma = sigma
+        self.action_space = action_space
+        self._state = None
+        if shape:
+            self.shape = shape
+        else:
+            self.shape = action_space.shape
+
+        self.reset()
+
+    def reset(self):
+        self._state = np.ones(self.shape) * self.mu
+
+    def next(self):
+        delta = self.theta * (self.mu - self._state) + self.sigma * np.random.randn(*self._state.shape)
+        self._state = self._state + delta
+        return self._state
+
+    def get_actions(self, states):
+        return self._policy.get_actions(states) + self.next()
+
+    def make(self, policy: BasePolicy):
+        self._policy = policy
+        return self
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/__init__.py b/experiments05/ant_umaze_1234/src/slbo/utils/__init__.py
new file mode 100644
index 0000000..5c7f19c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/__init__.py
@@ -0,0 +1 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/average_meter.py b/experiments05/ant_umaze_1234/src/slbo/utils/average_meter.py
new file mode 100644
index 0000000..b3e285c
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/average_meter.py
@@ -0,0 +1,20 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+class AverageMeter(object):
+    sum: float
+    count: float
+
+    def __init__(self, discount=1.):
+        self.discount = discount
+        self.reset()
+
+    def update(self, value, count=1):
+        self.sum = self.sum * self.discount + value * count
+        self.count = self.count * self.discount + count
+        return self.get()
+
+    def get(self):
+        return self.sum / (self.count + 1.e-8)
+
+    def reset(self):
+        self.sum = 0.
+        self.count = 0.
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/dataset.py b/experiments05/ant_umaze_1234/src/slbo/utils/dataset.py
new file mode 100644
index 0000000..c0046d2
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/dataset.py
@@ -0,0 +1,28 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+import lunzi.dataset as dataset
+import gym
+
+
+def gen_dtype(env: gym.Env, fields: str):
+    dtypes = {
+        'state': ('state', 'f8', env.observation_space.shape),
+        'action': ('action', 'f8', env.action_space.shape),
+        'next_state': ('next_state', 'f8', env.observation_space.shape),
+        'reward': ('reward', 'f8'),
+        'done': ('done', 'bool'),
+        'timeout': ('timeout', 'bool'),
+        'return_': ('return_', 'f8'),
+        'advantage': ('advantage', 'f8'),
+    }
+    return [dtypes[field] for field in fields.split(' ')]
+
+
+class Dataset(dataset.Dataset):
+    def sample_multi_step(self, size: int, n_env: int, n_step=1):
+        starts = np.random.randint(0, self._len, size=size)
+        batch = []
+        for step in range(n_step):
+            batch.append(self[(starts + step * n_env) % self._len])
+        return np.concatenate(batch).reshape(n_step, size).view(np.recarray)
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/flags.py b/experiments05/ant_umaze_1234/src/slbo/utils/flags.py
new file mode 100644
index 0000000..8c7bb40
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/flags.py
@@ -0,0 +1,163 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import time
+import os
+import yaml
+from subprocess import check_output, CalledProcessError
+from lunzi.config import BaseFLAGS, expand, parse
+from lunzi.Logger import logger, FileSink
+
+
+class FLAGS(BaseFLAGS):
+    _initialized = False
+
+    use_prev = True
+    seed = 100
+    log_dir: str = None
+    run_id: str = None
+    algorithm = 'OLBO'  # possible options: OLBO, baseline, MF
+
+    class pc(BaseFLAGS):
+        bonus_scale = 1
+        lamb = 0.01
+        bonus_stop_time= 30
+
+    class slbo(BaseFLAGS):
+        n_iters = 50
+        n_policy_iters = 10
+        n_model_iters = 100
+        n_stages = 100
+        n_evaluate_iters = 5
+        opt_model = False
+        start = 'reset'  # possibly 'buffer'
+
+    class plan(BaseFLAGS):
+        max_steps = 1000
+        n_envs = None
+        n_trpo_samples = 4000
+
+        @classmethod
+        def finalize(cls):
+            if cls.n_envs is None:
+                cls.n_envs = cls.n_trpo_samples // cls.max_steps
+            assert cls.n_envs * cls.max_steps == cls.n_trpo_samples
+
+    class env(BaseFLAGS):
+        id = 'HalfCheetah-v2'
+
+    class rollout(BaseFLAGS):
+        normalizer = 'policy'
+        max_buf_size = 100000
+        n_train_samples = 4000
+        n_dev_samples = 0
+        n_test_samples = 10000
+
+        @classmethod
+        def finalize(cls):
+            cls.n_dev_samples = cls.n_dev_samples or cls.n_train_samples
+
+    class ckpt(BaseFLAGS):
+        n_save_stages = 10
+        model_load = None
+        policy_load = None
+        buf_load = None
+        buf_load_index = 0
+        base = '/tmp/mbrl/logs'
+        warm_up = None
+
+        @classmethod
+        def finalize(cls):
+            for key, value in cls.as_dict().items():
+                if isinstance(value, str):
+                    setattr(cls, key, expand(value))
+
+    class OUNoise(BaseFLAGS):
+        theta = 0.15
+        sigma = 0.3
+
+    class model(BaseFLAGS):
+        hidden_sizes = [500, 500]
+        loss = 'L2'  # possibly L1, L2, MSE, G
+        G_coef = 0.5
+        multi_step = 1
+        lr = 1e-3
+        weight_decay = 1e-5
+        validation_freq = 1
+        optimizer = 'Adam'
+        train_batch_size = 256
+        dev_batch_size = 1024
+
+    class policy(BaseFLAGS):
+        hidden_sizes = [32, 32]
+        init_std = 1.
+
+    class PPO(BaseFLAGS):
+        n_minibatches = 32
+        n_opt_epochs = 10
+        ent_coef = 0.005
+        lr = 3e-4
+        clip_range = 0.2
+
+    class TRPO(BaseFLAGS):
+        cg_damping = 0.1
+        n_cg_iters = 10
+        max_kl = 0.01
+        vf_lr = 1e-3
+        n_vf_iters = 5
+        ent_coef = 0.0
+
+    class runner(BaseFLAGS):
+        lambda_ = 0.95
+        gamma = 0.99
+        max_steps = 500
+
+    @classmethod
+    def set_seed(cls):
+        if cls.seed == 0:  # auto seed
+            cls.seed = int.from_bytes(os.urandom(3), 'little') + 1  # never use seed 0 for RNG, 0 is for `urandom`
+        logger.warning("Setting random seed to %s", cls.seed)
+
+        import numpy as np
+        import tensorflow as tf
+        import random
+        np.random.seed(cls.seed)
+        tf.set_random_seed(np.random.randint(2**30))
+        random.seed(np.random.randint(2**30))
+
+    @classmethod
+    def finalize(cls):
+        log_dir = cls.log_dir
+        if log_dir is None:
+            run_id = cls.run_id
+            if run_id is None:
+                run_id = time.strftime('%Y-%m-%d_%H-%M-%S')
+
+            log_dir = os.path.join(cls.ckpt.base, run_id)
+            cls.log_dir = log_dir
+
+        if not os.path.exists(log_dir):
+            os.makedirs(log_dir)
+
+        for t in range(60):
+            try:
+                cls.commit = check_output(['git', 'rev-parse', 'HEAD']).decode('utf-8').strip()
+                check_output(['git', 'add', '.'])
+                check_output(['git', 'checkout-index', '-a', '-f', f'--prefix={log_dir}/src/'])
+                break
+            except CalledProcessError:
+                pass
+            time.sleep(1)
+        else:
+            raise RuntimeError('Failed after 60 trials.')
+
+        yaml.dump(cls.as_dict(), open(os.path.join(log_dir, 'config.yml'), 'w'), default_flow_style=False)
+        open(os.path.join(log_dir, 'diff.patch'), 'w').write(
+            check_output(['git', '--no-pager', 'diff', 'HEAD']).decode('utf-8'))
+
+        logger.add_sink(FileSink(os.path.join(log_dir, 'log.json')))
+        logger.info("log_dir = %s", log_dir)
+
+        cls.set_frozen()
+
+
+parse(FLAGS)
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/multi_layer_perceptron.py b/experiments05/ant_umaze_1234/src/slbo/utils/multi_layer_perceptron.py
new file mode 100644
index 0000000..0fe5dfe
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/multi_layer_perceptron.py
@@ -0,0 +1,51 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+import numpy as np
+import lunzi.nn as nn
+
+
+class MultiLayerPerceptron(nn.Module):
+    def __init__(self, blocks, activation=nn.ReLU, squeeze=False, weight_initializer=None, build=True):
+        super().__init__()
+
+        self._blocks = blocks
+        if build:
+            self.op_inputs = tf.placeholder(tf.float32, [None, self._blocks[0]])
+
+        with self.scope:
+            kwargs = {}
+            if weight_initializer is not None:
+                kwargs['weight_initializer'] = weight_initializer
+            layers = []
+            for in_features, out_features in zip(blocks[:-1], blocks[1:]):
+                if layers:
+                    layers.append(activation())
+                layers.append(nn.Linear(in_features, out_features, **kwargs))
+            if squeeze:
+                layers.append(nn.Squeeze(axis=1))
+            self.net = nn.Sequential(*layers)
+
+        self._squeeze = squeeze
+        self._activation = activation
+
+        if build:
+            self.build()
+
+    def build(self):
+        self.op_outputs = self.forward(self.op_inputs)
+
+    def forward(self, *inputs):
+        if len(inputs) > 1:
+            inputs = tf.concat(inputs, axis=-1)
+        else:
+            inputs = inputs[0]
+        return self.net(inputs)
+
+    def fast(self, *inputs):
+        return self.net.fast(np.concatenate(inputs, axis=-1))
+
+    def clone(self):
+        return MultiLayerPerceptron(self._blocks, self._activation, self._squeeze)
+
+    def extra_repr(self):
+        return f'activation = {self._activation}, blocks = {self._blocks}, squeeze = {self._squeeze}'
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/normalizer.py b/experiments05/ant_umaze_1234/src/slbo/utils/normalizer.py
new file mode 100644
index 0000000..3bb3685
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/normalizer.py
@@ -0,0 +1,66 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+from typing import List
+import numpy as np
+import tensorflow as tf
+import lunzi.nn as nn
+from lunzi.Logger import logger
+from lunzi import Tensor
+from slbo.utils.np_utils import gaussian_kl
+
+
+class GaussianNormalizer(nn.Module):
+    def __init__(self, name: str, shape: List[int], eps=1e-8, verbose=False):  # batch_size x ...
+        super().__init__()
+
+        self.name = name
+        self.shape = shape
+        self.eps = eps
+        self._verbose = verbose
+
+        with self.scope:
+            self.op_mean = nn.Parameter(tf.zeros(shape, dtype=tf.float32), name='mean', trainable=False)
+            self.op_std = nn.Parameter(tf.ones(shape, dtype=tf.float32), name='std', trainable=False)
+            self.op_n = nn.Parameter(tf.zeros([], dtype=tf.int64), name='n', trainable=False)
+
+    def extra_repr(self):
+        return f'shape={self.shape}'
+
+    def forward(self, x: Tensor, inverse=False):
+        if inverse:
+            return x * self.op_std + self.op_mean
+        return (x - self.op_mean).div(self.op_std.maximum(self.eps))
+
+    def update(self, samples: np.ndarray):
+        old_mean, old_std, old_n = self.op_mean.numpy(), self.op_std.numpy(), self.op_n.numpy()
+        samples = samples - old_mean
+
+        m = samples.shape[0]
+        delta = samples.mean(axis=0)
+        new_n = old_n + m
+        new_mean = old_mean + delta * m / new_n
+        new_std = np.sqrt((old_std**2 * old_n + samples.var(axis=0) * m + delta**2 * old_n * m / new_n) / new_n)
+
+        kl_old_new = gaussian_kl(new_mean, new_std, old_mean, old_std).sum()
+        self.load_state_dict({'op_mean': new_mean, 'op_std': new_std, 'op_n': new_n})
+
+        if self._verbose:
+            logger.info("updating Normalizer<%s>, KL divergence = %.6f", self.name, kl_old_new)
+
+    def fast(self, samples: np.ndarray, inverse=False) -> np.ndarray:
+        mean, std = self.op_mean.numpy(), self.op_std.numpy()
+        if inverse:
+            return samples * std + mean
+        return (samples - mean) / np.maximum(std, self.eps)
+
+
+class Normalizers(nn.Module):
+    def __init__(self, dim_action: int, dim_state: int):
+        super().__init__()
+        self.action = GaussianNormalizer('action', [dim_action])
+        self.state = GaussianNormalizer('state', [dim_state])
+        self.diff = GaussianNormalizer('diff', [dim_state])
+
+    def forward(self):
+        pass
+
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/np_utils.py b/experiments05/ant_umaze_1234/src/slbo/utils/np_utils.py
new file mode 100644
index 0000000..d170ed4
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/np_utils.py
@@ -0,0 +1,9 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+
+
+def gaussian_kl(mean_1: np.ndarray, std_1: np.ndarray, mean_2: np.ndarray, std_2: np.ndarray) -> np.ndarray:
+    eps = 1e-20
+    std_1 = np.maximum(std_1, eps)
+    std_2 = np.maximum(std_2, eps)
+    return np.log(std_2 / std_1) + (std_1**2 + (mean_1 - mean_2)**2) / std_2**2 / 2. - 0.5
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/pc_utils.py b/experiments05/ant_umaze_1234/src/slbo/utils/pc_utils.py
new file mode 100644
index 0000000..d488ef2
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/pc_utils.py
@@ -0,0 +1,58 @@
+import numpy as np
+import copy
+import os
+import scipy.spatial
+import scipy.signal
+
+
+def median_trick(X, args):
+    #median trick for computing the bandwith for kernel regression.
+    N = X.shape[0]
+    #print(X.shape)
+    perm = np.random.choice(N, np.min([N,args.update_size * args.buffer_width]), replace=False)
+    dsample = X[perm]
+    pd = scipy.spatial.distance.pdist(dsample)
+    sigma = np.median(pd)
+    return sigma
+
+def compute_cov_pi(phi):
+    #cov = np.zeros((phi.shape[1],phi.shape[1]))
+
+    #for i in range(len(phi)):
+    #    cov += np.outer(phi[i],phi[i])
+    cov = np.dot(phi.T,phi)
+    cov /= phi.shape[0]
+
+    #print(cov)
+
+    return cov
+
+def discount_cumsum(x, discount):
+    """
+    magic from rllab for computing discounted cumulative sums of vectors.
+    input:
+        vector x,
+        [x0,
+         x1,
+         x2]
+    output:
+        [x0 + discount * x1 + discount^2 * x2,
+         x1 + discount * x2,
+         x2]
+    """
+    return scipy.signal.lfilter([1], [1, float(-discount)], x[::-1], axis=0)[::-1]
+
+
+
+
+def soft_update_from_to(source, target, tau):
+    for target_param, param in zip(target.parameters(), source.parameters()):
+        target_param.data.copy_(
+            target_param.data * (1.0 - tau) + param.data * tau
+        )
+
+def copy_model_params_from_to(source, target):
+    for target_param, param in zip(target.parameters(), source.parameters()):
+        target_param.data.copy_(param.data)
+
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/runner.py b/experiments05/ant_umaze_1234/src/slbo/utils/runner.py
new file mode 100644
index 0000000..774665d
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/runner.py
@@ -0,0 +1,98 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import numpy as np
+from lunzi.dataset import Dataset
+from slbo.envs import BaseBatchedEnv
+from slbo.policies import BasePolicy
+from slbo.utils.dataset import Dataset, gen_dtype
+from slbo.v_function import BaseVFunction
+
+
+class Runner(object):
+    _states: np.ndarray  # [np.float]
+    _n_steps: np.ndarray
+    _returns: np.ndarray
+
+    def __init__(self, env: BaseBatchedEnv, max_steps: int, gamma=0.99, lambda_=0.95, rescale_action=False):
+        self.env = env
+        self.n_envs = env.n_envs
+        self.gamma = gamma
+        self.lambda_ = lambda_
+        self.max_steps = max_steps
+        self.rescale_action = rescale_action
+        self._dtype = gen_dtype(env, 'state action next_state reward done timeout')
+
+        self.reset()
+
+    def reset(self):
+        self.set_state(self.env.reset(), set_env_state=False)
+
+    def set_state(self, states: np.ndarray, set_env_state=True):
+        self._states = states.copy()
+        if set_env_state:
+            self.env.set_state(states)
+        self._n_steps = np.zeros(self.n_envs, 'i4')
+        self._returns = np.zeros(self.n_envs, 'f8')
+
+    def get_state(self):
+        return self._states.copy()
+
+    def run(self, policy: BasePolicy, n_samples: int, render=False):
+        ep_infos = []
+        n_steps = n_samples // self.n_envs
+        assert n_steps * self.n_envs == n_samples
+        dataset = Dataset(self._dtype, n_samples)
+
+        for T in range(n_steps):
+            unscaled_actions = policy.get_actions(self._states)
+            if self.rescale_action:
+                lo, hi = self.env.action_space.low, self.env.action_space.high
+                actions = (lo + (unscaled_actions + 1.) * 0.5 * (hi - lo))
+            else:
+                actions = unscaled_actions
+
+            next_states, rewards, dones, infos = self.env.step(actions)
+            if render:
+                #print(actions)
+                self.env.render()
+            dones = dones.astype(bool)
+            self._returns += rewards
+            self._n_steps += 1
+            timeouts = self._n_steps == self.max_steps
+
+            steps = [self._states.copy(), unscaled_actions, next_states.copy(), rewards, dones, timeouts]
+            dataset.extend(np.rec.fromarrays(steps, dtype=self._dtype))
+
+            indices = np.where(dones | timeouts)[0]
+            if len(indices) > 0:
+                next_states = next_states.copy()
+                next_states[indices] = self.env.partial_reset(indices)
+                for index in indices:
+                    infos[index]['episode'] = {'return': self._returns[index], 'success': (self._returns[index] > 50)}
+                self._n_steps[indices] = 0
+                self._returns[indices] = 0.
+
+            self._states = next_states.copy()
+            ep_infos.extend([info['episode'] for info in infos if 'episode' in info])
+
+        if render:
+            self.env.close()
+
+        return dataset, ep_infos
+
+    def compute_advantage(self, vfn: BaseVFunction, samples: Dataset):
+        n_steps = len(samples) // self.n_envs
+        samples = samples.reshape((n_steps, self.n_envs))
+        use_next_vf = ~samples.done
+        use_next_adv = ~(samples.done | samples.timeout)
+
+        next_values = vfn.get_values(samples[-1].next_state)
+        values = vfn.get_values(samples.reshape(-1).state).reshape(n_steps, self.n_envs)
+        advantages = np.zeros((n_steps, self.n_envs), dtype=np.float32)
+        last_gae_lambda = 0
+
+        for t in reversed(range(n_steps)):
+            delta = samples[t].reward + self.gamma * next_values * use_next_vf[t] - values[t]
+            advantages[t] = last_gae_lambda = delta + self.gamma * self.lambda_ * last_gae_lambda * use_next_adv[t]
+            next_values = values[t]
+        return advantages.reshape(-1), values.reshape(-1)
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/tf_utils.py b/experiments05/ant_umaze_1234/src/slbo/utils/tf_utils.py
new file mode 100644
index 0000000..154c60a
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/tf_utils.py
@@ -0,0 +1,20 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+
+
+def get_tf_config():
+    gpu_frac = 1
+
+    gpu_options = tf.GPUOptions(
+        per_process_gpu_memory_fraction=gpu_frac,
+        allow_growth=True,
+    )
+    config = tf.ConfigProto(
+        gpu_options=gpu_options,
+        log_device_placement=False,
+        allow_soft_placement=True,
+        inter_op_parallelism_threads=1,
+        intra_op_parallelism_threads=1,
+    )
+
+    return config
diff --git a/experiments05/ant_umaze_1234/src/slbo/utils/truncated_normal.py b/experiments05/ant_umaze_1234/src/slbo/utils/truncated_normal.py
new file mode 100644
index 0000000..04a0edc
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/utils/truncated_normal.py
@@ -0,0 +1,12 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+import numpy as np
+
+
+class LimitedEntNormal(tf.distributions.Normal):
+    def _entropy(self):
+        limit = 2.
+        lo, hi = (-limit - self._loc) / self._scale / np.sqrt(2), (limit - self._loc) / self._scale / np.sqrt(2)
+        return 0.5 * (self._scale.log() + np.log(2 * np.pi) / 2) * (hi.erf() - lo.erf()) + 0.5 * \
+            (tf.exp(-hi * hi) * hi - tf.exp(-lo * lo) * lo)
+
diff --git a/experiments05/ant_umaze_1234/src/slbo/v_function/__init__.py b/experiments05/ant_umaze_1234/src/slbo/v_function/__init__.py
new file mode 100644
index 0000000..7794a84
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/v_function/__init__.py
@@ -0,0 +1,13 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import abc
+from typing import Union
+import lunzi.nn as nn
+
+
+class BaseVFunction(abc.ABC):
+    @abc.abstractmethod
+    def get_values(self, states):
+        pass
+
+
+BaseNNVFunction = Union[BaseVFunction, nn.Module]  # in fact it should be Intersection
\ No newline at end of file
diff --git a/experiments05/ant_umaze_1234/src/slbo/v_function/mlp_v_function.py b/experiments05/ant_umaze_1234/src/slbo/v_function/mlp_v_function.py
new file mode 100644
index 0000000..d9749e9
--- /dev/null
+++ b/experiments05/ant_umaze_1234/src/slbo/v_function/mlp_v_function.py
@@ -0,0 +1,24 @@
+# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+import tensorflow as tf
+from baselines.common.tf_util import normc_initializer
+from slbo.utils.multi_layer_perceptron import MultiLayerPerceptron
+import lunzi.nn as nn
+from . import BaseVFunction
+
+
+class MLPVFunction(BaseVFunction, nn.Module):
+    def __init__(self, dim_state, hidden_sizes, normalizer=None):
+        super().__init__()
+        self.mlp = MultiLayerPerceptron((dim_state, *hidden_sizes, 1), activation=nn.Tanh, squeeze=True,
+                                        weight_initializer=normc_initializer(1.), build=False)
+        self.normalizer = normalizer
+        self.op_states = tf.placeholder(tf.float32, shape=[None, dim_state])
+        self.op_values = self.forward(self.op_states)
+
+    def forward(self, states):
+        states = self.normalizer(states)
+        return self.mlp(states)
+
+    @nn.make_method(fetch='values')
+    def get_values(self, states): pass
+
diff --git a/experiments05/ant_umaze_1234/stage-0.npy b/experiments05/ant_umaze_1234/stage-0.npy
new file mode 100644
index 0000000..3081364
Binary files /dev/null and b/experiments05/ant_umaze_1234/stage-0.npy differ
diff --git a/lunzi/__pycache__/Logger.cpython-36.pyc b/lunzi/__pycache__/Logger.cpython-36.pyc
index c62e4dc..cd65096 100644
Binary files a/lunzi/__pycache__/Logger.cpython-36.pyc and b/lunzi/__pycache__/Logger.cpython-36.pyc differ
diff --git a/lunzi/__pycache__/__init__.cpython-36.pyc b/lunzi/__pycache__/__init__.cpython-36.pyc
index d0052a1..bb94071 100644
Binary files a/lunzi/__pycache__/__init__.cpython-36.pyc and b/lunzi/__pycache__/__init__.cpython-36.pyc differ
diff --git a/lunzi/__pycache__/config.cpython-36.pyc b/lunzi/__pycache__/config.cpython-36.pyc
index 38e50cc..151d0cd 100644
Binary files a/lunzi/__pycache__/config.cpython-36.pyc and b/lunzi/__pycache__/config.cpython-36.pyc differ
diff --git a/lunzi/__pycache__/dataset.cpython-36.pyc b/lunzi/__pycache__/dataset.cpython-36.pyc
index f5f173f..673cfda 100644
Binary files a/lunzi/__pycache__/dataset.cpython-36.pyc and b/lunzi/__pycache__/dataset.cpython-36.pyc differ
diff --git a/lunzi/__pycache__/stubs.cpython-36.pyc b/lunzi/__pycache__/stubs.cpython-36.pyc
index 40d1d88..ac6d28a 100644
Binary files a/lunzi/__pycache__/stubs.cpython-36.pyc and b/lunzi/__pycache__/stubs.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/__init__.cpython-36.pyc b/lunzi/nn/__pycache__/__init__.cpython-36.pyc
index 2082353..d28b7c9 100644
Binary files a/lunzi/nn/__pycache__/__init__.cpython-36.pyc and b/lunzi/nn/__pycache__/__init__.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/container.cpython-36.pyc b/lunzi/nn/__pycache__/container.cpython-36.pyc
index fd7039b..f16264f 100644
Binary files a/lunzi/nn/__pycache__/container.cpython-36.pyc and b/lunzi/nn/__pycache__/container.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/flat_param.cpython-36.pyc b/lunzi/nn/__pycache__/flat_param.cpython-36.pyc
index dc8e6f9..792725a 100644
Binary files a/lunzi/nn/__pycache__/flat_param.cpython-36.pyc and b/lunzi/nn/__pycache__/flat_param.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/layers.cpython-36.pyc b/lunzi/nn/__pycache__/layers.cpython-36.pyc
index 3f22fba..9fd6751 100644
Binary files a/lunzi/nn/__pycache__/layers.cpython-36.pyc and b/lunzi/nn/__pycache__/layers.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/loss.cpython-36.pyc b/lunzi/nn/__pycache__/loss.cpython-36.pyc
index 9fa218d..10a1d20 100644
Binary files a/lunzi/nn/__pycache__/loss.cpython-36.pyc and b/lunzi/nn/__pycache__/loss.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/module.cpython-36.pyc b/lunzi/nn/__pycache__/module.cpython-36.pyc
index c0f0f4a..9088e26 100644
Binary files a/lunzi/nn/__pycache__/module.cpython-36.pyc and b/lunzi/nn/__pycache__/module.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/parameter.cpython-36.pyc b/lunzi/nn/__pycache__/parameter.cpython-36.pyc
index 5191416..2131727 100644
Binary files a/lunzi/nn/__pycache__/parameter.cpython-36.pyc and b/lunzi/nn/__pycache__/parameter.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/patch.cpython-36.pyc b/lunzi/nn/__pycache__/patch.cpython-36.pyc
index d535500..78a52be 100644
Binary files a/lunzi/nn/__pycache__/patch.cpython-36.pyc and b/lunzi/nn/__pycache__/patch.cpython-36.pyc differ
diff --git a/lunzi/nn/__pycache__/utils.cpython-36.pyc b/lunzi/nn/__pycache__/utils.cpython-36.pyc
index 1c808e8..f1860e7 100644
Binary files a/lunzi/nn/__pycache__/utils.cpython-36.pyc and b/lunzi/nn/__pycache__/utils.cpython-36.pyc differ
diff --git a/run2.sh b/run2.sh
new file mode 100644
index 0000000..7440dc5
--- /dev/null
+++ b/run2.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+for env_name in $1; do
+    echo "=> Running environment ${env_name}"
+    #for random_seed in 1234 2314 2345 1235; do
+    for random_seed in 1234; do
+        python main.py -c configs/algos/slbo_bm_200k.yml configs/env_tingwu/${env_name}.yml \
+	    -s pc.bonus_scale=0.2 log_dir=./experiments02/${env_name}_${random_seed} seed=${random_seed}
+    done
+done
diff --git a/run_experiments.sh b/run_experiments.sh
index 37ce016..e3f2ad7 100644
--- a/run_experiments.sh
+++ b/run_experiments.sh
@@ -3,8 +3,8 @@
 for env_name in $1; do
     echo "=> Running environment ${env_name}"
     #for random_seed in 1234 2314 2345 1235; do
-    for random_seed in 19; do
+    for random_seed in 1234; do
         python main.py -c configs/algos/slbo_bm_200k.yml configs/env_tingwu/${env_name}.yml \
-	    -s log_dir=./experiments/${env_name}_${random_seed} seed=${random_seed}
+	    -s pc.bonus_scale=0.5 log_dir=./experiments05/${env_name}_${random_seed} seed=${random_seed}
     done
 done
diff --git a/slbo/__pycache__/__init__.cpython-36.pyc b/slbo/__pycache__/__init__.cpython-36.pyc
index 069fa36..6a33858 100644
Binary files a/slbo/__pycache__/__init__.cpython-36.pyc and b/slbo/__pycache__/__init__.cpython-36.pyc differ
diff --git a/slbo/__pycache__/dynamics_model.cpython-36.pyc b/slbo/__pycache__/dynamics_model.cpython-36.pyc
index d9193cb..91423ce 100644
Binary files a/slbo/__pycache__/dynamics_model.cpython-36.pyc and b/slbo/__pycache__/dynamics_model.cpython-36.pyc differ
diff --git a/slbo/__pycache__/partial_envs.cpython-36.pyc b/slbo/__pycache__/partial_envs.cpython-36.pyc
index f20520d..7ad21fc 100644
Binary files a/slbo/__pycache__/partial_envs.cpython-36.pyc and b/slbo/__pycache__/partial_envs.cpython-36.pyc differ
diff --git a/slbo/__pycache__/random_net.cpython-36.pyc b/slbo/__pycache__/random_net.cpython-36.pyc
index 7688576..6e866b0 100644
Binary files a/slbo/__pycache__/random_net.cpython-36.pyc and b/slbo/__pycache__/random_net.cpython-36.pyc differ
diff --git a/slbo/algos/__pycache__/TRPO.cpython-36.pyc b/slbo/algos/__pycache__/TRPO.cpython-36.pyc
index 99cdd6a..9ba8329 100644
Binary files a/slbo/algos/__pycache__/TRPO.cpython-36.pyc and b/slbo/algos/__pycache__/TRPO.cpython-36.pyc differ
diff --git a/slbo/algos/__pycache__/__init__.cpython-36.pyc b/slbo/algos/__pycache__/__init__.cpython-36.pyc
index 09f2f9c..9c74708 100644
Binary files a/slbo/algos/__pycache__/__init__.cpython-36.pyc and b/slbo/algos/__pycache__/__init__.cpython-36.pyc differ
diff --git a/slbo/loss/__pycache__/__init__.cpython-36.pyc b/slbo/loss/__pycache__/__init__.cpython-36.pyc
index f1c5979..cc5457b 100644
Binary files a/slbo/loss/__pycache__/__init__.cpython-36.pyc and b/slbo/loss/__pycache__/__init__.cpython-36.pyc differ
diff --git a/slbo/loss/__pycache__/multi_step_loss.cpython-36.pyc b/slbo/loss/__pycache__/multi_step_loss.cpython-36.pyc
index 53c9a3d..695e469 100644
Binary files a/slbo/loss/__pycache__/multi_step_loss.cpython-36.pyc and b/slbo/loss/__pycache__/multi_step_loss.cpython-36.pyc differ
diff --git a/slbo/policies/__pycache__/__init__.cpython-36.pyc b/slbo/policies/__pycache__/__init__.cpython-36.pyc
index a98e999..0f2ff6d 100644
Binary files a/slbo/policies/__pycache__/__init__.cpython-36.pyc and b/slbo/policies/__pycache__/__init__.cpython-36.pyc differ
diff --git a/slbo/policies/__pycache__/gaussian_mlp_policy.cpython-36.pyc b/slbo/policies/__pycache__/gaussian_mlp_policy.cpython-36.pyc
index b355a90..3f0a156 100644
Binary files a/slbo/policies/__pycache__/gaussian_mlp_policy.cpython-36.pyc and b/slbo/policies/__pycache__/gaussian_mlp_policy.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/OU_noise.cpython-36.pyc b/slbo/utils/__pycache__/OU_noise.cpython-36.pyc
index 5819e5d..bdfb380 100644
Binary files a/slbo/utils/__pycache__/OU_noise.cpython-36.pyc and b/slbo/utils/__pycache__/OU_noise.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/__init__.cpython-36.pyc b/slbo/utils/__pycache__/__init__.cpython-36.pyc
index 0e85b1e..9df4fd9 100644
Binary files a/slbo/utils/__pycache__/__init__.cpython-36.pyc and b/slbo/utils/__pycache__/__init__.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/average_meter.cpython-36.pyc b/slbo/utils/__pycache__/average_meter.cpython-36.pyc
index 1bc0297..7fa8339 100644
Binary files a/slbo/utils/__pycache__/average_meter.cpython-36.pyc and b/slbo/utils/__pycache__/average_meter.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/dataset.cpython-36.pyc b/slbo/utils/__pycache__/dataset.cpython-36.pyc
index 0cc5d73..46a212c 100644
Binary files a/slbo/utils/__pycache__/dataset.cpython-36.pyc and b/slbo/utils/__pycache__/dataset.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/flags.cpython-36.pyc b/slbo/utils/__pycache__/flags.cpython-36.pyc
index dfd7feb..193bff4 100644
Binary files a/slbo/utils/__pycache__/flags.cpython-36.pyc and b/slbo/utils/__pycache__/flags.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/multi_layer_perceptron.cpython-36.pyc b/slbo/utils/__pycache__/multi_layer_perceptron.cpython-36.pyc
index ae136c1..eceaef9 100644
Binary files a/slbo/utils/__pycache__/multi_layer_perceptron.cpython-36.pyc and b/slbo/utils/__pycache__/multi_layer_perceptron.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/normalizer.cpython-36.pyc b/slbo/utils/__pycache__/normalizer.cpython-36.pyc
index 8c67648..574fc2b 100644
Binary files a/slbo/utils/__pycache__/normalizer.cpython-36.pyc and b/slbo/utils/__pycache__/normalizer.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/np_utils.cpython-36.pyc b/slbo/utils/__pycache__/np_utils.cpython-36.pyc
index e1f3150..d9d1d69 100644
Binary files a/slbo/utils/__pycache__/np_utils.cpython-36.pyc and b/slbo/utils/__pycache__/np_utils.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/pc_utils.cpython-36.pyc b/slbo/utils/__pycache__/pc_utils.cpython-36.pyc
index 0e894f3..b76bb46 100644
Binary files a/slbo/utils/__pycache__/pc_utils.cpython-36.pyc and b/slbo/utils/__pycache__/pc_utils.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/runner.cpython-36.pyc b/slbo/utils/__pycache__/runner.cpython-36.pyc
index 2678071..cce1028 100644
Binary files a/slbo/utils/__pycache__/runner.cpython-36.pyc and b/slbo/utils/__pycache__/runner.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/tf_utils.cpython-36.pyc b/slbo/utils/__pycache__/tf_utils.cpython-36.pyc
index 47606c4..59378e0 100644
Binary files a/slbo/utils/__pycache__/tf_utils.cpython-36.pyc and b/slbo/utils/__pycache__/tf_utils.cpython-36.pyc differ
diff --git a/slbo/utils/__pycache__/truncated_normal.cpython-36.pyc b/slbo/utils/__pycache__/truncated_normal.cpython-36.pyc
index 6d8d1b4..a615a74 100644
Binary files a/slbo/utils/__pycache__/truncated_normal.cpython-36.pyc and b/slbo/utils/__pycache__/truncated_normal.cpython-36.pyc differ
diff --git a/slbo/v_function/__pycache__/__init__.cpython-36.pyc b/slbo/v_function/__pycache__/__init__.cpython-36.pyc
index a38ef07..5932be7 100644
Binary files a/slbo/v_function/__pycache__/__init__.cpython-36.pyc and b/slbo/v_function/__pycache__/__init__.cpython-36.pyc differ
diff --git a/slbo/v_function/__pycache__/mlp_v_function.cpython-36.pyc b/slbo/v_function/__pycache__/mlp_v_function.cpython-36.pyc
index dba380d..06cd147 100644
Binary files a/slbo/v_function/__pycache__/mlp_v_function.cpython-36.pyc and b/slbo/v_function/__pycache__/mlp_v_function.cpython-36.pyc differ
